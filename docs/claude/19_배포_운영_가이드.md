# K-ERP 배포 운영 가이드

## 목차

1. [개요](#1-개요)
2. [배포 환경 구성](#2-배포-환경-구성)
3. [Kubernetes 클러스터 관리](#3-kubernetes-클러스터-관리)
4. [배포 프로세스](#4-배포-프로세스)
5. [운영 모니터링](#5-운영-모니터링)
6. [스케일링 전략](#6-스케일링-전략)
7. [장애 대응](#7-장애-대응)
8. [보안 운영](#8-보안-운영)
9. [백업 및 복구](#9-백업-및-복구)
10. [운영 체크리스트](#10-운영-체크리스트)

---

## 1. 개요

### 1.1 배포 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Production Environment                           │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐   ┌─────────────────────────────────────────────────┐ │
│  │   AWS WAF   │   │              AWS EKS Cluster                    │ │
│  │  + Shield   │   │  ┌─────────────────────────────────────────┐   │ │
│  └──────┬──────┘   │  │         Kubernetes Namespace: kerp       │   │ │
│         │          │  │  ┌─────────────┐  ┌─────────────┐       │   │ │
│  ┌──────▼──────┐   │  │  │  Go API     │  │  Go Worker  │       │   │ │
│  │    ALB      │───┼──┼─▶│  Replicas:3 │  │  Replicas:2 │       │   │ │
│  │ Ingress     │   │  │  └─────────────┘  └─────────────┘       │   │ │
│  └─────────────┘   │  │  ┌─────────────┐  ┌─────────────┐       │   │ │
│                    │  │  │  Python     │  │  Python     │       │   │ │
│                    │  │  │  tax-scraper│  │  ins-edi    │       │   │ │
│                    │  │  │  Replicas:2 │  │  Replicas:2 │       │   │ │
│                    │  │  └─────────────┘  └─────────────┘       │   │ │
│                    │  └─────────────────────────────────────────┘   │ │
│                    └─────────────────────────────────────────────────┘ │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    AWS Managed Services                          │   │
│  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────────┐   │   │
│  │  │ RDS       │ │Elasticache│ │    S3     │ │ CloudWatch    │   │   │
│  │  │PostgreSQL │ │  Redis    │ │  Bucket   │ │ Logs/Metrics  │   │   │
│  │  │ Multi-AZ  │ │  Cluster  │ │           │ │               │   │   │
│  │  └───────────┘ └───────────┘ └───────────┘ └───────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 환경 구분

| 환경 | 용도 | 클러스터 | 데이터베이스 |
|------|------|----------|--------------|
| Development | 개발/테스트 | Local K3s | Docker PostgreSQL |
| Staging | QA/검증 | EKS (t3.medium x3) | RDS db.t3.medium |
| Production | 운영 | EKS (m5.xlarge x5) | RDS db.r5.large Multi-AZ |

---

## 2. 배포 환경 구성

### 2.1 AWS 인프라 Terraform

```hcl
# infrastructure/terraform/main.tf

terraform {
  required_version = ">= 1.0"

  backend "s3" {
    bucket         = "kerp-terraform-state"
    key            = "prod/terraform.tfstate"
    region         = "ap-northeast-2"
    encrypt        = true
    dynamodb_table = "kerp-terraform-locks"
  }

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.23"
    }
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      Project     = "K-ERP"
      Environment = var.environment
      ManagedBy   = "Terraform"
    }
  }
}

# VPC Configuration
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.1.2"

  name = "kerp-${var.environment}-vpc"
  cidr = var.vpc_cidr

  azs             = ["ap-northeast-2a", "ap-northeast-2b", "ap-northeast-2c"]
  private_subnets = var.private_subnets
  public_subnets  = var.public_subnets

  enable_nat_gateway     = true
  single_nat_gateway     = var.environment != "prod"
  enable_dns_hostnames   = true
  enable_dns_support     = true

  public_subnet_tags = {
    "kubernetes.io/role/elb"                    = 1
    "kubernetes.io/cluster/kerp-${var.environment}" = "owned"
  }

  private_subnet_tags = {
    "kubernetes.io/role/internal-elb"           = 1
    "kubernetes.io/cluster/kerp-${var.environment}" = "owned"
  }
}

# EKS Cluster
module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "19.16.0"

  cluster_name    = "kerp-${var.environment}"
  cluster_version = "1.28"

  vpc_id                         = module.vpc.vpc_id
  subnet_ids                     = module.vpc.private_subnets
  cluster_endpoint_public_access = true

  eks_managed_node_groups = {
    main = {
      name = "kerp-${var.environment}-main"

      instance_types = var.node_instance_types
      capacity_type  = var.environment == "prod" ? "ON_DEMAND" : "SPOT"

      min_size     = var.node_min_size
      max_size     = var.node_max_size
      desired_size = var.node_desired_size

      labels = {
        Environment = var.environment
        NodeGroup   = "main"
      }

      taints = []
    }

    # Python services dedicated node group (for isolation)
    python = {
      name = "kerp-${var.environment}-python"

      instance_types = ["t3.large"]
      capacity_type  = var.environment == "prod" ? "ON_DEMAND" : "SPOT"

      min_size     = 1
      max_size     = 4
      desired_size = 2

      labels = {
        Environment = var.environment
        NodeGroup   = "python"
        ServiceType = "python"
      }

      taints = [
        {
          key    = "service-type"
          value  = "python"
          effect = "NO_SCHEDULE"
        }
      ]
    }
  }

  # Cluster addons
  cluster_addons = {
    coredns = {
      most_recent = true
    }
    kube-proxy = {
      most_recent = true
    }
    vpc-cni = {
      most_recent = true
    }
    aws-ebs-csi-driver = {
      most_recent = true
    }
  }
}

# RDS PostgreSQL
module "rds" {
  source  = "terraform-aws-modules/rds/aws"
  version = "6.1.1"

  identifier = "kerp-${var.environment}"

  engine               = "postgres"
  engine_version       = "16.1"
  family               = "postgres16"
  major_engine_version = "16"
  instance_class       = var.db_instance_class

  allocated_storage     = var.db_allocated_storage
  max_allocated_storage = var.db_max_allocated_storage

  db_name  = "kerp"
  username = "kerp_admin"
  port     = 5432

  multi_az               = var.environment == "prod"
  db_subnet_group_name   = module.vpc.database_subnet_group_name
  vpc_security_group_ids = [aws_security_group.rds.id]

  maintenance_window              = "Mon:00:00-Mon:03:00"
  backup_window                   = "03:00-06:00"
  backup_retention_period         = var.environment == "prod" ? 30 : 7

  performance_insights_enabled          = true
  performance_insights_retention_period = var.environment == "prod" ? 731 : 7

  deletion_protection = var.environment == "prod"
  skip_final_snapshot = var.environment != "prod"

  parameters = [
    {
      name  = "log_statement"
      value = "all"
    },
    {
      name  = "log_min_duration_statement"
      value = "1000"  # Log queries taking more than 1 second
    },
    {
      name  = "shared_preload_libraries"
      value = "pg_stat_statements"
    }
  ]
}

# ElastiCache Redis
module "elasticache" {
  source  = "terraform-aws-modules/elasticache/aws"
  version = "1.0.0"

  cluster_id           = "kerp-${var.environment}"
  engine               = "redis"
  engine_version       = "7.0"
  node_type            = var.redis_node_type
  num_cache_nodes      = var.environment == "prod" ? 3 : 1
  parameter_group_name = "default.redis7"
  port                 = 6379

  subnet_group_name  = module.vpc.elasticache_subnet_group_name
  security_group_ids = [aws_security_group.redis.id]

  automatic_failover_enabled = var.environment == "prod"
  multi_az_enabled          = var.environment == "prod"

  snapshot_retention_limit = var.environment == "prod" ? 7 : 1
  snapshot_window         = "05:00-09:00"

  at_rest_encryption_enabled = true
  transit_encryption_enabled = true
}
```

### 2.2 환경별 변수

```hcl
# infrastructure/terraform/environments/prod.tfvars

aws_region  = "ap-northeast-2"
environment = "prod"

# VPC
vpc_cidr        = "10.0.0.0/16"
private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]

# EKS
node_instance_types = ["m5.xlarge"]
node_min_size       = 3
node_max_size       = 10
node_desired_size   = 5

# RDS
db_instance_class       = "db.r5.large"
db_allocated_storage    = 100
db_max_allocated_storage = 500

# Redis
redis_node_type = "cache.r5.large"
```

---

## 3. Kubernetes 클러스터 관리

### 3.1 Namespace 구성

```yaml
# deployments/kubernetes/namespaces.yaml

apiVersion: v1
kind: Namespace
metadata:
  name: kerp
  labels:
    name: kerp
    istio-injection: enabled
---
apiVersion: v1
kind: Namespace
metadata:
  name: kerp-monitoring
  labels:
    name: kerp-monitoring
---
apiVersion: v1
kind: Namespace
metadata:
  name: kerp-logging
  labels:
    name: kerp-logging
```

### 3.2 Resource Quotas

```yaml
# deployments/kubernetes/resource-quota.yaml

apiVersion: v1
kind: ResourceQuota
metadata:
  name: kerp-quota
  namespace: kerp
spec:
  hard:
    requests.cpu: "20"
    requests.memory: "40Gi"
    limits.cpu: "40"
    limits.memory: "80Gi"
    persistentvolumeclaims: "20"
    pods: "100"
    services: "30"
    secrets: "100"
    configmaps: "100"
---
apiVersion: v1
kind: LimitRange
metadata:
  name: kerp-limits
  namespace: kerp
spec:
  limits:
    - type: Container
      default:
        cpu: "500m"
        memory: "512Mi"
      defaultRequest:
        cpu: "100m"
        memory: "128Mi"
      min:
        cpu: "50m"
        memory: "64Mi"
      max:
        cpu: "4"
        memory: "8Gi"
    - type: Pod
      max:
        cpu: "8"
        memory: "16Gi"
```

### 3.3 Network Policies

```yaml
# deployments/kubernetes/network-policies.yaml

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: kerp
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-api-ingress
  namespace: kerp
spec:
  podSelector:
    matchLabels:
      app: kerp-api
  policyTypes:
    - Ingress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 8080
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-to-python-grpc
  namespace: kerp
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/component: python-service
  policyTypes:
    - Ingress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: kerp-api
      ports:
        - protocol: TCP
          port: 50051
        - protocol: TCP
          port: 50052
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-egress-external
  namespace: kerp
spec:
  podSelector: {}
  policyTypes:
    - Egress
  egress:
    # DNS
    - to:
        - namespaceSelector: {}
      ports:
        - protocol: UDP
          port: 53
    # AWS Services (RDS, ElastiCache, S3)
    - to:
        - ipBlock:
            cidr: 10.0.0.0/16
    # External APIs (Popbill, NTS, etc.)
    - to:
        - ipBlock:
            cidr: 0.0.0.0/0
            except:
              - 10.0.0.0/8
              - 172.16.0.0/12
              - 192.168.0.0/16
      ports:
        - protocol: TCP
          port: 443
```

### 3.4 RBAC 설정

```yaml
# deployments/kubernetes/rbac.yaml

apiVersion: v1
kind: ServiceAccount
metadata:
  name: kerp-api
  namespace: kerp
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: kerp-worker
  namespace: kerp
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: kerp-api-role
  namespace: kerp
rules:
  - apiGroups: [""]
    resources: ["configmaps", "secrets"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: kerp-api-binding
  namespace: kerp
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: kerp-api-role
subjects:
  - kind: ServiceAccount
    name: kerp-api
    namespace: kerp
```

---

## 4. 배포 프로세스

### 4.1 Blue-Green 배포

```yaml
# deployments/kubernetes/blue-green/deployment.yaml

apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: kerp-api
  namespace: kerp
spec:
  replicas: 3
  strategy:
    blueGreen:
      activeService: kerp-api-active
      previewService: kerp-api-preview
      autoPromotionEnabled: false
      scaleDownDelaySeconds: 30
      prePromotionAnalysis:
        templates:
          - templateName: success-rate
        args:
          - name: service-name
            value: kerp-api-preview
      postPromotionAnalysis:
        templates:
          - templateName: success-rate
        args:
          - name: service-name
            value: kerp-api-active
  revisionHistoryLimit: 3
  selector:
    matchLabels:
      app: kerp-api
  template:
    metadata:
      labels:
        app: kerp-api
    spec:
      serviceAccountName: kerp-api
      containers:
        - name: api
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          ports:
            - containerPort: 8080
          envFrom:
            - configMapRef:
                name: kerp-config
            - secretRef:
                name: kerp-secrets
          resources:
            requests:
              cpu: "500m"
              memory: "512Mi"
            limits:
              cpu: "2"
              memory: "2Gi"
          livenessProbe:
            httpGet:
              path: /health/live
              port: 8080
            initialDelaySeconds: 15
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health/ready
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
---
apiVersion: argoproj.io/v1alpha1
kind: AnalysisTemplate
metadata:
  name: success-rate
  namespace: kerp
spec:
  args:
    - name: service-name
  metrics:
    - name: success-rate
      interval: 30s
      successCondition: result[0] >= 0.95
      failureLimit: 3
      provider:
        prometheus:
          address: http://prometheus.kerp-monitoring:9090
          query: |
            sum(rate(http_requests_total{service="{{args.service-name}}",status=~"2.."}[5m]))
            /
            sum(rate(http_requests_total{service="{{args.service-name}}"}[5m]))
```

### 4.2 Canary 배포

```yaml
# deployments/kubernetes/canary/rollout.yaml

apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: kerp-api-canary
  namespace: kerp
spec:
  replicas: 5
  strategy:
    canary:
      canaryService: kerp-api-canary
      stableService: kerp-api-stable
      trafficRouting:
        nginx:
          stableIngress: kerp-api-ingress
          annotationPrefix: nginx.ingress.kubernetes.io
      steps:
        # 5% traffic to canary
        - setWeight: 5
        - pause: { duration: 5m }
        # Analyze metrics
        - analysis:
            templates:
              - templateName: canary-analysis
            args:
              - name: service-name
                value: kerp-api-canary
        # 25% traffic
        - setWeight: 25
        - pause: { duration: 10m }
        # 50% traffic
        - setWeight: 50
        - pause: { duration: 10m }
        # 75% traffic
        - setWeight: 75
        - pause: { duration: 5m }
        # Full promotion
  revisionHistoryLimit: 3
  selector:
    matchLabels:
      app: kerp-api
  template:
    metadata:
      labels:
        app: kerp-api
    spec:
      containers:
        - name: api
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          ports:
            - containerPort: 8080
          resources:
            requests:
              cpu: "500m"
              memory: "512Mi"
            limits:
              cpu: "2"
              memory: "2Gi"
```

### 4.3 배포 스크립트

```bash
#!/bin/bash
# scripts/deploy.sh

set -euo pipefail

# Configuration
ENVIRONMENT=${1:-staging}
VERSION=${2:-latest}
DRY_RUN=${3:-false}

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Pre-deployment checks
pre_deploy_check() {
    log_info "Running pre-deployment checks..."

    # Check kubectl connection
    if ! kubectl cluster-info &> /dev/null; then
        log_error "Cannot connect to Kubernetes cluster"
        exit 1
    fi

    # Check namespace exists
    if ! kubectl get namespace kerp &> /dev/null; then
        log_error "Namespace 'kerp' does not exist"
        exit 1
    fi

    # Check image exists
    IMAGE="kerp-api:${VERSION}"
    if ! docker manifest inspect ${IMAGE} &> /dev/null; then
        log_error "Image ${IMAGE} not found"
        exit 1
    fi

    # Run database migration check
    log_info "Checking pending migrations..."
    PENDING=$(kubectl exec -n kerp deploy/kerp-api -- /app/migrate status 2>/dev/null | grep -c "pending" || true)
    if [ "$PENDING" -gt 0 ]; then
        log_warn "Found ${PENDING} pending migration(s)"
    fi

    log_info "Pre-deployment checks passed"
}

# Apply database migrations
apply_migrations() {
    log_info "Applying database migrations..."

    # Create migration job
    cat <<EOF | kubectl apply -f -
apiVersion: batch/v1
kind: Job
metadata:
  name: kerp-migration-${VERSION}
  namespace: kerp
spec:
  backoffLimit: 3
  template:
    spec:
      restartPolicy: Never
      containers:
        - name: migrate
          image: kerp-api:${VERSION}
          command: ["/app/migrate", "up"]
          envFrom:
            - secretRef:
                name: kerp-secrets
EOF

    # Wait for migration job to complete
    kubectl wait --for=condition=complete job/kerp-migration-${VERSION} -n kerp --timeout=300s

    log_info "Migrations completed successfully"
}

# Deploy services
deploy_services() {
    log_info "Deploying services to ${ENVIRONMENT}..."

    # Set values based on environment
    VALUES_FILE="deployments/helm/values-${ENVIRONMENT}.yaml"

    if [ "$DRY_RUN" = "true" ]; then
        log_info "Running in dry-run mode"
        HELM_FLAGS="--dry-run"
    else
        HELM_FLAGS=""
    fi

    # Deploy Go API
    log_info "Deploying Go API..."
    helm upgrade --install kerp-api ./deployments/helm/kerp-api \
        -n kerp \
        -f ${VALUES_FILE} \
        --set image.tag=${VERSION} \
        --wait \
        --timeout 10m \
        ${HELM_FLAGS}

    # Deploy Go Worker
    log_info "Deploying Go Worker..."
    helm upgrade --install kerp-worker ./deployments/helm/kerp-worker \
        -n kerp \
        -f ${VALUES_FILE} \
        --set image.tag=${VERSION} \
        --wait \
        --timeout 5m \
        ${HELM_FLAGS}

    # Deploy Python Tax Scraper
    log_info "Deploying Python Tax Scraper..."
    helm upgrade --install kerp-tax-scraper ./deployments/helm/kerp-python \
        -n kerp \
        -f ${VALUES_FILE} \
        --set image.tag=${VERSION} \
        --set service.name=tax-scraper \
        --set service.port=50051 \
        --wait \
        --timeout 5m \
        ${HELM_FLAGS}

    # Deploy Python Insurance EDI
    log_info "Deploying Python Insurance EDI..."
    helm upgrade --install kerp-insurance-edi ./deployments/helm/kerp-python \
        -n kerp \
        -f ${VALUES_FILE} \
        --set image.tag=${VERSION} \
        --set service.name=insurance-edi \
        --set service.port=50052 \
        --wait \
        --timeout 5m \
        ${HELM_FLAGS}

    log_info "All services deployed successfully"
}

# Post-deployment verification
post_deploy_verify() {
    log_info "Running post-deployment verification..."

    # Check all pods are running
    log_info "Checking pod status..."
    kubectl get pods -n kerp -l app.kubernetes.io/instance=kerp

    # Wait for all pods to be ready
    kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=kerp -n kerp --timeout=300s

    # Run health checks
    log_info "Running health checks..."

    API_POD=$(kubectl get pods -n kerp -l app=kerp-api -o jsonpath='{.items[0].metadata.name}')

    # Check API health
    kubectl exec -n kerp ${API_POD} -- curl -sf http://localhost:8080/health/ready

    # Check gRPC connections to Python services
    kubectl exec -n kerp ${API_POD} -- grpc_health_probe -addr=tax-scraper:50051
    kubectl exec -n kerp ${API_POD} -- grpc_health_probe -addr=insurance-edi:50052

    log_info "Post-deployment verification passed"
}

# Rollback function
rollback() {
    log_error "Deployment failed, initiating rollback..."

    helm rollback kerp-api -n kerp
    helm rollback kerp-worker -n kerp
    helm rollback kerp-tax-scraper -n kerp
    helm rollback kerp-insurance-edi -n kerp

    log_info "Rollback completed"
    exit 1
}

# Main deployment flow
main() {
    log_info "Starting deployment of version ${VERSION} to ${ENVIRONMENT}"

    # Set up error handling for rollback
    trap rollback ERR

    pre_deploy_check
    apply_migrations
    deploy_services
    post_deploy_verify

    log_info "Deployment completed successfully!"

    # Send notification
    if command -v slack-notify &> /dev/null; then
        slack-notify "K-ERP ${VERSION} deployed to ${ENVIRONMENT} successfully"
    fi
}

main
```

---

## 5. 운영 모니터링

### 5.1 Prometheus 알림 규칙

```yaml
# deployments/monitoring/prometheus-rules.yaml

apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: kerp-alerts
  namespace: kerp-monitoring
spec:
  groups:
    - name: kerp.api
      interval: 30s
      rules:
        # High error rate
        - alert: HighErrorRate
          expr: |
            sum(rate(http_requests_total{job="kerp-api",status=~"5.."}[5m]))
            /
            sum(rate(http_requests_total{job="kerp-api"}[5m])) > 0.05
          for: 5m
          labels:
            severity: critical
            service: kerp-api
          annotations:
            summary: "High error rate detected"
            description: "Error rate is {{ $value | humanizePercentage }} (threshold: 5%)"
            runbook_url: "https://wiki.kerp.io/runbooks/high-error-rate"

        # High latency
        - alert: HighLatency
          expr: |
            histogram_quantile(0.95,
              sum(rate(http_request_duration_seconds_bucket{job="kerp-api"}[5m])) by (le)
            ) > 0.5
          for: 5m
          labels:
            severity: warning
            service: kerp-api
          annotations:
            summary: "High API latency detected"
            description: "P95 latency is {{ $value }}s (threshold: 500ms)"

        # Pod not ready
        - alert: PodNotReady
          expr: |
            kube_pod_status_ready{namespace="kerp",condition="true"} == 0
          for: 5m
          labels:
            severity: warning
          annotations:
            summary: "Pod {{ $labels.pod }} is not ready"
            description: "Pod has been not ready for more than 5 minutes"

    - name: kerp.database
      interval: 30s
      rules:
        # Database connection pool exhaustion
        - alert: DatabaseConnectionPoolExhausted
          expr: |
            kerp_db_pool_idle_connections / kerp_db_pool_max_connections < 0.1
          for: 5m
          labels:
            severity: critical
            service: database
          annotations:
            summary: "Database connection pool nearly exhausted"
            description: "Only {{ $value | humanizePercentage }} connections available"

        # Slow queries
        - alert: SlowQueries
          expr: |
            rate(kerp_db_slow_queries_total[5m]) > 1
          for: 10m
          labels:
            severity: warning
            service: database
          annotations:
            summary: "High rate of slow database queries"
            description: "{{ $value }} slow queries per second"

    - name: kerp.python-services
      interval: 30s
      rules:
        # Python gRPC service down
        - alert: PythonServiceDown
          expr: |
            up{job=~"kerp-tax-scraper|kerp-insurance-edi"} == 0
          for: 2m
          labels:
            severity: critical
          annotations:
            summary: "Python service {{ $labels.job }} is down"
            description: "Service has been unavailable for more than 2 minutes"

        # High gRPC error rate
        - alert: GRPCHighErrorRate
          expr: |
            sum(rate(grpc_server_handled_total{job=~"kerp-tax-scraper|kerp-insurance-edi",grpc_code!="OK"}[5m])) by (job)
            /
            sum(rate(grpc_server_handled_total{job=~"kerp-tax-scraper|kerp-insurance-edi"}[5m])) by (job) > 0.1
          for: 5m
          labels:
            severity: warning
          annotations:
            summary: "High gRPC error rate on {{ $labels.job }}"
            description: "Error rate is {{ $value | humanizePercentage }}"

    - name: kerp.business
      interval: 1m
      rules:
        # Invoice processing failures
        - alert: InvoiceProcessingFailures
          expr: |
            sum(rate(kerp_invoice_processing_failures_total[15m])) > 0.1
          for: 15m
          labels:
            severity: warning
            service: invoices
          annotations:
            summary: "Invoice processing failures detected"
            description: "{{ $value }} failures per second over the last 15 minutes"

        # Insurance EDI sync failures
        - alert: InsuranceEDISyncFailure
          expr: |
            kerp_insurance_edi_last_success_timestamp < (time() - 86400)
          for: 30m
          labels:
            severity: critical
            service: insurance
          annotations:
            summary: "Insurance EDI sync has not succeeded in 24 hours"
            description: "Last successful sync was {{ $value | humanizeDuration }} ago"
```

### 5.2 Grafana 대시보드

```json
{
  "dashboard": {
    "title": "K-ERP Operations Dashboard",
    "uid": "kerp-ops",
    "timezone": "Asia/Seoul",
    "refresh": "30s",
    "panels": [
      {
        "title": "Request Rate",
        "type": "stat",
        "gridPos": { "x": 0, "y": 0, "w": 4, "h": 4 },
        "targets": [
          {
            "expr": "sum(rate(http_requests_total{job=\"kerp-api\"}[5m]))",
            "legendFormat": "Requests/s"
          }
        ],
        "options": {
          "colorMode": "value",
          "graphMode": "area"
        }
      },
      {
        "title": "Error Rate",
        "type": "stat",
        "gridPos": { "x": 4, "y": 0, "w": 4, "h": 4 },
        "targets": [
          {
            "expr": "sum(rate(http_requests_total{job=\"kerp-api\",status=~\"5..\"}[5m])) / sum(rate(http_requests_total{job=\"kerp-api\"}[5m])) * 100",
            "legendFormat": "Error %"
          }
        ],
        "options": {
          "colorMode": "value"
        },
        "thresholds": {
          "steps": [
            { "value": 0, "color": "green" },
            { "value": 1, "color": "yellow" },
            { "value": 5, "color": "red" }
          ]
        }
      },
      {
        "title": "P95 Latency",
        "type": "stat",
        "gridPos": { "x": 8, "y": 0, "w": 4, "h": 4 },
        "targets": [
          {
            "expr": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{job=\"kerp-api\"}[5m])) by (le)) * 1000",
            "legendFormat": "P95 (ms)"
          }
        ],
        "options": {
          "colorMode": "value"
        },
        "thresholds": {
          "steps": [
            { "value": 0, "color": "green" },
            { "value": 200, "color": "yellow" },
            { "value": 500, "color": "red" }
          ]
        }
      },
      {
        "title": "Active Users",
        "type": "stat",
        "gridPos": { "x": 12, "y": 0, "w": 4, "h": 4 },
        "targets": [
          {
            "expr": "kerp_active_sessions_total",
            "legendFormat": "Users"
          }
        ]
      },
      {
        "title": "Request Latency Distribution",
        "type": "timeseries",
        "gridPos": { "x": 0, "y": 4, "w": 12, "h": 8 },
        "targets": [
          {
            "expr": "histogram_quantile(0.50, sum(rate(http_request_duration_seconds_bucket{job=\"kerp-api\"}[5m])) by (le))",
            "legendFormat": "P50"
          },
          {
            "expr": "histogram_quantile(0.90, sum(rate(http_request_duration_seconds_bucket{job=\"kerp-api\"}[5m])) by (le))",
            "legendFormat": "P90"
          },
          {
            "expr": "histogram_quantile(0.99, sum(rate(http_request_duration_seconds_bucket{job=\"kerp-api\"}[5m])) by (le))",
            "legendFormat": "P99"
          }
        ]
      },
      {
        "title": "Python Services Status",
        "type": "table",
        "gridPos": { "x": 12, "y": 4, "w": 12, "h": 8 },
        "targets": [
          {
            "expr": "up{job=~\"kerp-tax-scraper|kerp-insurance-edi\"}",
            "format": "table",
            "instant": true
          }
        ],
        "transformations": [
          {
            "id": "organize",
            "options": {
              "includeByName": {
                "job": true,
                "instance": true,
                "Value": true
              },
              "renameByName": {
                "Value": "Status"
              }
            }
          }
        ]
      }
    ]
  }
}
```

---

## 6. 스케일링 전략

### 6.1 Horizontal Pod Autoscaler

```yaml
# deployments/kubernetes/hpa.yaml

apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: kerp-api-hpa
  namespace: kerp
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: kerp-api
  minReplicas: 3
  maxReplicas: 20
  metrics:
    # CPU utilization
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    # Memory utilization
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
    # Custom metric: requests per second
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: "1000"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 10
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
        - type: Percent
          value: 100
          periodSeconds: 15
        - type: Pods
          value: 4
          periodSeconds: 15
      selectPolicy: Max
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: kerp-worker-hpa
  namespace: kerp
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: kerp-worker
  minReplicas: 2
  maxReplicas: 10
  metrics:
    # Queue depth metric
    - type: External
      external:
        metric:
          name: nats_consumer_pending_messages
          selector:
            matchLabels:
              stream: INVOICES
        target:
          type: AverageValue
          averageValue: "100"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 600
    scaleUp:
      stabilizationWindowSeconds: 30
```

### 6.2 Vertical Pod Autoscaler

```yaml
# deployments/kubernetes/vpa.yaml

apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: kerp-api-vpa
  namespace: kerp
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: kerp-api
  updatePolicy:
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies:
      - containerName: api
        minAllowed:
          cpu: "250m"
          memory: "256Mi"
        maxAllowed:
          cpu: "4"
          memory: "8Gi"
        controlledResources: ["cpu", "memory"]
        controlledValues: RequestsAndLimits
```

### 6.3 Cluster Autoscaler

```yaml
# deployments/kubernetes/cluster-autoscaler.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-autoscaler-priority-expander
  namespace: kube-system
data:
  priorities: |
    50:
      - .*python.*
    40:
      - .*main.*
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cluster-autoscaler
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cluster-autoscaler
  template:
    spec:
      serviceAccountName: cluster-autoscaler
      containers:
        - name: cluster-autoscaler
          image: registry.k8s.io/autoscaling/cluster-autoscaler:v1.28.0
          command:
            - ./cluster-autoscaler
            - --v=4
            - --cloud-provider=aws
            - --skip-nodes-with-local-storage=false
            - --expander=priority
            - --node-group-auto-discovery=asg:tag=k8s.io/cluster-autoscaler/enabled,k8s.io/cluster-autoscaler/kerp-prod
            - --balance-similar-node-groups
            - --scale-down-enabled=true
            - --scale-down-delay-after-add=10m
            - --scale-down-unneeded-time=10m
            - --scale-down-utilization-threshold=0.5
```

---

## 7. 장애 대응

### 7.1 장애 대응 매뉴얼

```markdown
# K-ERP 장애 대응 가이드

## 1. 장애 등급 정의

| 등급 | 정의 | 대응 시간 | 예시 |
|------|------|-----------|------|
| P1 (Critical) | 전체 서비스 중단 | 15분 이내 | DB 다운, 전체 API 장애 |
| P2 (High) | 핵심 기능 장애 | 30분 이내 | 결제 실패, 세금계산서 발행 불가 |
| P3 (Medium) | 부분 기능 저하 | 2시간 이내 | 특정 API 느림, 알림 지연 |
| P4 (Low) | 경미한 이슈 | 24시간 이내 | UI 버그, 비핵심 기능 오류 |

## 2. 장애 대응 프로세스

### 2.1 탐지 (Detection)
- Prometheus 알림 수신
- 사용자 리포트
- 모니터링 대시보드 확인

### 2.2 분류 (Triage)
- 장애 등급 결정
- 영향 범위 파악
- 담당자 할당

### 2.3 대응 (Response)
- 즉각 조치 실행
- 원인 분석
- 해결책 적용

### 2.4 복구 (Recovery)
- 서비스 정상화 확인
- 모니터링 강화
- 후속 조치 계획

### 2.5 사후 분석 (Post-mortem)
- 근본 원인 분석
- 재발 방지 대책
- 문서화
```

### 7.2 장애 대응 스크립트

```bash
#!/bin/bash
# scripts/incident-response.sh

set -euo pipefail

ACTION=$1
COMPONENT=${2:-all}

# Get current status
get_status() {
    echo "=== Cluster Status ==="
    kubectl get nodes
    echo ""
    echo "=== Pod Status (kerp namespace) ==="
    kubectl get pods -n kerp -o wide
    echo ""
    echo "=== Recent Events ==="
    kubectl get events -n kerp --sort-by='.lastTimestamp' | tail -20
}

# Restart component
restart_component() {
    local component=$1
    echo "Restarting ${component}..."
    kubectl rollout restart deployment/${component} -n kerp
    kubectl rollout status deployment/${component} -n kerp --timeout=300s
    echo "${component} restarted successfully"
}

# Scale component
scale_component() {
    local component=$1
    local replicas=$2
    echo "Scaling ${component} to ${replicas} replicas..."
    kubectl scale deployment/${component} --replicas=${replicas} -n kerp
    kubectl rollout status deployment/${component} -n kerp --timeout=300s
}

# Get logs
get_logs() {
    local component=$1
    local since=${2:-1h}
    echo "=== Logs for ${component} (last ${since}) ==="
    kubectl logs -n kerp -l app=${component} --since=${since} --tail=500
}

# Database emergency actions
db_emergency() {
    local action=$1
    case $action in
        "connections")
            echo "Checking database connections..."
            kubectl exec -n kerp deploy/kerp-api -- curl -s localhost:8080/debug/db/stats
            ;;
        "kill-idle")
            echo "Killing idle connections..."
            kubectl exec -n kerp deploy/kerp-api -- curl -X POST localhost:8080/debug/db/kill-idle
            ;;
        "failover")
            echo "Initiating RDS failover..."
            aws rds failover-db-cluster --db-cluster-identifier kerp-prod
            ;;
    esac
}

# Cache emergency actions
cache_emergency() {
    local action=$1
    case $action in
        "flush")
            echo "Flushing cache..."
            kubectl exec -n kerp deploy/kerp-api -- curl -X POST localhost:8080/debug/cache/flush
            ;;
        "stats")
            echo "Cache statistics..."
            kubectl exec -n kerp deploy/kerp-api -- curl -s localhost:8080/debug/cache/stats
            ;;
    esac
}

# Circuit breaker actions
circuit_breaker() {
    local service=$1
    local action=$2
    echo "Circuit breaker ${action} for ${service}..."
    kubectl exec -n kerp deploy/kerp-api -- curl -X POST "localhost:8080/debug/circuit-breaker/${service}/${action}"
}

# Main
case $ACTION in
    "status")
        get_status
        ;;
    "restart")
        if [ "$COMPONENT" = "all" ]; then
            for c in kerp-api kerp-worker kerp-tax-scraper kerp-insurance-edi; do
                restart_component $c
            done
        else
            restart_component $COMPONENT
        fi
        ;;
    "logs")
        get_logs $COMPONENT ${3:-1h}
        ;;
    "scale")
        scale_component $COMPONENT $3
        ;;
    "db")
        db_emergency $COMPONENT
        ;;
    "cache")
        cache_emergency $COMPONENT
        ;;
    "circuit")
        circuit_breaker $COMPONENT $3
        ;;
    *)
        echo "Usage: $0 {status|restart|logs|scale|db|cache|circuit} [component] [args]"
        exit 1
        ;;
esac
```

### 7.3 PagerDuty 연동

```yaml
# deployments/monitoring/alertmanager-config.yaml

apiVersion: v1
kind: Secret
metadata:
  name: alertmanager-config
  namespace: kerp-monitoring
stringData:
  alertmanager.yml: |
    global:
      resolve_timeout: 5m
      pagerduty_url: 'https://events.pagerduty.com/v2/enqueue'
      slack_api_url: 'https://hooks.slack.com/services/xxx/yyy/zzz'

    route:
      group_by: ['alertname', 'severity']
      group_wait: 30s
      group_interval: 5m
      repeat_interval: 4h
      receiver: 'default'
      routes:
        - match:
            severity: critical
          receiver: 'pagerduty-critical'
          continue: true
        - match:
            severity: warning
          receiver: 'slack-warnings'

    receivers:
      - name: 'default'
        slack_configs:
          - channel: '#kerp-alerts'
            send_resolved: true

      - name: 'pagerduty-critical'
        pagerduty_configs:
          - service_key: '<pagerduty-service-key>'
            severity: critical
            description: '{{ .CommonAnnotations.summary }}'
            details:
              firing: '{{ template "pagerduty.default.instances" .Alerts.Firing }}'
              resolved: '{{ template "pagerduty.default.instances" .Alerts.Resolved }}'

      - name: 'slack-warnings'
        slack_configs:
          - channel: '#kerp-alerts'
            send_resolved: true
            title: '{{ .Status | toUpper }} - {{ .CommonAnnotations.summary }}'
            text: '{{ .CommonAnnotations.description }}'

    inhibit_rules:
      - source_match:
          severity: 'critical'
        target_match:
          severity: 'warning'
        equal: ['alertname', 'service']
```

---

## 8. 보안 운영

### 8.1 Secret 관리 (AWS Secrets Manager)

```yaml
# deployments/kubernetes/external-secrets.yaml

apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: kerp
spec:
  provider:
    aws:
      service: SecretsManager
      region: ap-northeast-2
      auth:
        jwt:
          serviceAccountRef:
            name: kerp-api
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: kerp-secrets
  namespace: kerp
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: kerp-secrets
    creationPolicy: Owner
  data:
    - secretKey: DATABASE_URL
      remoteRef:
        key: kerp/prod/database
        property: url
    - secretKey: REDIS_URL
      remoteRef:
        key: kerp/prod/redis
        property: url
    - secretKey: JWT_SECRET
      remoteRef:
        key: kerp/prod/auth
        property: jwt_secret
    - secretKey: POPBILL_API_KEY
      remoteRef:
        key: kerp/prod/popbill
        property: api_key
    - secretKey: ENCRYPTION_KEY
      remoteRef:
        key: kerp/prod/encryption
        property: key
```

### 8.2 Pod Security Standards

```yaml
# deployments/kubernetes/pod-security.yaml

apiVersion: v1
kind: Namespace
metadata:
  name: kerp
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: kerp-api-pdb
  namespace: kerp
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: kerp-api
---
apiVersion: v1
kind: Pod
metadata:
  name: kerp-api-security-example
  namespace: kerp
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault
  containers:
    - name: api
      image: kerp-api:latest
      securityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop:
            - ALL
      volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: cache
          mountPath: /app/.cache
  volumes:
    - name: tmp
      emptyDir: {}
    - name: cache
      emptyDir: {}
```

---

## 9. 백업 및 복구

### 9.1 데이터베이스 백업 전략

```yaml
# deployments/kubernetes/backup-cronjob.yaml

apiVersion: batch/v1
kind: CronJob
metadata:
  name: db-backup
  namespace: kerp
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      backoffLimit: 3
      template:
        spec:
          restartPolicy: OnFailure
          containers:
            - name: backup
              image: postgres:16
              command:
                - /bin/bash
                - -c
                - |
                  set -e
                  TIMESTAMP=$(date +%Y%m%d_%H%M%S)
                  BACKUP_FILE="kerp_backup_${TIMESTAMP}.sql.gz"

                  # Create backup
                  pg_dump $DATABASE_URL | gzip > /tmp/${BACKUP_FILE}

                  # Upload to S3
                  aws s3 cp /tmp/${BACKUP_FILE} s3://${BACKUP_BUCKET}/database/${BACKUP_FILE}

                  # Verify backup
                  aws s3 ls s3://${BACKUP_BUCKET}/database/${BACKUP_FILE}

                  # Cleanup old backups (keep last 30)
                  aws s3 ls s3://${BACKUP_BUCKET}/database/ | sort -r | tail -n +31 | awk '{print $4}' | \
                    xargs -I {} aws s3 rm s3://${BACKUP_BUCKET}/database/{}

                  echo "Backup completed: ${BACKUP_FILE}"
              envFrom:
                - secretRef:
                    name: kerp-secrets
              env:
                - name: BACKUP_BUCKET
                  value: "kerp-backups-prod"
                - name: AWS_REGION
                  value: "ap-northeast-2"
```

### 9.2 복구 프로세스

```bash
#!/bin/bash
# scripts/restore-database.sh

set -euo pipefail

BACKUP_FILE=$1
ENVIRONMENT=${2:-staging}

echo "=== Database Restore Process ==="
echo "Backup file: ${BACKUP_FILE}"
echo "Target environment: ${ENVIRONMENT}"
echo ""

# Confirm
read -p "Are you sure you want to restore? This will overwrite existing data. (yes/no): " CONFIRM
if [ "$CONFIRM" != "yes" ]; then
    echo "Restore cancelled"
    exit 0
fi

# Download backup
echo "Downloading backup from S3..."
aws s3 cp s3://kerp-backups-${ENVIRONMENT}/database/${BACKUP_FILE} /tmp/${BACKUP_FILE}

# Stop API to prevent new writes
echo "Scaling down API..."
kubectl scale deployment kerp-api --replicas=0 -n kerp
kubectl scale deployment kerp-worker --replicas=0 -n kerp

# Wait for pods to terminate
kubectl wait --for=delete pod -l app=kerp-api -n kerp --timeout=120s || true

# Restore database
echo "Restoring database..."
gunzip -c /tmp/${BACKUP_FILE} | psql $DATABASE_URL

# Run migrations to ensure schema is up to date
echo "Running migrations..."
kubectl create job --from=cronjob/db-migration db-migration-post-restore -n kerp
kubectl wait --for=condition=complete job/db-migration-post-restore -n kerp --timeout=300s

# Scale up API
echo "Scaling up API..."
kubectl scale deployment kerp-api --replicas=3 -n kerp
kubectl scale deployment kerp-worker --replicas=2 -n kerp

# Verify
echo "Verifying restore..."
kubectl rollout status deployment/kerp-api -n kerp --timeout=300s

echo "=== Restore completed successfully ==="
```

---

## 10. 운영 체크리스트

### 10.1 일일 점검

```markdown
## 일일 운영 체크리스트

### 서비스 상태 (09:00)
- [ ] 모든 Pod 정상 Running 상태
- [ ] API 응답시간 < 200ms (P95)
- [ ] 에러율 < 0.1%
- [ ] 디스크 사용량 < 80%

### 보안 점검
- [ ] 비정상 로그인 시도 확인
- [ ] 보안 알림 검토
- [ ] 인증서 만료일 확인

### 백업 확인
- [ ] 자동 백업 성공 여부
- [ ] 백업 파일 크기 정상
- [ ] S3 백업 스토리지 상태

### 외부 연동
- [ ] Popbill API 연결 상태
- [ ] 국세청 API 상태
- [ ] 4대보험 EDI 연결

### 알림 사항
- [ ] 어제 발생한 알림 검토
- [ ] 해결되지 않은 이슈 확인
```

### 10.2 주간 점검

```markdown
## 주간 운영 체크리스트 (매주 월요일)

### 성능 분석
- [ ] 주간 트래픽 패턴 분석
- [ ] 슬로우 쿼리 리뷰
- [ ] 캐시 히트율 확인
- [ ] 리소스 사용량 트렌드

### 용량 계획
- [ ] 디스크 증가 추이
- [ ] 데이터베이스 크기
- [ ] 로그 저장소 용량
- [ ] 스케일링 필요성 검토

### 보안 리뷰
- [ ] 취약점 스캔 결과
- [ ] 의존성 업데이트 확인
- [ ] 접근 로그 분석

### 비용 분석
- [ ] AWS 비용 현황
- [ ] 리소스 최적화 기회
- [ ] 예산 대비 지출
```

### 10.3 월간 점검

```markdown
## 월간 운영 체크리스트 (매월 첫째 주)

### 인프라 리뷰
- [ ] Kubernetes 버전 업데이트 검토
- [ ] 노드 그룹 상태 점검
- [ ] 네트워크 정책 리뷰
- [ ] SSL 인증서 갱신 확인

### 재해 복구 테스트
- [ ] 백업 복구 테스트
- [ ] 장애 시나리오 훈련
- [ ] DR 문서 업데이트

### 규정 준수
- [ ] 감사 로그 검토
- [ ] 접근 권한 리뷰
- [ ] 데이터 보존 정책 확인
- [ ] ISMS 요구사항 점검

### 문서화
- [ ] 운영 매뉴얼 업데이트
- [ ] 아키텍처 다이어그램 검토
- [ ] 장애 대응 절차 리뷰
```

---

## 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 1.0 | 2025-01-xx | K-ERP Team | 최초 작성 |
