# 전자세금계산서 스크래핑 기반 연동 설계서

## 1. 개요

### 1.1 문서 목적
본 문서는 기존 Popbill ASP 연동(`02_세금계산서_연동_설계.md`)을 확장하여, 무료 홈택스 스크래핑 방식을 기본으로 하고 향후 국세청 공식 API 전환이 가능한 Provider 추상화 아키텍처를 정의합니다.

### 1.2 배경
- **비용 절감**: Popbill 건당 100원 비용 제거
- **유연성**: 국세청 API 공개 시 즉시 전환 가능
- **자사 데이터**: 공인인증서로 본인 인증 후 조회 (합법적 접근)

### 1.3 범위

| 구분 | 포함 | 제외 |
|------|------|------|
| **세금계산서** | 매출/매입 조회, 발행, 취소 | 현금영수증, 수정세금계산서 |
| **인증** | 공인인증서(파일 기반) | 공동인증서(클라우드), 간편인증 |
| **시스템** | TEET(전자세금계산서) | e세로 일반 |

---

## 2. Provider 추상화 아키텍처

### 2.1 마이크로서비스 아키텍처 (Go + Python)

홈택스 스크래핑은 **Python 마이크로서비스**로 분리하여 구현합니다.

**이유:**
- Go 표준 라이브러리에 SEED 암호화 없음 (한국 공인인증서용)
- Python에 검증된 홈택스 라이브러리 존재 (`pycryptodome`, `hometax` 등)
- 개발 기간 단축 (3주+ -> 1주)

```
+-----------------------------------------------------------------------+
|                         K-ERP 세금계산서 아키텍처                        |
+-----------------------------------------------------------------------+
|                                                                        |
|  ┌─────────────────────────────────────────────────────────────────┐  |
|  │                      Go API Server (메인)                        │  |
|  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │  |
|  │  │ TaxInvoice  │  │  Provider   │  │   Health    │              │  |
|  │  │  Service    │  │  Selector   │  │   Cache     │              │  |
|  │  └──────┬──────┘  └──────┬──────┘  └─────────────┘              │  |
|  │         │                │                                       │  |
|  │         │    ┌───────────┴───────────┐                          │  |
|  │         │    │  TaxInvoiceProvider   │                          │  |
|  │         │    │     (Interface)       │                          │  |
|  │         │    └───────────┬───────────┘                          │  |
|  │         │                │                                       │  |
|  └─────────│────────────────│───────────────────────────────────────┘  |
|            │                │                                          |
|            │    ┌───────────┴───────────────────────┐                  |
|            │    │              │                    │                  |
|            │    v              v                    v                  |
|       ┌────┴────────┐  ┌─────────────┐      ┌─────────────┐           |
|       │   Scraper   │  │   NTS API   │      │   Popbill   │           |
|       │   Client    │  │   Client    │      │   Client    │           |
|       │   (gRPC)    │  │   (HTTP)    │      │   (HTTP)    │           |
|       └──────┬──────┘  └─────────────┘      └─────────────┘           |
|              │              (Go)                 (Go)                  |
|              │ gRPC                                                    |
|              v                                                         |
|  ┌───────────────────────────────────────┐                            |
|  │       Python Scraper Service          │  <-- 별도 컨테이너         |
|  │  ┌─────────────┐  ┌─────────────┐     │                            |
|  │  │  HometaxAPI │  │   SEED      │     │                            |
|  │  │  (스크래핑)  │  │  암호화     │     │                            |
|  │  └─────────────┘  └─────────────┘     │                            |
|  └───────────────────────────────────────┘                            |
|                                                                        |
+-----------------------------------------------------------------------+
```

### 2.2 서비스 간 통신

| 통신 | 프로토콜 | 용도 |
|------|----------|------|
| Go -> Python Scraper | **gRPC** | 세금계산서 조회/발행 (동기) |
| Go -> Python Scraper | **NATS** | 대량 동기화 (비동기) |
| Go -> Popbill | HTTP REST | Fallback API 호출 |
| Go -> NTS API | HTTP REST | 국세청 공식 API |

### 2.2 Provider 선택 전략 (무료 최대화)

```
+-----------------------------------------------------------------------+
|                      무료 최대화 Provider 전략                          |
+-----------------------------------------------------------------------+
|                                                                        |
|  우선순위 1: 홈택스 스크래핑 (Scraper)                                  |
|  +------------------------------------------------------------------+  |
|  | 비용: 무료                                                        |  |
|  | 조건: 공인인증서 유효 + 홈택스 정상 접속                           |  |
|  | 장점: 완전 무료, 실시간 처리                                      |  |
|  | 단점: 홈택스 UI 변경 시 파싱 오류 가능                            |  |
|  +------------------------------------------------------------------+  |
|                               |                                        |
|                          실패 시 Fallback                              |
|                               v                                        |
|  우선순위 2: 홈택스 Open API (NTS API)                                 |
|  +------------------------------------------------------------------+  |
|  | 비용: 무료                                                        |  |
|  | 조건: API 키 발급 + 사업자 인증                                   |  |
|  | 장점: 공식 API, 안정적, 무료                                      |  |
|  | 단점: API 호출 제한 (일 1,000건 예상)                             |  |
|  | 상태: 2024년 일부 공개, 확대 예정                                 |  |
|  +------------------------------------------------------------------+  |
|                               |                                        |
|                          실패 시 Fallback                              |
|                               v                                        |
|  우선순위 3: Popbill ASP (최후의 보루)                                 |
|  +------------------------------------------------------------------+  |
|  | 비용: 100원/건                                                    |  |
|  | 조건: 연동회원 가입 + 포인트 충전                                 |  |
|  | 장점: 가장 안정적, 다양한 SDK                                     |  |
|  | 용도: 긴급 Fallback 전용                                          |  |
|  +------------------------------------------------------------------+  |
|                                                                        |
|  목표: Popbill 사용률 5% 미만 유지                                     |
|                                                                        |
+-----------------------------------------------------------------------+
```

| 우선순위 | Provider | 조건 | 비용 | 목표 사용률 |
|----------|----------|------|------|------------|
| 1 | Scraper | 인증서 유효 & 홈택스 정상 | 무료 | 90%+ |
| 2 | NTS API | API 키 발급 & 할당량 내 | 무료 | 5% |
| 3 | Popbill | 무료 Provider 모두 실패 시 | 100원/건 | 5% 미만 |

### 2.3 비용 절감 시뮬레이션

| 월 발행량 | 100% Popbill | 무료 최대화 (95:5) | 절감액 | 연간 절감 |
|----------|-------------|-------------------|--------|----------|
| 1,000건 | 100,000원 | 5,000원 | 95,000원 | 1,140,000원 |
| 5,000건 | 500,000원 | 25,000원 | 475,000원 | 5,700,000원 |
| 10,000건 | 1,000,000원 | 50,000원 | 950,000원 | 11,400,000원 |
| 50,000건 | 5,000,000원 | 250,000원 | 4,750,000원 | 57,000,000원 |

### 2.4 디렉토리 구조 (Go + Python)

#### Go API Server 구조

```
k-erp/
+-- cmd/
|   +-- api/
|       +-- main.go              # API 서버 진입점
+-- internal/
|   +-- domain/
|   |   +-- tax/
|   |       +-- invoice.go       # 세금계산서 도메인
|   |       +-- invoice_item.go  # 품목 도메인
|   |       +-- enums.go         # 상태 ENUM
|   +-- service/
|   |   +-- tax/
|   |       +-- service.go       # 비즈니스 로직
|   +-- infrastructure/
|   |   +-- tax/
|   |       +-- provider.go      # Provider 인터페이스 정의
|   |       +-- factory.go       # Provider 팩토리
|   |       +-- selector.go      # Provider 선택기 (무료 우선)
|   |       +-- chain.go         # Fallback 체인
|   |       +-- health.go        # Health Check 캐시
|   |       +-- metrics.go       # 사용량 메트릭
|   |       +-- alert.go         # 알림 서비스
|   |       +-- scraper/         # Scraper gRPC 클라이언트 (Go)
|   |       |   +-- client.go    # Python 서비스 gRPC 호출
|   |       |   +-- converter.go # Proto <-> Domain 변환
|   |       +-- ntsapi/          # 국세청 API (2순위)
|   |       |   +-- client.go
|   |       +-- popbill/         # Popbill (3순위)
|   |           +-- client.go
|   +-- repository/
|       +-- tax/
|           +-- invoice_repository.go
|           +-- cert_repository.go
|           +-- metrics_repository.go
+-- api/
|   +-- proto/
|       +-- scraper/
|           +-- scraper.proto    # gRPC 인터페이스 정의
+-- pkg/
    +-- scraper/
        +-- scraper.pb.go        # 생성된 Go gRPC 코드
        +-- scraper_grpc.pb.go
```

#### Python Scraper Service 구조

```
services/scraper/                 # Python 마이크로서비스
+-- pyproject.toml               # Poetry 의존성
+-- Dockerfile
+-- src/
|   +-- scraper/
|       +-- __init__.py
|       +-- main.py              # gRPC 서버 진입점
|       +-- server.py            # gRPC Servicer 구현
|       +-- hometax/
|       |   +-- __init__.py
|       |   +-- client.py        # 홈택스 HTTP 클라이언트
|       |   +-- auth.py          # 공인인증서 로그인
|       |   +-- invoice.py       # 세금계산서 조회/발행
|       |   +-- parser.py        # XML/HTML 파싱
|       |   +-- session.py       # 세션 관리
|       +-- crypto/
|       |   +-- __init__.py
|       |   +-- seed.py          # SEED-CBC 암호화/복호화
|       |   +-- sign.py          # 전자서명 (RSA/SHA256)
|       +-- proto/
|           +-- scraper_pb2.py       # 생성된 Python gRPC 코드
|           +-- scraper_pb2_grpc.py
+-- tests/
    +-- test_hometax.py
    +-- test_crypto.py
```

---

## 3. 핵심 인터페이스 정의

### 3.1 TaxInvoiceProvider Interface

```go
// internal/infrastructure/tax/provider.go
package tax

import (
    "context"
    "time"

    "k-erp/internal/domain/tax"
)

// ProviderType Provider 유형
type ProviderType string

const (
    ProviderScraper  ProviderType = "SCRAPER"   // 홈택스 스크래핑
    ProviderPopbill  ProviderType = "POPBILL"   // ASP 유료
    ProviderNTSAPI   ProviderType = "NTS_API"   // 국세청 공식 (미래)
)

// TaxInvoiceProvider 세금계산서 Provider 인터페이스
type TaxInvoiceProvider interface {
    // Issue 세금계산서 발행
    Issue(ctx context.Context, invoice *tax.Invoice) (*IssueResult, error)

    // Cancel 세금계산서 취소
    Cancel(ctx context.Context, mgtKey string, reason string) error

    // GetInfo 상세 조회
    GetInfo(ctx context.Context, mgtKey string) (*tax.Invoice, error)

    // Search 목록 조회 (매출/매입)
    Search(ctx context.Context, params SearchParams) (*SearchResult, error)

    // GetNTSStatus 국세청 전송 상태
    GetNTSStatus(ctx context.Context, mgtKey string) (*NTSStatus, error)

    // Sync 홈택스 데이터 동기화
    Sync(ctx context.Context, dateFrom, dateTo time.Time) (*SyncResult, error)

    // ProviderType Provider 정보
    ProviderType() ProviderType

    // HealthCheck Provider 상태 확인
    HealthCheck(ctx context.Context) error
}
```

### 3.2 검색 파라미터 및 결과

```go
// SearchParams 목록 조회 파라미터
type SearchParams struct {
    IssueType    string     // ISSUED(매출) | RECEIVED(매입)
    DateFrom     time.Time  // 조회 시작일
    DateTo       time.Time  // 조회 종료일
    Status       []string   // 상태 필터
    CorpNum      string     // 거래처 사업자번호
    Keyword      string     // 검색어
    Page         int        // 페이지 번호
    PerPage      int        // 페이지당 건수
}

// SearchResult 목록 조회 결과
type SearchResult struct {
    Invoices   []*tax.Invoice `json:"invoices"`
    TotalCount int64          `json:"total_count"`
    Page       int            `json:"page"`
    PerPage    int            `json:"per_page"`
}

// IssueResult 발행 결과
type IssueResult struct {
    MgtKey        string    `json:"mgt_key"`
    NTSConfirmNum string    `json:"nts_confirm_num"`
    IssuedAt      time.Time `json:"issued_at"`
}

// NTSStatus 국세청 전송 상태
type NTSStatus struct {
    StateCode    int       `json:"state_code"`
    StateName    string    `json:"state_name"`
    NTSResult    string    `json:"nts_result"`
    NTSSendDT    time.Time `json:"nts_send_dt"`
    NTSResultDT  time.Time `json:"nts_result_dt"`
}

// SyncResult 동기화 결과
type SyncResult struct {
    SyncedCount   int       `json:"synced_count"`
    NewCount      int       `json:"new_count"`
    UpdatedCount  int       `json:"updated_count"`
    ErrorCount    int       `json:"error_count"`
    SyncedAt      time.Time `json:"synced_at"`
}
```

### 3.3 Provider Factory

```go
// internal/infrastructure/tax/factory.go
package tax

import (
    "fmt"

    "k-erp/internal/config"
    "k-erp/internal/infrastructure/tax/popbill"
    "k-erp/internal/infrastructure/tax/scraper"
)

// ProviderFactory Provider 팩토리
type ProviderFactory struct {
    cfg *config.TaxConfig
}

// NewProviderFactory 팩토리 생성
func NewProviderFactory(cfg *config.TaxConfig) *ProviderFactory {
    return &ProviderFactory{cfg: cfg}
}

// Create Provider 생성
func (f *ProviderFactory) Create(providerType ProviderType) (TaxInvoiceProvider, error) {
    switch providerType {
    case ProviderScraper:
        return scraper.NewClient(f.cfg.Scraper)
    case ProviderPopbill:
        return popbill.NewClient(f.cfg.Popbill)
    case ProviderNTSAPI:
        return nil, fmt.Errorf("NTS API not yet implemented")
    default:
        return nil, fmt.Errorf("unknown provider type: %s", providerType)
    }
}

// CreateDefault 기본 Provider 생성 (설정 기반)
func (f *ProviderFactory) CreateDefault() (TaxInvoiceProvider, error) {
    return f.Create(f.cfg.DefaultProvider)
}
```

### 3.4 gRPC Proto 정의 (Go-Python 통신)

```protobuf
// api/proto/scraper/scraper.proto
syntax = "proto3";

package scraper;

option go_package = "k-erp/pkg/scraper";

// ScraperService - 홈택스 스크래핑 서비스 (Python 구현)
service ScraperService {
    // 세금계산서 발행
    rpc IssueInvoice(IssueRequest) returns (IssueResponse);

    // 세금계산서 취소
    rpc CancelInvoice(CancelRequest) returns (CancelResponse);

    // 세금계산서 상세 조회
    rpc GetInvoice(GetInvoiceRequest) returns (Invoice);

    // 세금계산서 목록 조회
    rpc SearchInvoices(SearchRequest) returns (SearchResponse);

    // 홈택스 데이터 동기화
    rpc SyncInvoices(SyncRequest) returns (SyncResponse);

    // 서비스 헬스체크
    rpc HealthCheck(HealthRequest) returns (HealthResponse);
}

// 인증 정보
message CertCredential {
    string cert_base64 = 1;       // 인증서 (signCert.der) Base64
    string key_base64 = 2;        // 개인키 (signPri.key) Base64
    string password = 3;          // 인증서 비밀번호
    string business_number = 4;   // 사업자등록번호
}

// 세금계산서 발행 요청
message IssueRequest {
    CertCredential credential = 1;
    Invoice invoice = 2;
}

message IssueResponse {
    bool success = 1;
    string mgt_key = 2;
    string nts_confirm_num = 3;
    string issued_at = 4;
    string error_message = 5;
}

// 세금계산서 취소 요청
message CancelRequest {
    CertCredential credential = 1;
    string mgt_key = 2;
    string reason = 3;
}

message CancelResponse {
    bool success = 1;
    string error_message = 2;
}

// 세금계산서 조회 요청
message GetInvoiceRequest {
    CertCredential credential = 1;
    string mgt_key = 2;
}

// 목록 조회 요청
message SearchRequest {
    CertCredential credential = 1;
    string issue_type = 2;        // ISSUED | RECEIVED
    string date_from = 3;         // YYYY-MM-DD
    string date_to = 4;           // YYYY-MM-DD
    repeated string status = 5;   // 상태 필터
    string corp_num = 6;          // 거래처 사업자번호
    string keyword = 7;           // 검색어
    int32 page = 8;
    int32 per_page = 9;
}

message SearchResponse {
    repeated Invoice invoices = 1;
    int64 total_count = 2;
    int32 page = 3;
    int32 per_page = 4;
}

// 동기화 요청
message SyncRequest {
    CertCredential credential = 1;
    string date_from = 2;
    string date_to = 3;
}

message SyncResponse {
    int32 synced_count = 1;
    int32 new_count = 2;
    int32 updated_count = 3;
    int32 error_count = 4;
    repeated Invoice invoices = 5;
}

// 헬스체크
message HealthRequest {}

message HealthResponse {
    bool healthy = 1;
    string hometax_status = 2;    // AVAILABLE | MAINTENANCE | UNAVAILABLE
    string message = 3;
}

// 세금계산서 메시지
message Invoice {
    string mgt_key = 1;
    string nts_confirm_num = 2;
    string issue_type = 3;        // ISSUED | RECEIVED
    string invoice_type = 4;      // TAX | ZERO_TAX | FREE
    string status = 5;

    // 공급자 정보
    string supplier_corp_num = 10;
    string supplier_corp_name = 11;
    string supplier_ceo_name = 12;

    // 공급받는자 정보
    string buyer_corp_num = 20;
    string buyer_corp_name = 21;
    string buyer_ceo_name = 22;

    // 금액 정보
    int64 supply_amount = 30;
    int64 tax_amount = 31;
    int64 total_amount = 32;

    // 일시 정보
    string issued_at = 40;
    string written_date = 41;

    // 품목
    repeated InvoiceItem items = 50;

    // 비고
    string remark1 = 60;
    string remark2 = 61;
    string remark3 = 62;
}

message InvoiceItem {
    int32 seq = 1;
    string item_name = 2;
    string spec = 3;
    string unit = 4;
    double quantity = 5;
    int64 unit_price = 6;
    int64 supply_amount = 7;
    int64 tax_amount = 8;
    string remark = 9;
}
```

### 3.5 Go Scraper Client (gRPC)

```go
// internal/infrastructure/tax/scraper/client.go
package scraper

import (
    "context"
    "fmt"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"

    "k-erp/internal/domain/tax"
    pb "k-erp/pkg/scraper"
)

// Client Python Scraper gRPC 클라이언트
type Client struct {
    conn   *grpc.ClientConn
    client pb.ScraperServiceClient
}

// NewClient gRPC 클라이언트 생성
func NewClient(addr string) (*Client, error) {
    conn, err := grpc.Dial(addr,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithBlock(),
        grpc.WithTimeout(5*time.Second),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to connect to scraper service: %w", err)
    }

    return &Client{
        conn:   conn,
        client: pb.NewScraperServiceClient(conn),
    }, nil
}

// Issue 세금계산서 발행
func (c *Client) Issue(ctx context.Context, cert *CertCredential, invoice *tax.Invoice) (*IssueResult, error) {
    req := &pb.IssueRequest{
        Credential: toProtoCred(cert),
        Invoice:    toProtoInvoice(invoice),
    }

    resp, err := c.client.IssueInvoice(ctx, req)
    if err != nil {
        return nil, fmt.Errorf("scraper issue failed: %w", err)
    }

    if !resp.Success {
        return nil, fmt.Errorf("scraper issue error: %s", resp.ErrorMessage)
    }

    return &IssueResult{
        MgtKey:        resp.MgtKey,
        NTSConfirmNum: resp.NtsConfirmNum,
        IssuedAt:      parseTime(resp.IssuedAt),
    }, nil
}

// Search 목록 조회
func (c *Client) Search(ctx context.Context, cert *CertCredential, params SearchParams) (*SearchResult, error) {
    req := &pb.SearchRequest{
        Credential: toProtoCred(cert),
        IssueType:  params.IssueType,
        DateFrom:   params.DateFrom.Format("2006-01-02"),
        DateTo:     params.DateTo.Format("2006-01-02"),
        Status:     params.Status,
        CorpNum:    params.CorpNum,
        Keyword:    params.Keyword,
        Page:       int32(params.Page),
        PerPage:    int32(params.PerPage),
    }

    resp, err := c.client.SearchInvoices(ctx, req)
    if err != nil {
        return nil, fmt.Errorf("scraper search failed: %w", err)
    }

    return &SearchResult{
        Invoices:   toDomainInvoices(resp.Invoices),
        TotalCount: resp.TotalCount,
        Page:       int(resp.Page),
        PerPage:    int(resp.PerPage),
    }, nil
}

// HealthCheck 헬스체크
func (c *Client) HealthCheck(ctx context.Context) error {
    resp, err := c.client.HealthCheck(ctx, &pb.HealthRequest{})
    if err != nil {
        return fmt.Errorf("scraper health check failed: %w", err)
    }

    if !resp.Healthy {
        return fmt.Errorf("scraper unhealthy: %s", resp.Message)
    }

    return nil
}

// ProviderType Provider 타입
func (c *Client) ProviderType() ProviderType {
    return ProviderScraper
}

// Close 연결 종료
func (c *Client) Close() error {
    return c.conn.Close()
}
```

---

## 4. 홈택스 스크래핑 구현 (Python Service)

> **Note**: 홈택스 스크래핑은 Python 마이크로서비스로 구현합니다.
> SEED-CBC 암호화 및 홈택스 인증 처리에 검증된 Python 라이브러리를 활용합니다.

### 4.1 인증 흐름 상세

```
+---------------------------------------------------------------+
|                    홈택스 인증 프로세스                          |
+---------------------------------------------------------------+
|                                                                |
|  Step 1: 세션 초기화                                           |
|  +----------------------------------------------------------+  |
|  | GET https://www.hometax.go.kr/wqAction.do                 |  |
|  |     ?actionId=ATXPPZXA001R01                              |  |
|  |                                                           |  |
|  | Response:                                                 |  |
|  |   - Set-Cookie: WMONID, TXPPsessionID                    |  |
|  |   - Body: pkcEncSsn (암호화용 세션값)                      |  |
|  +----------------------------------------------------------+  |
|                         |                                      |
|                         v                                      |
|  Step 2: 공인인증서 서명 생성                                   |
|  +----------------------------------------------------------+  |
|  | 입력:                                                      |  |
|  |   - signCert.der (인증서)                                  |  |
|  |   - signPri.key (개인키)                                   |  |
|  |   - 인증서 비밀번호                                        |  |
|  |                                                           |  |
|  | 서명 데이터:                                               |  |
|  |   plain = pkcEncSsn + "$" + serialNum + "$" + timestamp   |  |
|  |                                                           |  |
|  | 서명 알고리즘: SHA256withRSA                               |  |
|  |                                                           |  |
|  | 출력:                                                      |  |
|  |   logSgnt = base64(plain + "$" + signature)               |  |
|  +----------------------------------------------------------+  |
|                         |                                      |
|                         v                                      |
|  Step 3: 로그인                                                |
|  +----------------------------------------------------------+  |
|  | POST https://www.hometax.go.kr/pubcLogin.do               |  |
|  |                                                           |  |
|  | Headers:                                                   |  |
|  |   - Cookie: WMONID, TXPPsessionID                         |  |
|  |   - Content-Type: application/x-www-form-urlencoded       |  |
|  |                                                           |  |
|  | Body:                                                      |  |
|  |   - cert: base64(signCert.der)                            |  |
|  |   - logSgnt: (Step 2에서 생성)                             |  |
|  |   - pkcLgnClCd: 04                                        |  |
|  +----------------------------------------------------------+  |
|                         |                                      |
|                         v                                      |
|  Step 4: SSO 토큰 획득                                         |
|  +----------------------------------------------------------+  |
|  | GET https://www.hometax.go.kr/permission.do               |  |
|  |                                                           |  |
|  | Response:                                                 |  |
|  |   - TIN (사업자등록번호)                                   |  |
|  |   - SSO Token                                             |  |
|  +----------------------------------------------------------+  |
|                         |                                      |
|                         v                                      |
|  Step 5: TEET 시스템 접근                                      |
|  +----------------------------------------------------------+  |
|  | GET https://teet.hometax.go.kr/permission.do              |  |
|  |                                                           |  |
|  | 전자세금계산서 시스템 접근 권한 획득                        |  |
|  +----------------------------------------------------------+  |
|                                                                |
+---------------------------------------------------------------+
```

### 4.2 SEED-CBC 암호화 (Python)

```python
# services/scraper/src/scraper/crypto/seed.py
"""
SEED-CBC 암호화/복호화 모듈
한국 공인인증서 개인키 복호화에 사용
"""
from Crypto.Cipher import AES
from Crypto.Hash import SHA1, PBKDF2
from Crypto.Util.Padding import unpad
import base64
from typing import Tuple

# SEED 상수 (KISA SEED 알고리즘)
# Note: pycryptodome은 SEED를 직접 지원하지 않으므로
# kisa-seed 또는 pyseed 라이브러리 사용 권장

class SEEDCipher:
    """SEED-CBC 암호화 클래스"""

    def __init__(self, key: bytes, iv: bytes):
        self.key = key
        self.iv = iv

    @classmethod
    def from_password(cls, password: str, salt: bytes, iterations: int = 2048) -> "SEEDCipher":
        """비밀번호로부터 키 유도 (PBKDF1)"""
        # PKCS#5 PBKDF1 with SHA1
        derived = cls._pbkdf1_sha1(password.encode(), salt, iterations, 20)
        key = derived[:16]  # SEED는 128-bit 키
        iv = derived[16:32] if len(derived) >= 32 else b'\x00' * 16
        return cls(key, iv)

    @staticmethod
    def _pbkdf1_sha1(password: bytes, salt: bytes, iterations: int, dk_len: int) -> bytes:
        """PBKDF1 SHA1 키 유도 함수"""
        derived = password + salt
        for _ in range(iterations):
            derived = SHA1.new(derived).digest()
        return derived[:dk_len]

    def decrypt(self, ciphertext: bytes) -> bytes:
        """SEED-CBC 복호화"""
        # 실제 구현시 kisa-seed 라이브러리 사용
        # pip install kisa-seed
        from seed import SEED
        cipher = SEED(self.key)
        return cipher.decrypt_cbc(ciphertext, self.iv)


def decrypt_private_key(encrypted_key: bytes, password: str) -> bytes:
    """
    공인인증서 개인키 복호화

    Args:
        encrypted_key: signPri.key 파일 내용 (DER 인코딩)
        password: 인증서 비밀번호

    Returns:
        복호화된 PKCS#8 개인키
    """
    from asn1crypto import core, algos, keys

    # EncryptedPrivateKeyInfo 파싱
    encrypted_info = keys.EncryptedPrivateKeyInfo.load(encrypted_key)

    # 암호화 알고리즘 파라미터 추출
    algorithm = encrypted_info['encryption_algorithm']
    algorithm_oid = algorithm['algorithm'].native

    # PBES1 with SEED-CBC (1.2.410.200004.1.15)
    if algorithm_oid == '1.2.410.200004.1.15':
        params = algorithm['parameters']
        salt = params['salt'].native
        iterations = params['iteration_count'].native

        # SEED 키 유도 및 복호화
        cipher = SEEDCipher.from_password(password, salt, iterations)
        decrypted = cipher.decrypt(encrypted_info['encrypted_data'].native)

        # PKCS#7 패딩 제거
        return unpad(decrypted, 16)

    raise ValueError(f"Unsupported algorithm: {algorithm_oid}")
```

### 4.3 인증 구현 (Python)

```python
# services/scraper/src/scraper/hometax/auth.py
"""홈택스 공인인증서 로그인"""
import base64
import hashlib
import re
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Optional

import httpx
from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa

from ..crypto.seed import decrypt_private_key


@dataclass
class Session:
    """홈택스 인증 세션"""
    wmonid: str
    txpp_session_id: str
    pkc_enc_ssn: str
    tin: Optional[str] = None  # 사업자등록번호
    sso_token: Optional[str] = None
    teet_authorized: bool = False
    expires_at: Optional[datetime] = None

    def is_valid(self) -> bool:
        return (
            self.teet_authorized and
            self.expires_at is not None and
            datetime.now() < self.expires_at
        )


@dataclass
class CertCredential:
    """인증서 정보"""
    cert_bytes: bytes      # signCert.der 내용
    key_bytes: bytes       # signPri.key 내용
    password: str          # 인증서 비밀번호
    business_number: str   # 사업자등록번호


class HometaxAuthenticator:
    """홈택스 인증기"""

    BASE_URL = "https://www.hometax.go.kr"
    TEET_URL = "https://teet.hometax.go.kr"

    def __init__(self, credential: CertCredential):
        self.credential = credential
        self.session: Optional[Session] = None
        self.http_client = httpx.Client(
            timeout=30.0,
            follow_redirects=False,
            headers={
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
            }
        )

    async def login(self) -> Session:
        """홈택스 로그인 (5단계 프로세스)"""
        # Step 1: 세션 초기화
        await self._init_session()

        # Step 2-3: 인증서 로그인
        await self._cert_login()

        # Step 4: SSO 토큰 획득
        await self._get_sso_token()

        # Step 5: TEET 시스템 접근
        await self._authorize_teet()

        self.session.expires_at = datetime.now() + timedelta(minutes=25)
        return self.session

    async def _init_session(self):
        """Step 1: 세션 초기화"""
        resp = self.http_client.get(
            f"{self.BASE_URL}/wqAction.do",
            params={"actionId": "ATXPPZXA001R01"}
        )
        resp.raise_for_status()

        # 쿠키 추출
        cookies = resp.cookies
        self.session = Session(
            wmonid=cookies.get("WMONID", ""),
            txpp_session_id=cookies.get("TXPPsessionID", ""),
            pkc_enc_ssn=self._extract_pkc_enc_ssn(resp.text)
        )

    async def _cert_login(self):
        """Step 2-3: 인증서 서명 및 로그인"""
        # 인증서 로드
        cert = x509.load_der_x509_certificate(self.credential.cert_bytes)

        # 개인키 복호화 및 로드
        decrypted_key = decrypt_private_key(
            self.credential.key_bytes,
            self.credential.password
        )
        private_key = serialization.load_der_private_key(decrypted_key, password=None)

        # 서명 데이터 생성
        serial_num = str(cert.serial_number)
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        plain = f"{self.session.pkc_enc_ssn}${serial_num}${timestamp}"

        # SHA256withRSA 서명
        signature = private_key.sign(
            plain.encode(),
            padding.PKCS1v15(),
            hashes.SHA256()
        )

        log_sgnt = base64.b64encode(
            f"{plain}${base64.b64encode(signature).decode()}".encode()
        ).decode()

        # 로그인 요청
        cert_b64 = base64.b64encode(self.credential.cert_bytes).decode()

        resp = self.http_client.post(
            f"{self.BASE_URL}/pubcLogin.do",
            data={
                "cert": cert_b64,
                "logSgnt": log_sgnt,
                "pkcLgnClCd": "04"
            },
            cookies={
                "WMONID": self.session.wmonid,
                "TXPPsessionID": self.session.txpp_session_id
            }
        )

        if resp.status_code not in (200, 302):
            raise Exception(f"Login failed: {resp.status_code}")

    async def _get_sso_token(self):
        """Step 4: SSO 토큰 획득"""
        resp = self.http_client.get(
            f"{self.BASE_URL}/permission.do",
            cookies={
                "WMONID": self.session.wmonid,
                "TXPPsessionID": self.session.txpp_session_id
            }
        )
        resp.raise_for_status()

        self.session.tin = self._extract_tin(resp.text)
        self.session.sso_token = self._extract_sso_token(resp.text)

    async def _authorize_teet(self):
        """Step 5: TEET 시스템 접근"""
        resp = self.http_client.get(
            f"{self.TEET_URL}/permission.do",
            cookies={
                "WMONID": self.session.wmonid,
                "TXPPsessionID": self.session.txpp_session_id
            }
        )
        self.session.teet_authorized = resp.status_code == 200

    @staticmethod
    def _extract_pkc_enc_ssn(html: str) -> str:
        """pkcEncSsn 값 추출"""
        match = re.search(r'pkcEncSsn["\']?\s*[:=]\s*["\']([^"\']+)["\']', html)
        return match.group(1) if match else ""

    @staticmethod
    def _extract_tin(html: str) -> str:
        """사업자등록번호 추출"""
        match = re.search(r'tin["\']?\s*[:=]\s*["\'](\d{10})["\']', html)
        return match.group(1) if match else ""

    @staticmethod
    def _extract_sso_token(html: str) -> str:
        """SSO 토큰 추출"""
        match = re.search(r'ssoToken["\']?\s*[:=]\s*["\']([^"\']+)["\']', html)
        return match.group(1) if match else ""

    def close(self):
        """HTTP 클라이언트 종료"""
        self.http_client.close()
```

### 4.4 세금계산서 조회/발행 (Python)

```python
# services/scraper/src/scraper/hometax/invoice.py
"""홈택스 세금계산서 조회/발행"""
from dataclasses import dataclass, field
from datetime import datetime, date
from decimal import Decimal
from enum import Enum
from typing import List, Optional
from xml.etree import ElementTree as ET

import httpx

from .auth import HometaxAuthenticator, Session, CertCredential


class ActionID(str, Enum):
    """홈택스 액션 ID"""
    SEARCH_ISSUED = "ATEETBDA001R01"    # 매출 목록
    SEARCH_RECEIVED = "ATEETBDA002R01"  # 매입 목록
    GET_DETAIL = "ATEETBDA003R01"       # 상세 조회
    ISSUE = "ATEETBDA001I01"            # 발행
    CANCEL = "ATEETBDA001D01"           # 취소


@dataclass
class InvoiceItem:
    """세금계산서 품목"""
    seq: int
    item_name: str
    spec: str = ""
    unit: str = ""
    quantity: Decimal = Decimal("1")
    unit_price: int = 0
    supply_amount: int = 0
    tax_amount: int = 0
    remark: str = ""


@dataclass
class Invoice:
    """세금계산서"""
    mgt_key: str = ""
    nts_confirm_num: str = ""
    issue_type: str = "ISSUED"  # ISSUED | RECEIVED
    invoice_type: str = "TAX"   # TAX | ZERO_TAX | FREE
    status: str = ""

    # 공급자 정보
    supplier_corp_num: str = ""
    supplier_corp_name: str = ""
    supplier_ceo_name: str = ""

    # 공급받는자 정보
    buyer_corp_num: str = ""
    buyer_corp_name: str = ""
    buyer_ceo_name: str = ""

    # 금액 정보
    supply_amount: int = 0
    tax_amount: int = 0
    total_amount: int = 0

    # 일시 정보
    issued_at: Optional[datetime] = None
    written_date: Optional[date] = None

    # 품목
    items: List[InvoiceItem] = field(default_factory=list)

    # 비고
    remark1: str = ""
    remark2: str = ""
    remark3: str = ""


@dataclass
class SearchParams:
    """검색 파라미터"""
    issue_type: str = "ISSUED"  # ISSUED | RECEIVED
    date_from: date = None
    date_to: date = None
    status: List[str] = field(default_factory=list)
    corp_num: str = ""
    keyword: str = ""
    page: int = 1
    per_page: int = 20


@dataclass
class SearchResult:
    """검색 결과"""
    invoices: List[Invoice]
    total_count: int
    page: int
    per_page: int


@dataclass
class IssueResult:
    """발행 결과"""
    mgt_key: str
    nts_confirm_num: str
    issued_at: datetime


class HometaxInvoiceClient:
    """홈택스 세금계산서 클라이언트"""

    TEET_URL = "https://teet.hometax.go.kr"

    def __init__(self, credential: CertCredential):
        self.credential = credential
        self.authenticator = HometaxAuthenticator(credential)
        self.session: Optional[Session] = None
        self.http_client = httpx.Client(timeout=30.0)

    async def ensure_session(self):
        """세션 확인/갱신"""
        if self.session is None or not self.session.is_valid():
            self.session = await self.authenticator.login()

    async def search(self, params: SearchParams) -> SearchResult:
        """세금계산서 목록 조회"""
        await self.ensure_session()

        action_id = (
            ActionID.SEARCH_ISSUED
            if params.issue_type == "ISSUED"
            else ActionID.SEARCH_RECEIVED
        )

        xml_body = self._build_search_request(params)
        response = await self._do_teet_request(action_id, xml_body)

        return self._parse_search_result(response)

    async def get_info(self, mgt_key: str) -> Invoice:
        """세금계산서 상세 조회"""
        await self.ensure_session()

        xml_body = self._build_detail_request(mgt_key)
        response = await self._do_teet_request(ActionID.GET_DETAIL, xml_body)

        return self._parse_invoice_detail(response)

    async def issue(self, invoice: Invoice) -> IssueResult:
        """세금계산서 발행"""
        await self.ensure_session()

        xml_body = self._build_issue_request(invoice)
        response = await self._do_teet_request(ActionID.ISSUE, xml_body)

        return self._parse_issue_result(response)

    async def cancel(self, mgt_key: str, reason: str) -> bool:
        """세금계산서 취소"""
        await self.ensure_session()

        xml_body = self._build_cancel_request(mgt_key, reason)
        await self._do_teet_request(ActionID.CANCEL, xml_body)

        return True

    async def _do_teet_request(self, action_id: ActionID, xml_body: bytes) -> bytes:
        """TEET 시스템 요청"""
        url = f"{self.TEET_URL}/wqAction.do"

        response = self.http_client.post(
            url,
            params={"actionId": action_id.value},
            content=xml_body,
            headers={"Content-Type": "application/xml; charset=UTF-8"},
            cookies={
                "WMONID": self.session.wmonid,
                "TXPPsessionID": self.session.txpp_session_id,
            },
        )
        response.raise_for_status()

        # 에러 체크
        self._check_error(response.content)

        return response.content

    def _build_search_request(self, params: SearchParams) -> bytes:
        """검색 요청 XML 생성"""
        root = ET.Element("map")
        ET.SubElement(root, "schStartDt").text = params.date_from.strftime("%Y%m%d")
        ET.SubElement(root, "schEndDt").text = params.date_to.strftime("%Y%m%d")
        ET.SubElement(root, "pageNum").text = str(params.page)
        ET.SubElement(root, "pageCount").text = str(params.per_page)

        return ET.tostring(root, encoding="utf-8", xml_declaration=True)

    def _build_detail_request(self, mgt_key: str) -> bytes:
        """상세조회 요청 XML 생성"""
        root = ET.Element("map")
        ET.SubElement(root, "mgtKey").text = mgt_key

        return ET.tostring(root, encoding="utf-8", xml_declaration=True)

    def _build_issue_request(self, invoice: Invoice) -> bytes:
        """발행 요청 XML 생성"""
        root = ET.Element("TaxInvoice")

        # 공급자 정보
        supplier = ET.SubElement(root, "Supplier")
        ET.SubElement(supplier, "CorpNum").text = invoice.supplier_corp_num
        ET.SubElement(supplier, "CorpName").text = invoice.supplier_corp_name
        ET.SubElement(supplier, "CEOName").text = invoice.supplier_ceo_name

        # 공급받는자 정보
        buyer = ET.SubElement(root, "Buyer")
        ET.SubElement(buyer, "CorpNum").text = invoice.buyer_corp_num
        ET.SubElement(buyer, "CorpName").text = invoice.buyer_corp_name
        ET.SubElement(buyer, "CEOName").text = invoice.buyer_ceo_name

        # 금액 정보
        ET.SubElement(root, "SupplyAmount").text = str(invoice.supply_amount)
        ET.SubElement(root, "TaxAmount").text = str(invoice.tax_amount)
        ET.SubElement(root, "TotalAmount").text = str(invoice.total_amount)

        # 품목
        items_elem = ET.SubElement(root, "Items")
        for item in invoice.items:
            item_elem = ET.SubElement(items_elem, "Item")
            ET.SubElement(item_elem, "Seq").text = str(item.seq)
            ET.SubElement(item_elem, "ItemName").text = item.item_name
            ET.SubElement(item_elem, "SupplyAmount").text = str(item.supply_amount)
            ET.SubElement(item_elem, "TaxAmount").text = str(item.tax_amount)

        return ET.tostring(root, encoding="utf-8", xml_declaration=True)

    def _build_cancel_request(self, mgt_key: str, reason: str) -> bytes:
        """취소 요청 XML 생성"""
        root = ET.Element("map")
        ET.SubElement(root, "mgtKey").text = mgt_key
        ET.SubElement(root, "cancelReason").text = reason

        return ET.tostring(root, encoding="utf-8", xml_declaration=True)

    def _parse_search_result(self, xml_data: bytes) -> SearchResult:
        """검색 결과 XML 파싱"""
        root = ET.fromstring(xml_data)
        invoices = []

        for item in root.findall(".//item"):
            invoice = Invoice(
                mgt_key=item.findtext("mgtKey", ""),
                nts_confirm_num=item.findtext("ntsConfirmNum", ""),
                supplier_corp_num=item.findtext("supplierCorpNum", ""),
                supplier_corp_name=item.findtext("supplierCorpName", ""),
                buyer_corp_num=item.findtext("buyerCorpNum", ""),
                buyer_corp_name=item.findtext("buyerCorpName", ""),
                supply_amount=int(item.findtext("supplyAmount", "0")),
                tax_amount=int(item.findtext("taxAmount", "0")),
                total_amount=int(item.findtext("totalAmount", "0")),
            )
            invoices.append(invoice)

        total_count = int(root.findtext(".//totalCount", "0"))

        return SearchResult(
            invoices=invoices,
            total_count=total_count,
            page=1,
            per_page=len(invoices),
        )

    def _parse_invoice_detail(self, xml_data: bytes) -> Invoice:
        """상세 정보 XML 파싱"""
        root = ET.fromstring(xml_data)

        return Invoice(
            mgt_key=root.findtext("mgtKey", ""),
            nts_confirm_num=root.findtext("ntsConfirmNum", ""),
            supplier_corp_num=root.findtext(".//Supplier/CorpNum", ""),
            supplier_corp_name=root.findtext(".//Supplier/CorpName", ""),
            buyer_corp_num=root.findtext(".//Buyer/CorpNum", ""),
            buyer_corp_name=root.findtext(".//Buyer/CorpName", ""),
            supply_amount=int(root.findtext("supplyAmount", "0")),
            tax_amount=int(root.findtext("taxAmount", "0")),
            total_amount=int(root.findtext("totalAmount", "0")),
        )

    def _parse_issue_result(self, xml_data: bytes) -> IssueResult:
        """발행 결과 XML 파싱"""
        root = ET.fromstring(xml_data)

        return IssueResult(
            mgt_key=root.findtext("mgtKey", ""),
            nts_confirm_num=root.findtext("ntsConfirmNum", ""),
            issued_at=datetime.now(),
        )

    def _check_error(self, xml_data: bytes):
        """에러 응답 확인"""
        try:
            root = ET.fromstring(xml_data)
            err_code = root.findtext("errCd")
            err_msg = root.findtext("errMsg")

            if err_code:
                raise HometaxError(err_code, err_msg)
        except ET.ParseError:
            pass


class HometaxError(Exception):
    """홈택스 에러"""

    def __init__(self, code: str, message: str):
        self.code = code
        self.message = message
        super().__init__(f"[{code}] {message}")
```

### 4.5 gRPC 서버 구현 (Python)

```python
# services/scraper/src/scraper/server.py
"""gRPC Scraper 서비스 구현"""
import base64
from concurrent import futures
from datetime import datetime

import grpc

from .proto import scraper_pb2, scraper_pb2_grpc
from .hometax.auth import CertCredential
from .hometax.invoice import (
    HometaxInvoiceClient, Invoice, InvoiceItem, SearchParams
)


class ScraperServicer(scraper_pb2_grpc.ScraperServiceServicer):
    """gRPC Scraper 서비스"""

    def _create_credential(self, proto_cred) -> CertCredential:
        """Proto 인증정보 -> CertCredential 변환"""
        return CertCredential(
            cert_bytes=base64.b64decode(proto_cred.cert_base64),
            key_bytes=base64.b64decode(proto_cred.key_base64),
            password=proto_cred.password,
            business_number=proto_cred.business_number,
        )

    async def IssueInvoice(self, request, context):
        """세금계산서 발행"""
        try:
            credential = self._create_credential(request.credential)
            client = HometaxInvoiceClient(credential)

            invoice = self._proto_to_invoice(request.invoice)
            result = await client.issue(invoice)

            return scraper_pb2.IssueResponse(
                success=True,
                mgt_key=result.mgt_key,
                nts_confirm_num=result.nts_confirm_num,
                issued_at=result.issued_at.isoformat(),
            )
        except Exception as e:
            return scraper_pb2.IssueResponse(
                success=False,
                error_message=str(e),
            )

    async def SearchInvoices(self, request, context):
        """세금계산서 목록 조회"""
        try:
            credential = self._create_credential(request.credential)
            client = HometaxInvoiceClient(credential)

            params = SearchParams(
                issue_type=request.issue_type,
                date_from=datetime.strptime(request.date_from, "%Y-%m-%d").date(),
                date_to=datetime.strptime(request.date_to, "%Y-%m-%d").date(),
                status=list(request.status),
                corp_num=request.corp_num,
                keyword=request.keyword,
                page=request.page or 1,
                per_page=request.per_page or 20,
            )
            result = await client.search(params)

            return scraper_pb2.SearchResponse(
                invoices=[self._invoice_to_proto(inv) for inv in result.invoices],
                total_count=result.total_count,
                page=result.page,
                per_page=result.per_page,
            )
        except Exception as e:
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return scraper_pb2.SearchResponse()

    async def HealthCheck(self, request, context):
        """헬스체크"""
        # 홈택스 접속 테스트
        try:
            import httpx
            resp = httpx.get("https://www.hometax.go.kr", timeout=5.0)
            healthy = resp.status_code == 200
            status = "AVAILABLE" if healthy else "UNAVAILABLE"
        except Exception:
            healthy = False
            status = "UNAVAILABLE"

        return scraper_pb2.HealthResponse(
            healthy=healthy,
            hometax_status=status,
            message="OK" if healthy else "Hometax unreachable",
        )

    def _proto_to_invoice(self, proto) -> Invoice:
        """Proto Invoice -> Domain Invoice 변환"""
        return Invoice(
            supplier_corp_num=proto.supplier_corp_num,
            supplier_corp_name=proto.supplier_corp_name,
            supplier_ceo_name=proto.supplier_ceo_name,
            buyer_corp_num=proto.buyer_corp_num,
            buyer_corp_name=proto.buyer_corp_name,
            buyer_ceo_name=proto.buyer_ceo_name,
            supply_amount=proto.supply_amount,
            tax_amount=proto.tax_amount,
            total_amount=proto.total_amount,
            items=[
                InvoiceItem(
                    seq=item.seq,
                    item_name=item.item_name,
                    supply_amount=item.supply_amount,
                    tax_amount=item.tax_amount,
                )
                for item in proto.items
            ],
        )

    def _invoice_to_proto(self, invoice: Invoice):
        """Domain Invoice -> Proto Invoice 변환"""
        return scraper_pb2.Invoice(
            mgt_key=invoice.mgt_key,
            nts_confirm_num=invoice.nts_confirm_num,
            issue_type=invoice.issue_type,
            supplier_corp_num=invoice.supplier_corp_num,
            supplier_corp_name=invoice.supplier_corp_name,
            buyer_corp_num=invoice.buyer_corp_num,
            buyer_corp_name=invoice.buyer_corp_name,
            supply_amount=invoice.supply_amount,
            tax_amount=invoice.tax_amount,
            total_amount=invoice.total_amount,
        )


def serve(port: int = 50051):
    """gRPC 서버 시작"""
    server = grpc.aio.server(futures.ThreadPoolExecutor(max_workers=10))
    scraper_pb2_grpc.add_ScraperServiceServicer_to_server(
        ScraperServicer(), server
    )
    server.add_insecure_port(f"[::]:{port}")
    return server


# services/scraper/src/scraper/main.py
"""gRPC 서버 진입점"""
import asyncio
import logging

from .server import serve

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


async def main():
    server = serve(port=50051)
    await server.start()
    logger.info("Scraper gRPC server started on port 50051")
    await server.wait_for_termination()


if __name__ == "__main__":
    asyncio.run(main())
```

---

## 5. 데이터베이스 설계

### 5.1 기존 스키마와의 호환성

기존 `13_DB_스키마_상세.md`의 `tax_invoices` 테이블을 유지하면서 Provider 정보 컬럼을 추가합니다.

### 5.2 인증서 메타데이터 테이블 (신규)

```sql
-- db/migrations/000042_create_company_cert_meta.up.sql

-- 인증서 파일은 /data/certs/{company_id}/ 에 저장
-- 이 테이블은 메타데이터만 관리

CREATE TABLE company_cert_meta (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,

    -- 인증서 정보
    cert_type VARCHAR(20) NOT NULL DEFAULT 'SIGN',  -- SIGN: 전자서명용, AUTH: 인증용
    serial_number VARCHAR(50),                       -- 인증서 일련번호
    subject_dn VARCHAR(255),                         -- 인증서 소유자 정보
    issuer_dn VARCHAR(255),                          -- 발급기관
    issued_at TIMESTAMPTZ,                           -- 발급일
    expires_at TIMESTAMPTZ NOT NULL,                 -- 만료일

    -- 파일 정보
    file_path VARCHAR(255) NOT NULL,                 -- /data/certs/{company_id}

    -- 상태
    is_active BOOLEAN DEFAULT true,
    last_used_at TIMESTAMPTZ,
    last_error VARCHAR(500),

    -- 감사
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES users(id),

    CONSTRAINT uk_company_cert_type UNIQUE (company_id, cert_type)
);

-- 만료 예정 인증서 알림용 인덱스
CREATE INDEX idx_cert_expires_active ON company_cert_meta(expires_at)
    WHERE is_active = true;

-- 회사별 조회 인덱스
CREATE INDEX idx_cert_company ON company_cert_meta(company_id);

-- RLS 정책
SELECT enable_rls_for_table('company_cert_meta');

COMMENT ON TABLE company_cert_meta IS '공인인증서 메타데이터 (파일은 /data/certs/{company_id}에 저장)';
COMMENT ON COLUMN company_cert_meta.cert_type IS 'SIGN: 전자서명용, AUTH: 인증용';
COMMENT ON COLUMN company_cert_meta.subject_dn IS 'CN=홍길동,OU=center,O=yessign,C=kr 형식';
```

### 5.3 tax_invoices 테이블 확장

```sql
-- db/migrations/000043_add_provider_to_tax_invoices.up.sql

-- provider_type 컬럼 추가
ALTER TABLE tax_invoices
ADD COLUMN IF NOT EXISTS provider_type VARCHAR(20) NOT NULL DEFAULT 'SCRAPER';

-- provider 에러 정보
ALTER TABLE tax_invoices
ADD COLUMN IF NOT EXISTS provider_error VARCHAR(500);

-- 동기화 정보
ALTER TABLE tax_invoices
ADD COLUMN IF NOT EXISTS synced_at TIMESTAMPTZ;

-- 인덱스
CREATE INDEX idx_tax_invoices_provider ON tax_invoices(provider_type);
CREATE INDEX idx_tax_invoices_synced ON tax_invoices(synced_at) WHERE synced_at IS NOT NULL;

COMMENT ON COLUMN tax_invoices.provider_type IS 'SCRAPER, POPBILL, NTS_API';
```

---

## 6. 서비스 레이어

### 6.1 TaxInvoiceService

```go
// internal/service/tax/service.go
package tax

import (
    "context"
    "fmt"
    "time"

    "github.com/google/uuid"

    "k-erp/internal/domain/tax"
    provider "k-erp/internal/infrastructure/tax"
    "k-erp/internal/repository"
)

// Service 세금계산서 서비스
type Service struct {
    repo            repository.TaxInvoiceRepository
    certRepo        repository.CertRepository
    companyRepo     repository.CompanyRepository
    providerFactory *provider.ProviderFactory
    defaultProvider provider.TaxInvoiceProvider
}

// NewService 서비스 생성
func NewService(
    repo repository.TaxInvoiceRepository,
    certRepo repository.CertRepository,
    companyRepo repository.CompanyRepository,
    factory *provider.ProviderFactory,
) (*Service, error) {
    defaultProvider, err := factory.CreateDefault()
    if err != nil {
        return nil, err
    }

    return &Service{
        repo:            repo,
        certRepo:        certRepo,
        companyRepo:     companyRepo,
        providerFactory: factory,
        defaultProvider: defaultProvider,
    }, nil
}

// getProvider 회사별 Provider 획득
func (s *Service) getProvider(ctx context.Context) (provider.TaxInvoiceProvider, error) {
    companyID := ctx.Value("company_id").(uuid.UUID)

    // 인증서 확인
    cert, err := s.certRepo.FindActiveByCompany(ctx, companyID)
    if err != nil {
        // 인증서 없으면 Popbill 사용
        return s.providerFactory.Create(provider.ProviderPopbill)
    }

    // 인증서 만료 확인
    if time.Now().After(cert.ExpiresAt) {
        return s.providerFactory.Create(provider.ProviderPopbill)
    }

    // 스크래퍼 사용
    scraper, err := s.providerFactory.Create(provider.ProviderScraper)
    if err != nil {
        return s.providerFactory.Create(provider.ProviderPopbill)
    }

    return scraper, nil
}

// Issue 세금계산서 발행
func (s *Service) Issue(ctx context.Context, input *IssueInput) (*tax.Invoice, error) {
    companyID := ctx.Value("company_id").(uuid.UUID)

    // 공급자 정보 조회
    company, err := s.companyRepo.FindByID(ctx, companyID)
    if err != nil {
        return nil, fmt.Errorf("failed to get company: %w", err)
    }

    // 관리번호 생성
    mgtKey := generateMgtKey()

    // 도메인 객체 생성
    invoice := &tax.Invoice{
        CompanyID:              companyID,
        MgtKey:                 mgtKey,
        IssueType:              input.IssueType,
        InvoiceType:            input.InvoiceType,
        Status:                 tax.StatusDraft,
        SupplierCorpNum:        company.BusinessNumber,
        SupplierCorpName:       company.Name,
        SupplierCEOName:        company.CEOName,
        BuyerCorpNum:           input.BuyerCorpNum,
        BuyerCorpName:          input.BuyerCorpName,
        BuyerCEOName:           input.BuyerCEOName,
        SupplyValue:            input.SupplyValue,
        TaxAmount:              input.TaxAmount,
        TotalAmount:            input.SupplyValue + input.TaxAmount,
    }

    // DB 저장 (draft)
    if err := s.repo.Create(ctx, invoice); err != nil {
        return nil, fmt.Errorf("failed to save invoice: %w", err)
    }

    // Provider 발행
    prov, err := s.getProvider(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to get provider: %w", err)
    }

    result, err := prov.Issue(ctx, invoice)
    if err != nil {
        // 발행 실패 - Fallback to Popbill
        if prov.ProviderType() == provider.ProviderScraper {
            popbillProv, _ := s.providerFactory.Create(provider.ProviderPopbill)
            result, err = popbillProv.Issue(ctx, invoice)
            if err != nil {
                invoice.ProviderError = err.Error()
                _ = s.repo.Update(ctx, invoice)
                return nil, fmt.Errorf("issue failed: %w", err)
            }
            invoice.ProviderType = string(provider.ProviderPopbill)
        } else {
            invoice.ProviderError = err.Error()
            _ = s.repo.Update(ctx, invoice)
            return nil, fmt.Errorf("issue failed: %w", err)
        }
    }

    // 발행 성공
    invoice.Status = tax.StatusIssued
    invoice.NTSConfirmNum = result.NTSConfirmNum
    invoice.ProviderType = string(prov.ProviderType())

    if err := s.repo.Update(ctx, invoice); err != nil {
        return nil, fmt.Errorf("failed to update invoice: %w", err)
    }

    return invoice, nil
}

// Search 목록 조회
func (s *Service) Search(ctx context.Context, params *SearchParams) (*SearchResult, error) {
    // DB에서 조회 (동기화된 데이터)
    invoices, total, err := s.repo.Search(ctx, params)
    if err != nil {
        return nil, err
    }

    return &SearchResult{
        Invoices:   invoices,
        TotalCount: total,
        Page:       params.Page,
        PerPage:    params.PerPage,
    }, nil
}

// Sync 홈택스 동기화
func (s *Service) Sync(ctx context.Context, dateFrom, dateTo time.Time) (*SyncResult, error) {
    prov, err := s.getProvider(ctx)
    if err != nil {
        return nil, err
    }

    // Provider에서 데이터 조회
    result, err := prov.Sync(ctx, dateFrom, dateTo)
    if err != nil {
        return nil, err
    }

    // DB에 동기화 (upsert)
    // ... 구현

    return &SyncResult{
        SyncedCount: result.SyncedCount,
        NewCount:    result.NewCount,
        UpdatedCount: result.UpdatedCount,
        SyncedAt:    result.SyncedAt,
    }, nil
}

// Cancel 취소
func (s *Service) Cancel(ctx context.Context, id uuid.UUID, reason string) error {
    invoice, err := s.repo.FindByID(ctx, id)
    if err != nil {
        return err
    }

    prov, err := s.getProvider(ctx)
    if err != nil {
        return err
    }

    if err := prov.Cancel(ctx, invoice.MgtKey, reason); err != nil {
        return err
    }

    invoice.Status = tax.StatusCancelled
    return s.repo.Update(ctx, invoice)
}

// generateMgtKey 관리번호 생성 (24자리)
func generateMgtKey() string {
    return fmt.Sprintf("%s%s",
        time.Now().Format("20060102150405"),
        randomString(10))
}
```

---

## 7. API 엔드포인트

### 7.1 REST API

| Method | Endpoint | 설명 |
|--------|----------|------|
| GET | `/api/v1/tax-invoices` | 목록 조회 |
| POST | `/api/v1/tax-invoices` | 발행 |
| GET | `/api/v1/tax-invoices/:id` | 상세 조회 |
| POST | `/api/v1/tax-invoices/:id/cancel` | 취소 |
| POST | `/api/v1/tax-invoices/sync` | 홈택스 동기화 |
| GET | `/api/v1/certificates` | 인증서 목록 |
| POST | `/api/v1/certificates` | 인증서 등록 |
| DELETE | `/api/v1/certificates/:id` | 인증서 삭제 |
| GET | `/api/v1/certificates/status` | 인증서 상태 |

### 7.2 HTTP Handler

```go
// internal/handler/tax/handler.go
package tax

import (
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"

    "k-erp/internal/service/tax"
)

// Handler 세금계산서 핸들러
type Handler struct {
    service *tax.Service
}

// NewHandler 핸들러 생성
func NewHandler(service *tax.Service) *Handler {
    return &Handler{service: service}
}

// RegisterRoutes 라우트 등록
func (h *Handler) RegisterRoutes(r *gin.RouterGroup) {
    g := r.Group("/tax-invoices")
    {
        g.GET("", h.List)
        g.POST("", h.Issue)
        g.GET("/:id", h.Get)
        g.POST("/:id/cancel", h.Cancel)
        g.POST("/sync", h.Sync)
    }

    cert := r.Group("/certificates")
    {
        cert.GET("", h.ListCertificates)
        cert.POST("", h.RegisterCertificate)
        cert.DELETE("/:id", h.DeleteCertificate)
        cert.GET("/status", h.CertificateStatus)
    }
}

// List 목록 조회
// @Summary 세금계산서 목록 조회
// @Tags tax-invoices
// @Produce json
// @Param issue_type query string false "ISSUED|RECEIVED"
// @Param date_from query string false "시작일 (YYYY-MM-DD)"
// @Param date_to query string false "종료일 (YYYY-MM-DD)"
// @Param page query int false "페이지" default(1)
// @Param per_page query int false "페이지당 건수" default(20)
// @Success 200 {object} SearchResponse
// @Router /api/v1/tax-invoices [get]
func (h *Handler) List(c *gin.Context) {
    var params tax.SearchParams
    if err := c.ShouldBindQuery(&params); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    result, err := h.service.Search(c.Request.Context(), &params)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, result)
}

// Issue 발행
// @Summary 세금계산서 발행
// @Tags tax-invoices
// @Accept json
// @Produce json
// @Param body body IssueRequest true "발행 정보"
// @Success 201 {object} InvoiceResponse
// @Router /api/v1/tax-invoices [post]
func (h *Handler) Issue(c *gin.Context) {
    var req IssueRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    input := &tax.IssueInput{
        IssueType:     req.IssueType,
        InvoiceType:   req.InvoiceType,
        BuyerCorpNum:  req.Buyer.CorpNum,
        BuyerCorpName: req.Buyer.CorpName,
        BuyerCEOName:  req.Buyer.CEOName,
        SupplyValue:   req.SupplyValue,
        TaxAmount:     req.TaxAmount,
        Items:         req.Items,
    }

    invoice, err := h.service.Issue(c.Request.Context(), input)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusCreated, toInvoiceResponse(invoice))
}

// Sync 홈택스 동기화
// @Summary 홈택스 데이터 동기화
// @Tags tax-invoices
// @Accept json
// @Produce json
// @Param body body SyncRequest true "동기화 기간"
// @Success 200 {object} SyncResponse
// @Router /api/v1/tax-invoices/sync [post]
func (h *Handler) Sync(c *gin.Context) {
    var req SyncRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    dateFrom, _ := time.Parse("2006-01-02", req.DateFrom)
    dateTo, _ := time.Parse("2006-01-02", req.DateTo)

    result, err := h.service.Sync(c.Request.Context(), dateFrom, dateTo)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, result)
}

// RegisterCertificate 인증서 등록
// @Summary 공인인증서 등록
// @Tags certificates
// @Accept multipart/form-data
// @Produce json
// @Param cert formData file true "인증서 파일 (signCert.der)"
// @Param key formData file true "개인키 파일 (signPri.key)"
// @Param password formData string true "인증서 비밀번호"
// @Success 201 {object} CertificateResponse
// @Router /api/v1/certificates [post]
func (h *Handler) RegisterCertificate(c *gin.Context) {
    // 파일 업로드 처리
    certFile, _ := c.FormFile("cert")
    keyFile, _ := c.FormFile("key")
    password := c.PostForm("password")

    // 인증서 저장 및 검증
    // ... 구현

    c.JSON(http.StatusCreated, gin.H{"message": "certificate registered"})
}
```

---

## 8. 설정

### 8.1 환경변수

```bash
# .env

# 세금계산서 Provider 설정
TAX_PROVIDER=scraper  # scraper | popbill | nts_api

# 스크래핑 설정
SCRAPER_CERT_PATH=/data/certs
SCRAPER_TIMEOUT=30s
SCRAPER_RETRY_COUNT=3

# Popbill 백업 (Fallback용)
POPBILL_LINK_ID=your_link_id
POPBILL_SECRET_KEY=your_secret_key
POPBILL_IS_TEST=true

# 인증서 비밀번호 암호화 키 (AES-256)
CERT_ENCRYPTION_KEY=your-32-byte-encryption-key-here
```

### 8.2 설정 구조체

```go
// internal/config/tax.go
package config

import "time"

// TaxConfig 세금계산서 설정
type TaxConfig struct {
    DefaultProvider ProviderType `mapstructure:"TAX_PROVIDER"`
    Scraper         *ScraperConfig
    Popbill         *PopbillConfig
}

// ScraperConfig 스크래퍼 설정
type ScraperConfig struct {
    CertBasePath string        `mapstructure:"SCRAPER_CERT_PATH"`
    Timeout      time.Duration `mapstructure:"SCRAPER_TIMEOUT"`
    RetryCount   int           `mapstructure:"SCRAPER_RETRY_COUNT"`
}

// PopbillConfig Popbill 설정
type PopbillConfig struct {
    LinkID    string `mapstructure:"POPBILL_LINK_ID"`
    SecretKey string `mapstructure:"POPBILL_SECRET_KEY"`
    IsTest    bool   `mapstructure:"POPBILL_IS_TEST"`
}
```

---

## 9. 에러 처리

### 9.1 Scraper 에러 코드

| 코드 | 설명 | 대응 |
|------|------|------|
| `CERT_NOT_FOUND` | 인증서 없음 | 인증서 등록 필요 |
| `CERT_EXPIRED` | 인증서 만료 | 인증서 갱신 |
| `CERT_PASSWORD_WRONG` | 비밀번호 오류 | 비밀번호 확인 |
| `SESSION_EXPIRED` | 세션 만료 | 자동 재로그인 |
| `HOMETAX_UNAVAILABLE` | 홈택스 접속 불가 | Popbill Fallback |
| `PARSE_ERROR` | 응답 파싱 실패 | 로그 확인 |

### 9.2 에러 처리 전략

```go
// internal/infrastructure/tax/scraper/error.go
package scraper

import "fmt"

// ScraperError 스크래퍼 에러
type ScraperError struct {
    Code    string
    Message string
    Cause   error
}

func (e *ScraperError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("[%s] %s: %v", e.Code, e.Message, e.Cause)
    }
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

// 에러 코드
const (
    ErrCertNotFound      = "CERT_NOT_FOUND"
    ErrCertExpired       = "CERT_EXPIRED"
    ErrCertPasswordWrong = "CERT_PASSWORD_WRONG"
    ErrSessionExpired    = "SESSION_EXPIRED"
    ErrHometaxUnavail    = "HOMETAX_UNAVAILABLE"
    ErrParseError        = "PARSE_ERROR"
)

// IsRetryable 재시도 가능 여부
func (e *ScraperError) IsRetryable() bool {
    switch e.Code {
    case ErrSessionExpired, ErrHometaxUnavail:
        return true
    default:
        return false
    }
}

// ShouldFallback Popbill Fallback 필요 여부
func (e *ScraperError) ShouldFallback() bool {
    switch e.Code {
    case ErrCertNotFound, ErrCertExpired, ErrHometaxUnavail:
        return true
    default:
        return false
    }
}
```

---

## 10. 리스크 및 대응

### 10.1 기술적 리스크

| 리스크 | 영향 | 확률 | 대응 |
|--------|------|------|------|
| 홈택스 UI 변경 | 스크래핑 실패 | 중 | Parser 모듈화, 빠른 대응 체계 |
| 인증서 파싱 복잡 | 개발 지연 | 저 | Go crypto 라이브러리 활용 |
| 세션 만료 | 작업 실패 | 중 | 자동 재로그인, 세션 갱신 |
| 동시 접속 제한 | 처리량 한계 | 중 | 요청 큐잉, Rate Limiting |

### 10.2 법적 리스크

| 리스크 | 대응 |
|--------|------|
| 이용약관 위반 우려 | 자사 인증서로 본인 데이터만 조회 (합법적 접근) |
| 스크래핑 차단 | Popbill Fallback 즉시 전환 |
| 국세청 정책 변경 | API 공개 시 Provider 전환 |

### 10.3 Fallback 전략 (3단계)

```
                         요청
                          |
                          v
                 +----------------+
                 |  Scraper 시도  |
                 |    (1순위)     |
                 +----------------+
                          |
                +----+----+----+
                |              |
             성공           실패
                |              |
                v              v
             완료     +----------------+
                      |  NTS API 시도  |
                      |    (2순위)     |
                      +----------------+
                               |
                      +----+---+---+
                      |            |
                   성공         실패
                      |            |
                      v            v
                   완료    +----------------+
                           | Popbill 시도   |
                           |   (3순위)      |
                           +----------------+
                                    |
                           +----+---+---+
                           |            |
                        성공         실패
                           |            |
                           v            v
                        완료       에러 반환
```

---

## 11. Provider 선택기 및 Health Check

### 11.1 Provider 선택기 (무료 우선)

```go
// internal/infrastructure/tax/selector.go
package tax

import (
    "context"
    "log/slog"
    "time"
)

// ProviderSelector Provider 선택기 (무료 최대화 전략)
type ProviderSelector struct {
    factory     *ProviderFactory
    certRepo    CertRepository
    configRepo  ConfigRepository
    healthCache *HealthCache
}

// SelectProvider 최적 Provider 선택 (무료 우선)
func (s *ProviderSelector) SelectProvider(ctx context.Context, companyID string) (TaxInvoiceProvider, error) {
    // 1순위: 홈택스 스크래핑
    if provider, err := s.tryScraperProvider(ctx, companyID); err == nil {
        return provider, nil
    }

    // 2순위: 홈택스 Open API
    if provider, err := s.tryNTSAPIProvider(ctx, companyID); err == nil {
        return provider, nil
    }

    // 3순위: Popbill (최후의 보루)
    slog.Warn("falling back to Popbill",
        "company_id", companyID,
        "reason", "free providers unavailable")

    return s.factory.Create(ProviderPopbill)
}

// tryScraperProvider 스크래핑 Provider 시도
func (s *ProviderSelector) tryScraperProvider(ctx context.Context, companyID string) (TaxInvoiceProvider, error) {
    // 1. 인증서 확인
    cert, err := s.certRepo.FindActiveByCompany(ctx, companyID)
    if err != nil {
        return nil, &ProviderError{Code: "CERT_NOT_FOUND", Message: "certificate not found"}
    }

    // 2. 인증서 만료 확인
    if time.Now().After(cert.ExpiresAt) {
        return nil, &ProviderError{Code: "CERT_EXPIRED", Message: "certificate expired"}
    }

    // 3. 홈택스 상태 확인 (캐시된 health check)
    if !s.healthCache.IsHealthy(ProviderScraper) {
        return nil, &ProviderError{Code: "HOMETAX_UNAVAILABLE", Message: "hometax is down"}
    }

    return s.factory.Create(ProviderScraper)
}

// tryNTSAPIProvider 국세청 API Provider 시도
func (s *ProviderSelector) tryNTSAPIProvider(ctx context.Context, companyID string) (TaxInvoiceProvider, error) {
    // 1. API 활성화 여부 확인
    config, err := s.configRepo.GetTaxConfig(ctx, companyID)
    if err != nil || !config.NTSAPIEnabled {
        return nil, &ProviderError{Code: "NTS_API_DISABLED", Message: "NTS API not enabled"}
    }

    // 2. 일일 할당량 확인
    usage, err := s.configRepo.GetDailyUsage(ctx, companyID, ProviderNTSAPI)
    if err != nil || usage >= config.NTSAPIDailyLimit {
        return nil, &ProviderError{Code: "NTS_API_QUOTA_EXCEEDED", Message: "daily quota exceeded"}
    }

    // 3. API 상태 확인
    if !s.healthCache.IsHealthy(ProviderNTSAPI) {
        return nil, &ProviderError{Code: "NTS_API_UNAVAILABLE", Message: "NTS API is down"}
    }

    return s.factory.Create(ProviderNTSAPI)
}
```

### 11.2 Health Check 캐시

```go
// internal/infrastructure/tax/health.go
package tax

import (
    "context"
    "sync"
    "time"
)

// Health Check 상수
const (
    HealthCheckInterval = 1 * time.Minute
    FailureThreshold    = 3
    RecoveryBackoff     = 5 * time.Minute
    MaxRecoveryBackoff  = 30 * time.Minute
)

// HealthCache Provider 상태 캐시
type HealthCache struct {
    mu       sync.RWMutex
    statuses map[ProviderType]*HealthStatus
    factory  *ProviderFactory
}

// HealthStatus Provider 상태
type HealthStatus struct {
    IsHealthy     bool
    LastChecked   time.Time
    LastError     error
    FailureCount  int
    RecoveryAfter time.Time
}

// StartHealthChecker 백그라운드 Health Checker 시작
func (h *HealthCache) StartHealthChecker(ctx context.Context) {
    ticker := time.NewTicker(HealthCheckInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            h.checkAllProviders(ctx)
        }
    }
}

// checkProvider 개별 Provider 상태 확인
func (h *HealthCache) checkProvider(ctx context.Context, pt ProviderType) {
    h.mu.Lock()
    defer h.mu.Unlock()

    status, exists := h.statuses[pt]
    if !exists {
        status = &HealthStatus{IsHealthy: true}
        h.statuses[pt] = status
    }

    // Recovery 대기 중이면 스킵
    if time.Now().Before(status.RecoveryAfter) {
        return
    }

    // Provider 생성 및 Health Check
    provider, err := h.factory.Create(pt)
    if err != nil {
        h.markUnhealthy(status, err)
        return
    }

    checkCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
    defer cancel()

    if err := provider.HealthCheck(checkCtx); err != nil {
        h.markUnhealthy(status, err)
        return
    }

    // 복구 성공
    status.IsHealthy = true
    status.FailureCount = 0
    status.LastChecked = time.Now()
    status.LastError = nil
}

// markUnhealthy 장애 상태 마킹 (Exponential Backoff)
func (h *HealthCache) markUnhealthy(status *HealthStatus, err error) {
    status.FailureCount++
    status.LastError = err
    status.LastChecked = time.Now()

    if status.FailureCount >= FailureThreshold {
        status.IsHealthy = false
        backoff := time.Duration(status.FailureCount-FailureThreshold+1) * RecoveryBackoff
        if backoff > MaxRecoveryBackoff {
            backoff = MaxRecoveryBackoff
        }
        status.RecoveryAfter = time.Now().Add(backoff)
    }
}

// IsHealthy Provider 상태 확인
func (h *HealthCache) IsHealthy(pt ProviderType) bool {
    h.mu.RLock()
    defer h.mu.RUnlock()

    status, exists := h.statuses[pt]
    if !exists {
        return true
    }
    return status.IsHealthy
}
```

---

## 12. Fallback Chain 구현

```go
// internal/infrastructure/tax/chain.go
package tax

import (
    "context"
    "fmt"
    "log/slog"

    "k-erp/internal/domain/tax"
)

// ProviderChain Fallback 체인
type ProviderChain struct {
    selector *ProviderSelector
    factory  *ProviderFactory
    metrics  *ProviderMetrics
}

// Issue 발행 (3단계 Fallback 체인 적용)
func (c *ProviderChain) Issue(ctx context.Context, invoice *tax.Invoice) (*IssueResult, error) {
    companyID := ctx.Value("company_id").(string)

    // 우선순위: Scraper -> NTS API -> Popbill
    providers := []ProviderType{ProviderScraper, ProviderNTSAPI, ProviderPopbill}

    var lastErr error
    for _, pt := range providers {
        provider, err := c.tryProvider(ctx, companyID, pt)
        if err != nil {
            slog.Debug("provider unavailable",
                "provider", pt,
                "error", err)
            continue
        }

        result, err := provider.Issue(ctx, invoice)
        if err == nil {
            c.metrics.RecordSuccess(pt)
            slog.Info("invoice issued",
                "provider", pt,
                "mgt_key", result.MgtKey)
            return result, nil
        }

        lastErr = err
        c.metrics.RecordFailure(pt, err)

        slog.Warn("provider failed, trying next",
            "provider", pt,
            "error", err)
    }

    return nil, fmt.Errorf("all providers failed: %w", lastErr)
}

// tryProvider Provider 시도
func (c *ProviderChain) tryProvider(ctx context.Context, companyID string, pt ProviderType) (TaxInvoiceProvider, error) {
    switch pt {
    case ProviderScraper:
        return c.selector.tryScraperProvider(ctx, companyID)
    case ProviderNTSAPI:
        return c.selector.tryNTSAPIProvider(ctx, companyID)
    case ProviderPopbill:
        return c.factory.Create(ProviderPopbill)
    default:
        return nil, fmt.Errorf("unknown provider: %s", pt)
    }
}
```

---

## 13. Provider 사용량 메트릭

### 13.1 메트릭 수집

```go
// internal/infrastructure/tax/metrics.go
package tax

import (
    "fmt"
    "sync"
    "time"
)

// ProviderMetrics Provider 사용량 메트릭
type ProviderMetrics struct {
    mu    sync.RWMutex
    daily map[string]*DailyMetrics
    repo  MetricsRepository
}

// DailyMetrics 일별 메트릭
type DailyMetrics struct {
    Date          string
    ScraperCount  int64
    ScraperErrors int64
    NTSAPICount   int64
    NTSAPIErrors  int64
    PopbillCount  int64
    PopbillErrors int64
    TotalCost     int64 // Popbill 비용 (원)
}

// RecordSuccess 성공 기록
func (m *ProviderMetrics) RecordSuccess(pt ProviderType) {
    m.mu.Lock()
    defer m.mu.Unlock()

    today := time.Now().Format("2006-01-02")
    metrics := m.getOrCreateDaily(today)

    switch pt {
    case ProviderScraper:
        metrics.ScraperCount++
    case ProviderNTSAPI:
        metrics.NTSAPICount++
    case ProviderPopbill:
        metrics.PopbillCount++
        metrics.TotalCost += 100 // 100원/건
    }
}

// GetFreeRatio 무료 Provider 사용 비율
func (m *ProviderMetrics) GetFreeRatio(date string) float64 {
    m.mu.RLock()
    defer m.mu.RUnlock()

    metrics, exists := m.daily[date]
    if !exists {
        return 1.0
    }

    total := metrics.ScraperCount + metrics.NTSAPICount + metrics.PopbillCount
    if total == 0 {
        return 1.0
    }

    freeCount := metrics.ScraperCount + metrics.NTSAPICount
    return float64(freeCount) / float64(total)
}

// GetMonthlySavings 월간 절감액 계산
func (m *ProviderMetrics) GetMonthlySavings(year int, month int) *SavingsReport {
    m.mu.RLock()
    defer m.mu.RUnlock()

    var totalIssued, popbillUsed, actualCost int64
    prefix := fmt.Sprintf("%04d-%02d", year, month)

    for date, metrics := range m.daily {
        if len(date) >= 7 && date[:7] == prefix {
            totalIssued += metrics.ScraperCount + metrics.NTSAPICount + metrics.PopbillCount
            popbillUsed += metrics.PopbillCount
            actualCost += metrics.TotalCost
        }
    }

    potentialCost := totalIssued * 100
    return &SavingsReport{
        YearMonth:     prefix,
        TotalIssued:   totalIssued,
        FreeUsed:      totalIssued - popbillUsed,
        PopbillUsed:   popbillUsed,
        FreeRatio:     float64(totalIssued-popbillUsed) / float64(totalIssued) * 100,
        ActualCost:    actualCost,
        PotentialCost: potentialCost,
        SavedAmount:   potentialCost - actualCost,
    }
}

// SavingsReport 절감 리포트
type SavingsReport struct {
    YearMonth     string  `json:"year_month"`
    TotalIssued   int64   `json:"total_issued"`
    FreeUsed      int64   `json:"free_used"`
    PopbillUsed   int64   `json:"popbill_used"`
    FreeRatio     float64 `json:"free_ratio_percent"`
    ActualCost    int64   `json:"actual_cost"`
    PotentialCost int64   `json:"potential_cost"`
    SavedAmount   int64   `json:"saved_amount"`
}
```

### 13.2 메트릭 API

| Method | Endpoint | 설명 |
|--------|----------|------|
| GET | `/api/v1/tax-invoices/metrics/daily` | 일별 메트릭 |
| GET | `/api/v1/tax-invoices/metrics/monthly` | 월별 메트릭 |
| GET | `/api/v1/tax-invoices/metrics/savings` | 절감 리포트 |

**Response 예시**:
```json
{
    "year_month": "2025-01",
    "total_issued": 5432,
    "free_used": 5160,
    "popbill_used": 272,
    "free_ratio_percent": 95.0,
    "actual_cost": 27200,
    "potential_cost": 543200,
    "saved_amount": 516000
}
```

---

## 14. 알림 시스템

### 14.1 알림 임계값

| 항목 | 경고 | 심각 | 설명 |
|------|------|------|------|
| Popbill 사용률 | 10% | 20% | 무료 Provider 상태 확인 필요 |
| 인증서 만료 | 7일 전 | 3일 전 | 갱신 필요 |
| 일일 비용 | 50,000원 | 100,000원 | 비용 이상 감지 |

### 14.2 알림 서비스 구현

```go
// internal/infrastructure/tax/alert.go
package tax

import (
    "context"
    "fmt"
    "time"
)

// AlertThresholds 알림 임계값
type AlertThresholds struct {
    PopbillRatioWarning  float64 // 0.10 (10%)
    PopbillRatioCritical float64 // 0.20 (20%)
    CertExpiryWarningDays int    // 7일
    CertExpiryCriticalDays int   // 3일
    DailyCostWarning     int64   // 50,000원
    DailyCostCritical    int64   // 100,000원
}

// AlertService 알림 서비스
type AlertService struct {
    metrics    *ProviderMetrics
    certRepo   CertRepository
    notifier   Notifier
    thresholds *AlertThresholds
}

// CheckAndAlert 상태 확인 및 알림 (cron: 매 시간)
func (s *AlertService) CheckAndAlert(ctx context.Context) {
    today := time.Now().Format("2006-01-02")

    // 1. Popbill 사용률 확인
    s.checkPopbillRatio(ctx, today)

    // 2. 인증서 만료 확인
    s.checkCertExpiry(ctx)

    // 3. 일일 비용 확인
    s.checkDailyCost(ctx, today)
}

// checkPopbillRatio Popbill 사용률 확인
func (s *AlertService) checkPopbillRatio(ctx context.Context, date string) {
    freeRatio := s.metrics.GetFreeRatio(date)
    popbillRatio := 1.0 - freeRatio

    if popbillRatio >= s.thresholds.PopbillRatioCritical {
        s.notifier.SendAlert(ctx, &Alert{
            Level:   AlertCritical,
            Title:   "Popbill 사용률 심각",
            Message: fmt.Sprintf("Popbill 사용률 %.1f%% - 무료 Provider 상태 확인 필요", popbillRatio*100),
        })
    } else if popbillRatio >= s.thresholds.PopbillRatioWarning {
        s.notifier.SendAlert(ctx, &Alert{
            Level:   AlertWarning,
            Title:   "Popbill 사용률 경고",
            Message: fmt.Sprintf("Popbill 사용률 %.1f%%", popbillRatio*100),
        })
    }
}

// checkCertExpiry 인증서 만료 확인
func (s *AlertService) checkCertExpiry(ctx context.Context) {
    // 7일 내 만료 예정 인증서 조회
    certs, _ := s.certRepo.FindExpiringWithinDays(ctx, s.thresholds.CertExpiryWarningDays)

    for _, cert := range certs {
        daysLeft := int(time.Until(cert.ExpiresAt).Hours() / 24)
        level := AlertWarning
        if daysLeft <= s.thresholds.CertExpiryCriticalDays {
            level = AlertCritical
        }

        s.notifier.SendAlert(ctx, &Alert{
            Level:     level,
            Title:     "인증서 만료 임박",
            Message:   fmt.Sprintf("%s 인증서가 %d일 후 만료", cert.CompanyName, daysLeft),
            CompanyID: cert.CompanyID,
        })
    }
}
```

---

## 15. 데이터베이스 스키마 추가

### 15.1 Provider 메트릭 테이블

```sql
-- db/migrations/000044_create_provider_metrics.up.sql

CREATE TABLE provider_daily_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES companies(id),
    metric_date DATE NOT NULL,

    -- Provider별 사용량
    scraper_success_count INT DEFAULT 0,
    scraper_failure_count INT DEFAULT 0,
    nts_api_success_count INT DEFAULT 0,
    nts_api_failure_count INT DEFAULT 0,
    popbill_success_count INT DEFAULT 0,
    popbill_failure_count INT DEFAULT 0,

    -- 비용 (원)
    popbill_cost_krw BIGINT DEFAULT 0,

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT uk_company_metric_date UNIQUE (company_id, metric_date)
);

CREATE INDEX idx_metrics_date ON provider_daily_metrics(metric_date);
CREATE INDEX idx_metrics_company_date ON provider_daily_metrics(company_id, metric_date);

SELECT enable_rls_for_table('provider_daily_metrics');

COMMENT ON TABLE provider_daily_metrics IS 'Provider별 일일 사용량 메트릭';
```

### 15.2 Provider Health 로그 테이블

```sql
-- db/migrations/000045_create_provider_health_logs.up.sql

CREATE TABLE provider_health_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_type VARCHAR(20) NOT NULL,  -- SCRAPER, NTS_API, POPBILL
    is_healthy BOOLEAN NOT NULL,
    error_message VARCHAR(500),
    response_time_ms INT,
    checked_at TIMESTAMPTZ DEFAULT NOW()
);

-- 최근 7일 데이터만 보관
CREATE INDEX idx_health_logs_checked ON provider_health_logs(checked_at);

-- 자동 삭제 (pg_cron 또는 애플리케이션 배치)
-- DELETE FROM provider_health_logs WHERE checked_at < NOW() - INTERVAL '7 days';

COMMENT ON TABLE provider_health_logs IS 'Provider 상태 로그 (모니터링용, 7일 보관)';
```

### 15.3 NTS API 설정 테이블

```sql
-- db/migrations/000046_create_nts_api_config.up.sql

CREATE TABLE company_nts_api_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,

    -- API 설정
    is_enabled BOOLEAN DEFAULT false,
    api_key VARCHAR(100),
    daily_limit INT DEFAULT 1000,

    -- 사용량 추적
    today_usage INT DEFAULT 0,
    usage_reset_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT uk_company_nts_config UNIQUE (company_id)
);

SELECT enable_rls_for_table('company_nts_api_config');

COMMENT ON TABLE company_nts_api_config IS '회사별 국세청 API 설정';
COMMENT ON COLUMN company_nts_api_config.daily_limit IS '일일 API 호출 한도 (기본 1,000건)';
```

---

## 16. 최종 아키텍처 (Go + Python)

```
+--------------------------------------------------------------------------------+
|                               K-ERP 세금계산서                                   |
+--------------------------------------------------------------------------------+
|                                                                                  |
|  +--------------------------------------------------------------------------+   |
|  |                         Go API Server                                     |   |
|  |                                                                           |   |
|  |  +-----------------+  +------------------+  +------------------+          |   |
|  |  | TaxInvoice      |  | ProviderChain    |  | AlertService     |          |   |
|  |  | Service         |  | + HealthCache    |  | (Slack/Email)    |          |   |
|  |  |                 |  | + Selector       |  |                  |          |   |
|  |  |                 |  | + Metrics        |  |                  |          |   |
|  |  +-----------------+  +------------------+  +------------------+          |   |
|  |           |                   |                                           |   |
|  |           |    +--------------+-------------------+                       |   |
|  |           |    |              |                   |                       |   |
|  |           v    v              v                   v                       |   |
|  |  +-------------+     +-------------+     +-------------+                  |   |
|  |  | Scraper     |     | NTS API     |     | Popbill     |                  |   |
|  |  | gRPC Client |     | HTTP Client |     | HTTP Client |                  |   |
|  |  | (Go)        |     | (Go)        |     | (Go)        |                  |   |
|  |  +------+------+     +-------------+     +-------------+                  |   |
|  |         |                 무료              100원/건                       |   |
|  +---------|-----------------------------------------------------------------+   |
|            | gRPC (port 50051)                                                   |
|            v                                                                     |
|  +--------------------------------------------------------------------------+   |
|  |                    Python Scraper Service                                 |   |
|  |                    (별도 컨테이너)                                         |   |
|  |                                                                           |   |
|  |  +------------------+  +------------------+  +------------------+         |   |
|  |  | gRPC Servicer    |  | SEED-CBC         |  | Hometax Client   |         |   |
|  |  |                  |  | (pycryptodome)   |  | (httpx)          |         |   |
|  |  +------------------+  +------------------+  +------------------+         |   |
|  |                                                                           |   |
|  +--------------------------------------------------------------------------+   |
|                                                                                  |
|  Provider 우선순위: Scraper(무료) -> NTS API(무료) -> Popbill(유료)             |
|  목표: Popbill 사용률 5% 미만                                                    |
|                                                                                  |
+--------------------------------------------------------------------------------+
```

---

## 17. Docker/K8s 배포 설정

### 17.1 Python Scraper Dockerfile

```dockerfile
# services/scraper/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 시스템 의존성
RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Poetry 설치
RUN pip install poetry

# 의존성 설치
COPY pyproject.toml poetry.lock ./
RUN poetry config virtualenvs.create false \
    && poetry install --no-dev --no-interaction --no-ansi

# 소스 복사
COPY src/ ./src/

# gRPC 포트
EXPOSE 50051

# 헬스체크
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import grpc; channel = grpc.insecure_channel('localhost:50051'); grpc.channel_ready_future(channel).result(timeout=5)"

# 실행
CMD ["python", "-m", "scraper.main"]
```

### 17.2 Docker Compose (개발 환경)

```yaml
# deployments/docker-compose.scraper.yaml
version: '3.8'

services:
  # Go API Server
  api:
    build:
      context: ..
      dockerfile: deployments/Dockerfile.api
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
      - SCRAPER_GRPC_ADDR=scraper:50051
      - POPBILL_API_KEY=${POPBILL_API_KEY}
    depends_on:
      - postgres
      - redis
      - scraper
    networks:
      - kerp-network

  # Python Scraper Service
  scraper:
    build:
      context: ../services/scraper
      dockerfile: Dockerfile
    ports:
      - "50051:50051"
    volumes:
      - cert-data:/data/certs:ro  # 인증서 마운트 (읽기 전용)
    environment:
      - LOG_LEVEL=INFO
      - GRPC_PORT=50051
    healthcheck:
      test: ["CMD", "python", "-c", "import grpc; grpc.insecure_channel('localhost:50051')"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - kerp-network

  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: kerp
      POSTGRES_USER: kerp
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - kerp-network

  redis:
    image: redis:7-alpine
    networks:
      - kerp-network

volumes:
  postgres-data:
  cert-data:

networks:
  kerp-network:
    driver: bridge
```

### 17.3 Kubernetes 배포 (프로덕션)

```yaml
# deployments/k8s/scraper-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: scraper
  namespace: kerp
  labels:
    app: scraper
    component: tax-invoice
spec:
  replicas: 2
  selector:
    matchLabels:
      app: scraper
  template:
    metadata:
      labels:
        app: scraper
    spec:
      containers:
        - name: scraper
          image: kerp/scraper:latest
          ports:
            - containerPort: 50051
              name: grpc
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            exec:
              command: ["python", "-c", "import grpc; grpc.insecure_channel('localhost:50051')"]
            initialDelaySeconds: 10
            periodSeconds: 30
          readinessProbe:
            exec:
              command: ["python", "-c", "import grpc; grpc.insecure_channel('localhost:50051')"]
            initialDelaySeconds: 5
            periodSeconds: 10
          volumeMounts:
            - name: cert-volume
              mountPath: /data/certs
              readOnly: true
          env:
            - name: LOG_LEVEL
              value: "INFO"
            - name: GRPC_PORT
              value: "50051"
      volumes:
        - name: cert-volume
          persistentVolumeClaim:
            claimName: cert-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: scraper
  namespace: kerp
spec:
  selector:
    app: scraper
  ports:
    - port: 50051
      targetPort: 50051
      name: grpc
  type: ClusterIP
```

### 17.4 Python 의존성 (pyproject.toml)

```toml
# services/scraper/pyproject.toml
[tool.poetry]
name = "scraper"
version = "1.0.0"
description = "Hometax Tax Invoice Scraper Service"
authors = ["K-ERP Team"]

[tool.poetry.dependencies]
python = "^3.11"
grpcio = "^1.60.0"
grpcio-tools = "^1.60.0"
httpx = "^0.26.0"
pycryptodome = "^3.20.0"
asn1crypto = "^1.5.1"
cryptography = "^42.0.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-asyncio = "^0.23.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

---

## 18. 구현 일정

### Phase 1: 기반 구조 (1주)

- [ ] Provider 인터페이스 정의 (Go)
- [ ] 도메인 모델 구현 (Go)
- [ ] gRPC Proto 정의 및 코드 생성
- [ ] DB 마이그레이션 (메트릭, NTS API 설정 테이블)
- [ ] Repository 구현

### Phase 2: Python Scraper 개발 (1주)

- [ ] Python 프로젝트 셋업 (Poetry)
- [ ] SEED-CBC 복호화 모듈 (pycryptodome)
- [ ] 공인인증서 파싱/서명
- [ ] 홈택스 인증 (5단계)
- [ ] 세션 관리 (자동 갱신)
- [ ] 세금계산서 조회/발행
- [ ] XML 파서
- [ ] gRPC Servicer 구현

### Phase 3: Go 통합 (0.5주)

- [ ] Scraper gRPC Client 구현
- [ ] Provider Factory 수정
- [ ] Docker Compose 설정
- [ ] 단위 테스트

### Phase 4: NTS API 연동 (1주)

- [ ] 국세청 Open API 연동 (Go)
- [ ] API 키 관리
- [ ] 일일 할당량 관리
- [ ] Rate Limiting

### Phase 5: 무료 최대화 인프라 (0.5주)

- [ ] Provider 선택기 (ProviderSelector)
- [ ] Health Check 캐시
- [ ] Fallback Chain
- [ ] 메트릭 수집/저장

### Phase 6: 모니터링/알림 (0.5주)

- [ ] 알림 서비스 (Slack/Email)
- [ ] 대시보드 API
- [ ] 절감 리포트

### Phase 7: 통합 테스트 및 배포 (0.5주)

- [ ] E2E 테스트
- [ ] K8s 배포 설정
- [ ] 부하 테스트
- [ ] 프로덕션 배포

---

## 19. 참고 문서

| 문서 | 설명 |
|------|------|
| `02_세금계산서_연동_설계.md` | Popbill 연동 (3순위 Fallback Provider) |
| `07_보안_설계.md` | 암호화 패턴 (인증서 비밀번호) |
| `12_API_설계_상세.md` | REST API 스펙 |
| `13_DB_스키마_상세.md` | 테이블 설계 |

---

**문서 버전**: 3.0
**작성일**: 2025년 1월
**수정일**: 2026년 1월 (Python 마이크로서비스 아키텍처 반영)
**작성자**: K-ERP 개발팀
**주요 변경사항**:
- **v3.0**: Python 마이크로서비스 아키텍처로 변경 (Go + Python 하이브리드)
  - 홈택스 스크래핑을 Python 서비스로 분리 (SEED-CBC 암호화 지원)
  - gRPC 통신 인터페이스 추가
  - Docker/K8s 배포 설정 추가
- v2.0: Provider 우선순위 변경: Scraper(1) -> NTS API(2) -> Popbill(3)
- v2.0: 무료 최대화 전략 추가 (목표: Popbill 5% 미만)
- v2.0: Health Check, Fallback Chain, Metrics 시스템 추가
- v2.0: 알림 시스템 추가 (Popbill 사용률, 인증서 만료)
- v2.0: DB 스키마 추가 (메트릭, Health 로그, NTS API 설정)
