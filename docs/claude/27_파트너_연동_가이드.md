# 27. 파트너 연동 가이드

## 1. 개요

### 1.1 목적
K-ERP SaaS 플랫폼과 외부 파트너 시스템 간의 연동 방법, 기술 요구사항, 운영 가이드를 정의한다.

### 1.2 연동 파트너 목록
| 파트너 | 연동 목적 | 연동 방식 | 관련 모듈 |
|--------|-----------|-----------|-----------|
| **Popbill** | 전자세금계산서 | REST API | 세금계산서 |
| **국민연금공단** | 4대보험 신고 | EDI (VAN) | 급여/인사 |
| **건강보험공단** | 건강/장기요양보험 | EDI (VAN) | 급여/인사 |
| **고용산재보험** | 고용/산재보험 | EDI (VAN) | 급여/인사 |
| **은행** | 계좌조회/이체 | 오픈뱅킹 API | 회계/급여 |
| **PG사** | 결제 | REST API | 결제 |
| **택배사** | 배송조회 | REST API | 재고/판매 |

## 2. Popbill 세금계산서 연동

### 2.1 연동 구성
```
┌─────────────────┐     REST API     ┌─────────────────┐
│    K-ERP API    │ ───────────────→ │    Popbill      │
│  (세금계산서)    │ ←─────────────── │    ASP 서버     │
└─────────────────┘                   └─────────────────┘
         │                                    │
         │                                    │
         ▼                                    ▼
┌─────────────────┐                  ┌─────────────────┐
│   PostgreSQL    │                  │   국세청 NTS    │
│  (전표/계산서)   │                  │  (홈택스 연동)   │
└─────────────────┘                  └─────────────────┘
```

### 2.2 Popbill 클라이언트 구현
```go
// internal/infrastructure/popbill/client.go
package popbill

import (
    "bytes"
    "context"
    "crypto/sha256"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

type Config struct {
    LinkID      string        // 링크 아이디
    SecretKey   string        // 비밀키
    IsTest      bool          // 테스트 모드
    Timeout     time.Duration // API 타임아웃
}

type Client struct {
    config     Config
    httpClient *http.Client
    baseURL    string
}

func NewClient(config Config) *Client {
    baseURL := "https://popbill.linkhub.co.kr"
    if config.IsTest {
        baseURL = "https://popbill-test.linkhub.co.kr"
    }

    return &Client{
        config: config,
        httpClient: &http.Client{
            Timeout: config.Timeout,
        },
        baseURL: baseURL,
    }
}

// 세션 토큰 발급
func (c *Client) GetAccessToken(ctx context.Context, corpNum string) (string, error) {
    timestamp := time.Now().UTC().Format("2006-01-02T15:04:05Z")

    // 서명 생성
    hmacTarget := fmt.Sprintf("POST\n%s\n\n\n%s", timestamp, "/POPBILL_TEST/Token")
    signature := c.generateSignature(hmacTarget)

    req, err := http.NewRequestWithContext(ctx, "POST",
        c.baseURL+"/POPBILL_TEST/Token",
        bytes.NewReader([]byte(`{"access_id":"`+c.config.LinkID+`","scope":["110"]}`)),
    )
    if err != nil {
        return "", err
    }

    req.Header.Set("x-lh-date", timestamp)
    req.Header.Set("x-lh-version", "2.0")
    req.Header.Set("Authorization", fmt.Sprintf("LINKHUB %s:%s", c.config.LinkID, signature))
    req.Header.Set("Content-Type", "application/json")

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return "", fmt.Errorf("token request failed: %w", err)
    }
    defer resp.Body.Close()

    var tokenResp struct {
        SessionToken string `json:"session_token"`
        ExpireIn     int    `json:"expireIn"`
    }

    if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
        return "", err
    }

    return tokenResp.SessionToken, nil
}

// HMAC-SHA256 서명 생성
func (c *Client) generateSignature(target string) string {
    h := sha256.New()
    h.Write([]byte(c.config.SecretKey))
    h.Write([]byte(target))
    return base64.StdEncoding.EncodeToString(h.Sum(nil))
}
```

### 2.3 세금계산서 발행 서비스
```go
// internal/service/taxinvoice/popbill_service.go
package taxinvoice

import (
    "context"
    "fmt"

    "k-erp/internal/domain"
    "k-erp/internal/infrastructure/popbill"
)

type PopbillService struct {
    client     *popbill.Client
    repo       TaxInvoiceRepository
    auditLog   AuditLogger
}

// 세금계산서 구조체 (Popbill 형식)
type PopbillTaxInvoice struct {
    WriteDate       string              `json:"writeDate"`       // 작성일자
    ChargeDirection string              `json:"chargeDirection"` // 정과금/역과금
    IssueType       string              `json:"issueType"`       // 발행형태
    TaxType         string              `json:"taxType"`         // 과세형태

    // 공급자 정보
    InvoicerCorpNum    string `json:"invoicerCorpNum"`    // 사업자번호
    InvoicerCorpName   string `json:"invoicerCorpName"`   // 상호
    InvoicerCEOName    string `json:"invoicerCEOName"`    // 대표자명
    InvoicerAddr       string `json:"invoicerAddr"`       // 주소
    InvoicerBizType    string `json:"invoicerBizType"`    // 업태
    InvoicerBizClass   string `json:"invoicerBizClass"`   // 종목
    InvoicerEmail      string `json:"invoicerEmail"`      // 이메일

    // 공급받는자 정보
    InvoiceeCorpNum    string `json:"invoiceeCorpNum"`
    InvoiceeCorpName   string `json:"invoiceeCorpName"`
    InvoiceeCEOName    string `json:"invoiceeCEOName"`
    InvoiceeAddr       string `json:"invoiceeAddr"`
    InvoiceeEmail      string `json:"invoiceeEmail"`

    // 금액 정보
    SupplyCostTotal    int64  `json:"supplyCostTotal"`    // 공급가액 합계
    TaxTotal           int64  `json:"taxTotal"`           // 세액 합계
    TotalAmount        int64  `json:"totalAmount"`        // 합계금액

    // 품목 정보
    DetailList         []PopbillTaxInvoiceItem `json:"detailList"`
}

type PopbillTaxInvoiceItem struct {
    SerialNum    int    `json:"serialNum"`    // 일련번호
    ItemName     string `json:"itemName"`     // 품목명
    Spec         string `json:"spec"`         // 규격
    Qty          int    `json:"qty"`          // 수량
    UnitCost     int64  `json:"unitCost"`     // 단가
    SupplyCost   int64  `json:"supplyCost"`   // 공급가액
    Tax          int64  `json:"tax"`          // 세액
}

// 세금계산서 발행
func (s *PopbillService) Issue(ctx context.Context, invoice *domain.TaxInvoice) (*domain.TaxInvoiceResult, error) {
    // 1. 도메인 모델 → Popbill 형식 변환
    popbillInvoice := s.toPopbillFormat(invoice)

    // 2. 세션 토큰 발급
    token, err := s.client.GetAccessToken(ctx, invoice.SupplierBusinessNo)
    if err != nil {
        return nil, fmt.Errorf("failed to get access token: %w", err)
    }

    // 3. 세금계산서 등록
    mgtKey, err := s.client.Register(ctx, token, invoice.SupplierBusinessNo, popbillInvoice)
    if err != nil {
        return nil, fmt.Errorf("failed to register tax invoice: %w", err)
    }

    // 4. 발행 요청
    if err := s.client.Issue(ctx, token, invoice.SupplierBusinessNo, mgtKey); err != nil {
        return nil, fmt.Errorf("failed to issue tax invoice: %w", err)
    }

    // 5. 발행 결과 조회
    result, err := s.client.GetInfo(ctx, token, invoice.SupplierBusinessNo, mgtKey)
    if err != nil {
        return nil, fmt.Errorf("failed to get invoice info: %w", err)
    }

    // 6. 감사 로그 기록
    s.auditLog.Log(ctx, AuditEvent{
        Type:       "tax_invoice.issued",
        Resource:   "tax_invoice",
        ResourceID: mgtKey,
        Details:    map[string]interface{}{"nts_confirm_num": result.NTSConfirmNum},
    })

    // 7. 로컬 DB 업데이트
    invoice.ExternalID = mgtKey
    invoice.NTSConfirmNum = result.NTSConfirmNum
    invoice.Status = domain.TaxInvoiceStatusIssued
    invoice.IssuedAt = time.Now()

    if err := s.repo.Update(ctx, invoice); err != nil {
        return nil, err
    }

    return &domain.TaxInvoiceResult{
        MgtKey:        mgtKey,
        NTSConfirmNum: result.NTSConfirmNum,
        IssuedAt:      invoice.IssuedAt,
    }, nil
}

// 세금계산서 상태 동기화 (배치)
func (s *PopbillService) SyncStatus(ctx context.Context, corpNum string) error {
    // 미확인 상태 세금계산서 조회
    invoices, err := s.repo.FindByStatus(ctx, corpNum, domain.TaxInvoiceStatusIssued)
    if err != nil {
        return err
    }

    for _, invoice := range invoices {
        token, _ := s.client.GetAccessToken(ctx, corpNum)
        info, err := s.client.GetInfo(ctx, token, corpNum, invoice.ExternalID)
        if err != nil {
            log.Error("failed to sync invoice status", "mgt_key", invoice.ExternalID, "error", err)
            continue
        }

        // 상태 업데이트
        invoice.Status = mapPopbillStatus(info.StateCode)
        invoice.NTSResultCode = info.NTSResultCode
        s.repo.Update(ctx, invoice)
    }

    return nil
}

func (s *PopbillService) toPopbillFormat(inv *domain.TaxInvoice) *PopbillTaxInvoice {
    result := &PopbillTaxInvoice{
        WriteDate:          inv.IssueDate.Format("20060102"),
        ChargeDirection:    "정과금",
        IssueType:          "정발행",
        TaxType:            "과세",
        InvoicerCorpNum:    inv.SupplierBusinessNo,
        InvoicerCorpName:   inv.SupplierName,
        InvoicerCEOName:    inv.SupplierRepName,
        InvoicerAddr:       inv.SupplierAddress,
        InvoicerEmail:      inv.SupplierEmail,
        InvoiceeCorpNum:    inv.BuyerBusinessNo,
        InvoiceeCorpName:   inv.BuyerName,
        InvoiceeCEOName:    inv.BuyerRepName,
        InvoiceeAddr:       inv.BuyerAddress,
        InvoiceeEmail:      inv.BuyerEmail,
        SupplyCostTotal:    inv.SupplyValue,
        TaxTotal:           inv.TaxAmount,
        TotalAmount:        inv.TotalAmount,
    }

    for i, item := range inv.Items {
        result.DetailList = append(result.DetailList, PopbillTaxInvoiceItem{
            SerialNum:  i + 1,
            ItemName:   item.Name,
            Spec:       item.Spec,
            Qty:        item.Quantity,
            UnitCost:   item.UnitPrice,
            SupplyCost: item.SupplyValue,
            Tax:        item.TaxAmount,
        })
    }

    return result
}
```

### 2.4 Popbill 에러 처리
```go
// internal/infrastructure/popbill/errors.go
package popbill

import "fmt"

type PopbillError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
}

func (e *PopbillError) Error() string {
    return fmt.Sprintf("popbill error [%d]: %s", e.Code, e.Message)
}

// 주요 에러 코드 매핑
var ErrorMessages = map[int]string{
    -10000001: "인증토큰 발급 실패",
    -10000002: "링크아이디 오류",
    -10000003: "서명 생성 오류",
    -11000001: "사업자번호 형식 오류",
    -11000002: "공급받는자 정보 오류",
    -12000001: "세금계산서 등록 실패",
    -12000002: "세금계산서 발행 실패",
    -12000003: "중복 발행",
    -12000004: "발행 기한 초과",
    -14000001: "포인트 잔액 부족",
    -99999999: "시스템 오류",
}

// 재시도 가능 여부 판단
func IsRetryable(code int) bool {
    retryableCodes := map[int]bool{
        -99999999: true, // 시스템 오류
        -10000001: true, // 토큰 만료
    }
    return retryableCodes[code]
}
```

## 3. 4대보험 EDI 연동

### 3.1 EDI 연동 구조
```
┌─────────────────┐     SFTP/VAN     ┌─────────────────┐     EDI      ┌─────────────────┐
│    K-ERP        │ ───────────────→ │    VAN 사업자   │ ──────────→ │    공단 서버    │
│  (급여 시스템)   │ ←─────────────── │   (세영정보 등)  │ ←────────── │   (NPS/NHIS)    │
└─────────────────┘                   └─────────────────┘              └─────────────────┘
```

### 3.2 EDI 클라이언트 구현
```go
// internal/infrastructure/edi/client.go
package edi

import (
    "context"
    "fmt"
    "io"
    "path/filepath"
    "time"

    "github.com/pkg/sftp"
    "golang.org/x/crypto/ssh"
)

type EDIClient struct {
    config     EDIConfig
    sshClient  *ssh.Client
    sftpClient *sftp.Client
}

type EDIConfig struct {
    Host       string
    Port       int
    Username   string
    Password   string        // 또는 PrivateKey
    PrivateKey []byte
    RemoteDir  string        // 원격 디렉토리
    LocalDir   string        // 로컬 작업 디렉토리
    Timeout    time.Duration
}

func NewEDIClient(config EDIConfig) (*EDIClient, error) {
    var auth []ssh.AuthMethod

    if config.Password != "" {
        auth = append(auth, ssh.Password(config.Password))
    }

    if len(config.PrivateKey) > 0 {
        signer, err := ssh.ParsePrivateKey(config.PrivateKey)
        if err != nil {
            return nil, fmt.Errorf("failed to parse private key: %w", err)
        }
        auth = append(auth, ssh.PublicKeys(signer))
    }

    sshConfig := &ssh.ClientConfig{
        User:            config.Username,
        Auth:            auth,
        HostKeyCallback: ssh.InsecureIgnoreHostKey(), // 프로덕션에서는 Known Hosts 확인
        Timeout:         config.Timeout,
    }

    addr := fmt.Sprintf("%s:%d", config.Host, config.Port)
    client, err := ssh.Dial("tcp", addr, sshConfig)
    if err != nil {
        return nil, fmt.Errorf("ssh connection failed: %w", err)
    }

    sftpClient, err := sftp.NewClient(client)
    if err != nil {
        client.Close()
        return nil, fmt.Errorf("sftp client creation failed: %w", err)
    }

    return &EDIClient{
        config:     config,
        sshClient:  client,
        sftpClient: sftpClient,
    }, nil
}

// EDI 파일 전송
func (c *EDIClient) Upload(ctx context.Context, filename string, data []byte) error {
    remotePath := filepath.Join(c.config.RemoteDir, "send", filename)

    remoteFile, err := c.sftpClient.Create(remotePath)
    if err != nil {
        return fmt.Errorf("failed to create remote file: %w", err)
    }
    defer remoteFile.Close()

    if _, err := remoteFile.Write(data); err != nil {
        return fmt.Errorf("failed to write to remote file: %w", err)
    }

    log.Info("EDI file uploaded", "filename", filename, "size", len(data))
    return nil
}

// EDI 응답 파일 수신
func (c *EDIClient) Download(ctx context.Context, filename string) ([]byte, error) {
    remotePath := filepath.Join(c.config.RemoteDir, "recv", filename)

    remoteFile, err := c.sftpClient.Open(remotePath)
    if err != nil {
        return nil, fmt.Errorf("failed to open remote file: %w", err)
    }
    defer remoteFile.Close()

    data, err := io.ReadAll(remoteFile)
    if err != nil {
        return nil, fmt.Errorf("failed to read remote file: %w", err)
    }

    return data, nil
}

// 수신 대기 파일 목록 조회
func (c *EDIClient) ListPendingFiles(ctx context.Context) ([]string, error) {
    recvDir := filepath.Join(c.config.RemoteDir, "recv")
    files, err := c.sftpClient.ReadDir(recvDir)
    if err != nil {
        return nil, err
    }

    var filenames []string
    for _, f := range files {
        if !f.IsDir() {
            filenames = append(filenames, f.Name())
        }
    }

    return filenames, nil
}

func (c *EDIClient) Close() error {
    if c.sftpClient != nil {
        c.sftpClient.Close()
    }
    if c.sshClient != nil {
        c.sshClient.Close()
    }
    return nil
}
```

### 3.3 국민연금 EDI 파일 생성
```go
// internal/service/insurance/nps_edi.go
package insurance

import (
    "bytes"
    "fmt"
    "strings"
    "time"

    "golang.org/x/text/encoding/korean"
    "golang.org/x/text/transform"
)

// 국민연금 취득신고 파일 생성
type NPSAcquisitionReport struct {
    // 헤더
    RecordType     string // "H"
    FileType       string // "NP1001"
    CompanyRegNo   string // 사업장관리번호 (10자리)
    CreateDate     string // YYYYMMDD
    TotalRecords   int

    // 상세 레코드
    Employees []NPSAcquisitionDetail
}

type NPSAcquisitionDetail struct {
    RecordType       string // "D"
    ResidentNo       string // 주민등록번호 (13자리)
    Name             string // 성명 (한글 10자)
    AcquisitionDate  string // 취득일 YYYYMMDD
    AcquisitionReason string // 취득사유 (1자리)
    MonthlyIncome    int64  // 기준소득월액
    JobType          string // 직종 코드
}

// EDI 파일 생성 (EUC-KR 인코딩)
func (r *NPSAcquisitionReport) Generate() ([]byte, error) {
    var buf bytes.Buffer

    // 헤더 레코드
    header := fmt.Sprintf("H%-6s%-10s%-8s%05d\r\n",
        r.FileType,
        r.CompanyRegNo,
        r.CreateDate,
        len(r.Employees),
    )
    buf.WriteString(header)

    // 상세 레코드
    for _, emp := range r.Employees {
        // 이름 패딩 (한글 10자 = 20바이트)
        paddedName := padKorean(emp.Name, 20)

        detail := fmt.Sprintf("D%-13s%-20s%-8s%-1s%09d%-2s\r\n",
            emp.ResidentNo,
            paddedName,
            emp.AcquisitionDate,
            emp.AcquisitionReason,
            emp.MonthlyIncome,
            emp.JobType,
        )
        buf.WriteString(detail)
    }

    // 트레일러 레코드
    trailer := fmt.Sprintf("T%05d\r\n", len(r.Employees))
    buf.WriteString(trailer)

    // EUC-KR 인코딩
    encoder := korean.EUCKR.NewEncoder()
    encoded, _, err := transform.Bytes(encoder, buf.Bytes())
    if err != nil {
        return nil, fmt.Errorf("encoding failed: %w", err)
    }

    return encoded, nil
}

// 한글 문자열 패딩 (바이트 기준)
func padKorean(s string, width int) string {
    // EUC-KR에서 한글은 2바이트
    encoder := korean.EUCKR.NewEncoder()
    encoded, _, _ := transform.String(encoder, s)
    padding := width - len(encoded)
    if padding > 0 {
        return s + strings.Repeat(" ", padding)
    }
    return s
}
```

### 3.4 건강보험 EDI 연동
```go
// internal/service/insurance/nhis_edi.go
package insurance

import (
    "bytes"
    "fmt"
)

// 건강보험 자격취득신고
type NHISAcquisitionReport struct {
    CompanyRegNo   string // 사업장기호
    CreateDate     string
    Employees      []NHISAcquisitionDetail
}

type NHISAcquisitionDetail struct {
    ResidentNo      string // 주민등록번호
    Name            string // 성명
    AcquisitionDate string // 취득일
    Dependents      int    // 피부양자 수
    MonthlyWage     int64  // 보수월액
}

func (r *NHISAcquisitionReport) Generate() ([]byte, error) {
    var buf bytes.Buffer

    // 건강보험공단 EDI 형식에 맞춰 생성
    // (실제 형식은 건강보험공단 EDI 매뉴얼 참조)

    header := fmt.Sprintf("HDR%-10s%-8s%05d\r\n",
        r.CompanyRegNo,
        r.CreateDate,
        len(r.Employees),
    )
    buf.WriteString(header)

    for _, emp := range r.Employees {
        detail := fmt.Sprintf("DTL%-13s%-20s%-8s%02d%09d\r\n",
            emp.ResidentNo,
            padKorean(emp.Name, 20),
            emp.AcquisitionDate,
            emp.Dependents,
            emp.MonthlyWage,
        )
        buf.WriteString(detail)
    }

    // EUC-KR 인코딩 후 반환
    return encodeToEUCKR(buf.Bytes())
}
```

### 3.5 EDI 배치 처리
```go
// internal/worker/edi_worker.go
package worker

import (
    "context"
    "time"
)

type EDIWorker struct {
    ediClient       *edi.EDIClient
    npsService      *insurance.NPSService
    nhisService     *insurance.NHISService
    employmentSvc   *insurance.EmploymentService
    notifier        Notifier
}

// 매일 정해진 시간에 EDI 파일 전송
func (w *EDIWorker) ProcessDailyReports(ctx context.Context) error {
    companies, err := w.getCompaniesWithPendingReports(ctx)
    if err != nil {
        return err
    }

    for _, company := range companies {
        // 1. 국민연금 신고
        if reports := w.npsService.GetPendingReports(ctx, company.ID); len(reports) > 0 {
            for _, report := range reports {
                data, err := report.Generate()
                if err != nil {
                    w.handleError(ctx, company.ID, "NPS", err)
                    continue
                }

                filename := fmt.Sprintf("NP1001_%s_%s.dat",
                    company.BusinessNo,
                    time.Now().Format("20060102150405"),
                )

                if err := w.ediClient.Upload(ctx, filename, data); err != nil {
                    w.handleError(ctx, company.ID, "NPS", err)
                    continue
                }

                report.Status = "SENT"
                report.SentAt = time.Now()
                w.npsService.UpdateReport(ctx, report)
            }
        }

        // 2. 건강보험 신고
        // ... 유사한 로직

        // 3. 고용/산재보험 신고
        // ... 유사한 로직
    }

    return nil
}

// EDI 응답 파일 처리
func (w *EDIWorker) ProcessResponses(ctx context.Context) error {
    files, err := w.ediClient.ListPendingFiles(ctx)
    if err != nil {
        return err
    }

    for _, filename := range files {
        data, err := w.ediClient.Download(ctx, filename)
        if err != nil {
            log.Error("failed to download EDI response", "filename", filename, "error", err)
            continue
        }

        // 파일 타입에 따라 처리
        switch {
        case strings.HasPrefix(filename, "NP"):
            w.npsService.ProcessResponse(ctx, data)
        case strings.HasPrefix(filename, "NH"):
            w.nhisService.ProcessResponse(ctx, data)
        case strings.HasPrefix(filename, "EI"):
            w.employmentSvc.ProcessResponse(ctx, data)
        }

        // 처리 완료 파일 아카이브
        w.archiveFile(ctx, filename)
    }

    return nil
}
```

## 4. 오픈뱅킹 API 연동

### 4.1 오픈뱅킹 구성
```
┌─────────────────┐     OAuth 2.0     ┌─────────────────┐     금융결제원     ┌─────────────────┐
│    K-ERP        │ ───────────────→ │   오픈뱅킹       │ ──────────────→  │    참가 은행    │
│   (회계 모듈)    │ ←─────────────── │    센터          │ ←────────────── │  (국민,신한 등)  │
└─────────────────┘                   └─────────────────┘                  └─────────────────┘
```

### 4.2 오픈뱅킹 클라이언트
```go
// internal/infrastructure/openbanking/client.go
package openbanking

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "net/url"
    "time"
)

type Config struct {
    ClientID     string
    ClientSecret string
    BaseURL      string        // https://openapi.openbanking.or.kr
    RedirectURI  string
    IsTest       bool
}

type Client struct {
    config     Config
    httpClient *http.Client
}

// OAuth 2.0 인가 URL 생성
func (c *Client) GetAuthorizationURL(state, scope string) string {
    params := url.Values{
        "response_type": {"code"},
        "client_id":     {c.config.ClientID},
        "redirect_uri":  {c.config.RedirectURI},
        "scope":         {scope},  // "login inquiry transfer"
        "state":         {state},
        "auth_type":     {"0"},    // 0: 최초인증, 1: 재인증
    }

    return fmt.Sprintf("%s/oauth/2.0/authorize?%s", c.config.BaseURL, params.Encode())
}

// Access Token 발급
func (c *Client) GetAccessToken(ctx context.Context, code string) (*TokenResponse, error) {
    params := url.Values{
        "code":          {code},
        "client_id":     {c.config.ClientID},
        "client_secret": {c.config.ClientSecret},
        "redirect_uri":  {c.config.RedirectURI},
        "grant_type":    {"authorization_code"},
    }

    resp, err := c.httpClient.PostForm(c.config.BaseURL+"/oauth/2.0/token", params)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var tokenResp TokenResponse
    if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
        return nil, err
    }

    return &tokenResp, nil
}

type TokenResponse struct {
    AccessToken  string `json:"access_token"`
    TokenType    string `json:"token_type"`
    ExpiresIn    int    `json:"expires_in"`
    RefreshToken string `json:"refresh_token"`
    Scope        string `json:"scope"`
    UserSeqNo    string `json:"user_seq_no"`
}

// 잔액 조회
func (c *Client) GetBalance(ctx context.Context, accessToken, bankCode, accountNum string) (*BalanceResponse, error) {
    req, err := http.NewRequestWithContext(ctx, "GET",
        c.config.BaseURL+"/v2.0/account/balance/fin_num", nil)
    if err != nil {
        return nil, err
    }

    q := req.URL.Query()
    q.Add("bank_tran_id", c.generateTranID())
    q.Add("fintech_use_num", accountNum)
    q.Add("tran_dtime", time.Now().Format("20060102150405"))
    req.URL.RawQuery = q.Encode()

    req.Header.Set("Authorization", "Bearer "+accessToken)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var balanceResp BalanceResponse
    if err := json.NewDecoder(resp.Body).Decode(&balanceResp); err != nil {
        return nil, err
    }

    return &balanceResp, nil
}

type BalanceResponse struct {
    APITranID         string `json:"api_tran_id"`
    RspCode           string `json:"rsp_code"`
    RspMessage        string `json:"rsp_message"`
    BankName          string `json:"bank_name"`
    AccountNumMasked  string `json:"account_num_masked"`
    BalanceAmt        string `json:"balance_amt"`
    AvailableAmt      string `json:"available_amt"`
    ProductName       string `json:"product_name"`
}

// 거래내역 조회
func (c *Client) GetTransactions(ctx context.Context, accessToken, fintechUseNum, fromDate, toDate string) (*TransactionListResponse, error) {
    req, err := http.NewRequestWithContext(ctx, "GET",
        c.config.BaseURL+"/v2.0/account/transaction_list/fin_num", nil)
    if err != nil {
        return nil, err
    }

    q := req.URL.Query()
    q.Add("bank_tran_id", c.generateTranID())
    q.Add("fintech_use_num", fintechUseNum)
    q.Add("inquiry_type", "A")  // A: 전체, I: 입금, O: 출금
    q.Add("inquiry_base", "D")  // D: 날짜, T: 시간
    q.Add("from_date", fromDate)
    q.Add("to_date", toDate)
    q.Add("sort_order", "D")    // D: 내림차순, A: 오름차순
    q.Add("tran_dtime", time.Now().Format("20060102150405"))
    req.URL.RawQuery = q.Encode()

    req.Header.Set("Authorization", "Bearer "+accessToken)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var result TransactionListResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }

    return &result, nil
}

type TransactionListResponse struct {
    RspCode    string        `json:"rsp_code"`
    RspMessage string        `json:"rsp_message"`
    ResList    []Transaction `json:"res_list"`
}

type Transaction struct {
    TranDate        string `json:"tran_date"`
    TranTime        string `json:"tran_time"`
    InoutType       string `json:"inout_type"`     // 입출금구분
    TranType        string `json:"tran_type"`      // 거래구분
    PrintContent    string `json:"print_content"`  // 통장인자내용
    TranAmt         string `json:"tran_amt"`       // 거래금액
    AfterBalanceAmt string `json:"after_balance_amt"`
    BranchName      string `json:"branch_name"`
}

func (c *Client) generateTranID() string {
    return fmt.Sprintf("M%s%s%09d",
        c.config.ClientID[:10],
        "U",
        time.Now().UnixNano()%1000000000,
    )
}
```

## 5. PG사 결제 연동

### 5.1 결제 모듈 구조
```go
// internal/infrastructure/payment/interface.go
package payment

import (
    "context"

    "github.com/google/uuid"
)

// PG사 공통 인터페이스
type PaymentGateway interface {
    // 결제 요청
    RequestPayment(ctx context.Context, req *PaymentRequest) (*PaymentResponse, error)

    // 결제 취소
    CancelPayment(ctx context.Context, paymentID string, amount int64) (*CancelResponse, error)

    // 결제 조회
    GetPayment(ctx context.Context, paymentID string) (*PaymentDetail, error)

    // 빌링키 발급 (정기결제)
    IssueBillingKey(ctx context.Context, req *BillingKeyRequest) (*BillingKeyResponse, error)

    // 빌링키 결제
    PayWithBillingKey(ctx context.Context, billingKey string, amount int64) (*PaymentResponse, error)
}

type PaymentRequest struct {
    OrderID     uuid.UUID
    Amount      int64
    ProductName string
    BuyerEmail  string
    BuyerName   string
    BuyerTel    string
    SuccessURL  string
    FailURL     string
    CancelURL   string
}

type PaymentResponse struct {
    PaymentID   string
    Status      PaymentStatus
    PaidAt      *time.Time
    ReceiptURL  string
    CardInfo    *CardInfo
}

type PaymentStatus string

const (
    PaymentStatusReady     PaymentStatus = "ready"
    PaymentStatusPaid      PaymentStatus = "paid"
    PaymentStatusCancelled PaymentStatus = "cancelled"
    PaymentStatusFailed    PaymentStatus = "failed"
)
```

### 5.2 토스페이먼츠 구현
```go
// internal/infrastructure/payment/tosspayments.go
package payment

import (
    "bytes"
    "context"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "net/http"
)

type TossPayments struct {
    secretKey  string
    clientKey  string
    baseURL    string
    httpClient *http.Client
}

func NewTossPayments(secretKey, clientKey string, isTest bool) *TossPayments {
    baseURL := "https://api.tosspayments.com"
    if isTest {
        baseURL = "https://api.tosspayments.com/sandbox"
    }

    return &TossPayments{
        secretKey:  secretKey,
        clientKey:  clientKey,
        baseURL:    baseURL,
        httpClient: &http.Client{Timeout: 30 * time.Second},
    }
}

// 결제 승인
func (t *TossPayments) ConfirmPayment(ctx context.Context, paymentKey, orderID string, amount int64) (*PaymentResponse, error) {
    payload := map[string]interface{}{
        "paymentKey": paymentKey,
        "orderId":    orderID,
        "amount":     amount,
    }

    body, _ := json.Marshal(payload)

    req, err := http.NewRequestWithContext(ctx, "POST",
        t.baseURL+"/v1/payments/confirm",
        bytes.NewReader(body),
    )
    if err != nil {
        return nil, err
    }

    req.Header.Set("Authorization", t.getAuthHeader())
    req.Header.Set("Content-Type", "application/json")

    resp, err := t.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        var errResp TossErrorResponse
        json.NewDecoder(resp.Body).Decode(&errResp)
        return nil, &PaymentError{
            Code:    errResp.Code,
            Message: errResp.Message,
        }
    }

    var result TossPaymentResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }

    return t.toPaymentResponse(&result), nil
}

// 결제 취소
func (t *TossPayments) CancelPayment(ctx context.Context, paymentKey string, amount int64, reason string) (*CancelResponse, error) {
    payload := map[string]interface{}{
        "cancelReason": reason,
    }
    if amount > 0 {
        payload["cancelAmount"] = amount // 부분 취소
    }

    body, _ := json.Marshal(payload)

    req, err := http.NewRequestWithContext(ctx, "POST",
        fmt.Sprintf("%s/v1/payments/%s/cancel", t.baseURL, paymentKey),
        bytes.NewReader(body),
    )
    if err != nil {
        return nil, err
    }

    req.Header.Set("Authorization", t.getAuthHeader())
    req.Header.Set("Content-Type", "application/json")

    resp, err := t.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    // ... 응답 처리
    return &CancelResponse{}, nil
}

func (t *TossPayments) getAuthHeader() string {
    credentials := base64.StdEncoding.EncodeToString([]byte(t.secretKey + ":"))
    return "Basic " + credentials
}

type TossPaymentResponse struct {
    PaymentKey    string    `json:"paymentKey"`
    OrderID       string    `json:"orderId"`
    Status        string    `json:"status"`
    TotalAmount   int64     `json:"totalAmount"`
    ApprovedAt    string    `json:"approvedAt"`
    Receipt       struct {
        URL string `json:"url"`
    } `json:"receipt"`
    Card          *struct {
        Company        string `json:"company"`
        Number         string `json:"number"`
        InstallmentPlanMonths int `json:"installmentPlanMonths"`
    } `json:"card"`
}

type TossErrorResponse struct {
    Code    string `json:"code"`
    Message string `json:"message"`
}
```

## 6. 연동 모니터링

### 6.1 외부 API 헬스체크
```go
// internal/service/integration/health_checker.go
package integration

import (
    "context"
    "sync"
    "time"
)

type IntegrationHealth struct {
    Name      string
    Status    HealthStatus
    Latency   time.Duration
    LastCheck time.Time
    Error     string
}

type HealthStatus string

const (
    HealthStatusUp       HealthStatus = "up"
    HealthStatusDown     HealthStatus = "down"
    HealthStatusDegraded HealthStatus = "degraded"
)

type HealthChecker struct {
    checks map[string]HealthCheckFunc
    mu     sync.RWMutex
}

type HealthCheckFunc func(ctx context.Context) (*IntegrationHealth, error)

// 전체 파트너 헬스체크 실행
func (h *HealthChecker) CheckAll(ctx context.Context) map[string]*IntegrationHealth {
    results := make(map[string]*IntegrationHealth)
    var wg sync.WaitGroup

    for name, checkFunc := range h.checks {
        wg.Add(1)
        go func(name string, fn HealthCheckFunc) {
            defer wg.Done()

            ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
            defer cancel()

            start := time.Now()
            health, err := fn(ctx)
            latency := time.Since(start)

            h.mu.Lock()
            if err != nil {
                results[name] = &IntegrationHealth{
                    Name:      name,
                    Status:    HealthStatusDown,
                    Latency:   latency,
                    LastCheck: time.Now(),
                    Error:     err.Error(),
                }
            } else {
                health.Latency = latency
                health.LastCheck = time.Now()
                results[name] = health
            }
            h.mu.Unlock()
        }(name, checkFunc)
    }

    wg.Wait()
    return results
}

// Popbill 헬스체크
func CheckPopbillHealth(client *popbill.Client) HealthCheckFunc {
    return func(ctx context.Context) (*IntegrationHealth, error) {
        // 간단한 API 호출로 상태 확인
        _, err := client.GetAccessToken(ctx, "0000000000")
        if err != nil {
            return nil, err
        }

        return &IntegrationHealth{
            Name:   "Popbill",
            Status: HealthStatusUp,
        }, nil
    }
}

// 오픈뱅킹 헬스체크
func CheckOpenBankingHealth(client *openbanking.Client) HealthCheckFunc {
    return func(ctx context.Context) (*IntegrationHealth, error) {
        // 서버 상태 확인 API 호출
        resp, err := http.Get(client.config.BaseURL + "/health")
        if err != nil {
            return nil, err
        }
        defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK {
            return &IntegrationHealth{
                Name:   "OpenBanking",
                Status: HealthStatusDegraded,
            }, nil
        }

        return &IntegrationHealth{
            Name:   "OpenBanking",
            Status: HealthStatusUp,
        }, nil
    }
}
```

### 6.2 연동 메트릭
```go
// internal/infrastructure/metrics/integration_metrics.go
package metrics

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    // 외부 API 호출 횟수
    IntegrationRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "kerp_integration_requests_total",
            Help: "Total integration API requests",
        },
        []string{"partner", "endpoint", "status"},
    )

    // 외부 API 응답 시간
    IntegrationRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "kerp_integration_request_duration_seconds",
            Help:    "Integration API request duration",
            Buckets: prometheus.DefBuckets,
        },
        []string{"partner", "endpoint"},
    )

    // 외부 API 에러
    IntegrationErrorsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "kerp_integration_errors_total",
            Help: "Total integration API errors",
        },
        []string{"partner", "error_code"},
    )

    // 연동 상태
    IntegrationHealthStatus = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "kerp_integration_health_status",
            Help: "Integration health status (1=up, 0=down)",
        },
        []string{"partner"},
    )
)
```

## 7. 관련 문서

| 문서 | 설명 |
|------|------|
| [02_세금계산서_연동_설계.md](./02_세금계산서_연동_설계.md) | Popbill 연동 상세 |
| [03_4대보험_EDI_연동.md](./03_4대보험_EDI_연동.md) | EDI 파일 형식 상세 |
| [07_보안_설계.md](./07_보안_설계.md) | API 인증/보안 |
| [18_에러_핸들링_가이드.md](./18_에러_핸들링_가이드.md) | 외부 API 에러 처리 |

---

*문서 버전: 1.0.0*
*최종 수정: 2025년 1월*
*작성자: K-ERP 개발팀*
