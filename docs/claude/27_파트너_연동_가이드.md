# 27. 파트너 연동 가이드 (Partner Integration Guide)

## 목차
1. [개요](#1-개요)
2. [파트너 유형](#2-파트너-유형)
3. [인증 및 보안](#3-인증-및-보안)
4. [API 연동](#4-api-연동)
5. [웹훅 연동](#5-웹훅-연동)
6. [SDK 제공](#6-sdk-제공)
7. [테스트 환경](#7-테스트-환경)
8. [운영 가이드](#8-운영-가이드)

---

## 1. 개요

### 1.1 파트너 프로그램 개요

```yaml
partner_program:
  description: "K-ERP 파트너 연동 프로그램"
  objectives:
    - "생태계 확장"
    - "고객 가치 제공"
    - "서드파티 서비스 통합"

  partner_types:
    reseller:
      name: "리셀러 파트너"
      description: "K-ERP 재판매 및 고객 지원"
      benefits:
        - "판매 수수료"
        - "마케팅 지원"
        - "기술 교육"

    technology:
      name: "기술 파트너"
      description: "API/플러그인 개발 및 연동"
      benefits:
        - "API 전체 액세스"
        - "개발자 지원"
        - "마켓플레이스 등록"

    consulting:
      name: "컨설팅 파트너"
      description: "구축/컨설팅 서비스 제공"
      benefits:
        - "구축 수수료"
        - "전문 교육"
        - "공동 마케팅"

integration_scope:
  data_sync: "데이터 동기화 (읽기/쓰기)"
  automation: "업무 자동화"
  extension: "기능 확장"
  reporting: "맞춤 리포팅"
```

### 1.2 연동 아키텍처

```
┌────────────────────────────────────────────────────────────────────┐
│                    Partner Integration Architecture                 │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  External Partners                       K-ERP Platform             │
│  ┌─────────────────┐                    ┌─────────────────────┐    │
│  │  Partner App A  │───┐                │                     │    │
│  │  (Banking)      │   │                │    API Gateway      │    │
│  └─────────────────┘   │                │  ┌───────────────┐  │    │
│                        │   REST API     │  │ Rate Limiter  │  │    │
│  ┌─────────────────┐   ├───────────────→│  │ Auth (OAuth)  │  │    │
│  │  Partner App B  │   │                │  │ Logging       │  │    │
│  │  (HR System)    │───┤                │  └───────┬───────┘  │    │
│  └─────────────────┘   │                │          │          │    │
│                        │                │          ▼          │    │
│  ┌─────────────────┐   │   Webhooks     │  ┌───────────────┐  │    │
│  │  Partner App C  │───┘   ←───────────────│  Go API       │  │    │
│  │  (BI Tool)      │                    │  │  Services     │  │    │
│  └─────────────────┘                    │  └───────────────┘  │    │
│                                         │          │          │    │
│                                         │          ▼          │    │
│                                         │  ┌───────────────┐  │    │
│                                         │  │  PostgreSQL   │  │    │
│                                         │  │  (Tenant DB)  │  │    │
│                                         │  └───────────────┘  │    │
│                                         └─────────────────────┘    │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

---

## 2. 파트너 유형

### 2.1 연동 유형별 권한

```yaml
integration_tiers:
  basic:
    name: "Basic"
    rate_limit: "1,000 requests/hour"
    data_access:
      - "vouchers:read"
      - "accounts:read"
      - "reports:read"
    webhooks: false
    support: "Community"
    price: "무료"

  standard:
    name: "Standard"
    rate_limit: "10,000 requests/hour"
    data_access:
      - "vouchers:read,write"
      - "accounts:read,write"
      - "tax_invoices:read,write"
      - "reports:read"
    webhooks: true
    webhook_limit: 10
    support: "Email"
    price: "월 50,000원"

  enterprise:
    name: "Enterprise"
    rate_limit: "100,000 requests/hour"
    data_access:
      - "all:read,write"
    webhooks: true
    webhook_limit: 100
    features:
      - "전용 지원 담당자"
      - "커스텀 연동 지원"
      - "SLA 보장"
    support: "24/7 전용"
    price: "협의"
```

### 2.2 파트너 등록 절차

```go
// internal/partner/registration.go
package partner

import (
    "context"
    "time"

    "github.com/google/uuid"
)

type PartnerStatus string

const (
    PartnerStatusPending  PartnerStatus = "pending"
    PartnerStatusApproved PartnerStatus = "approved"
    PartnerStatusActive   PartnerStatus = "active"
    PartnerStatusSuspended PartnerStatus = "suspended"
)

type Partner struct {
    ID              uuid.UUID
    CompanyName     string
    ContactEmail    string
    ContactPhone    string
    Website         string
    Description     string
    PartnerType     string // reseller, technology, consulting
    IntegrationTier string // basic, standard, enterprise
    Status          PartnerStatus
    APIKeyID        *uuid.UUID
    CreatedAt       time.Time
    ApprovedAt      *time.Time
    ApprovedBy      *uuid.UUID
}

type PartnerRegistrationService struct {
    repo         PartnerRepository
    apiKeyService *APIKeyService
    notifier     Notifier
    logger       *slog.Logger
}

// RegisterPartner registers a new partner
func (s *PartnerRegistrationService) RegisterPartner(ctx context.Context, req RegisterPartnerRequest) (*Partner, error) {
    // Validate request
    if err := s.validateRequest(req); err != nil {
        return nil, err
    }

    partner := &Partner{
        ID:              uuid.New(),
        CompanyName:     req.CompanyName,
        ContactEmail:    req.ContactEmail,
        ContactPhone:    req.ContactPhone,
        Website:         req.Website,
        Description:     req.Description,
        PartnerType:     req.PartnerType,
        IntegrationTier: "basic", // Start with basic
        Status:          PartnerStatusPending,
        CreatedAt:       time.Now(),
    }

    if err := s.repo.Save(ctx, partner); err != nil {
        return nil, fmt.Errorf("failed to save partner: %w", err)
    }

    // Notify admin for review
    s.notifier.NotifyAdmins(ctx, NotificationPartnerRegistration, partner)

    s.logger.Info("partner registered",
        slog.String("partner_id", partner.ID.String()),
        slog.String("company", partner.CompanyName),
    )

    return partner, nil
}

// ApprovePartner approves a pending partner
func (s *PartnerRegistrationService) ApprovePartner(ctx context.Context, partnerID uuid.UUID, approverID uuid.UUID) error {
    partner, err := s.repo.FindByID(ctx, partnerID)
    if err != nil {
        return err
    }

    if partner.Status != PartnerStatusPending {
        return fmt.Errorf("partner is not in pending status")
    }

    // Generate API credentials
    apiKey, err := s.apiKeyService.CreateAPIKey(ctx, CreateAPIKeyRequest{
        PartnerID:    partnerID,
        Name:         partner.CompanyName + " API Key",
        Tier:         partner.IntegrationTier,
        ExpiresAt:    time.Now().AddDate(1, 0, 0), // 1 year
    })
    if err != nil {
        return fmt.Errorf("failed to create API key: %w", err)
    }

    now := time.Now()
    partner.Status = PartnerStatusApproved
    partner.ApprovedAt = &now
    partner.ApprovedBy = &approverID
    partner.APIKeyID = &apiKey.ID

    if err := s.repo.Save(ctx, partner); err != nil {
        return err
    }

    // Notify partner
    s.notifier.NotifyPartner(ctx, partner.ContactEmail, NotificationPartnerApproved, map[string]interface{}{
        "api_key":    apiKey.Key,
        "api_secret": apiKey.Secret,
        "tier":       partner.IntegrationTier,
    })

    return nil
}

// UpgradeTier upgrades partner integration tier
func (s *PartnerRegistrationService) UpgradeTier(ctx context.Context, partnerID uuid.UUID, newTier string) error {
    partner, err := s.repo.FindByID(ctx, partnerID)
    if err != nil {
        return err
    }

    oldTier := partner.IntegrationTier
    partner.IntegrationTier = newTier

    // Update API key permissions
    if partner.APIKeyID != nil {
        if err := s.apiKeyService.UpdateTier(ctx, *partner.APIKeyID, newTier); err != nil {
            return err
        }
    }

    if err := s.repo.Save(ctx, partner); err != nil {
        return err
    }

    s.logger.Info("partner tier upgraded",
        slog.String("partner_id", partnerID.String()),
        slog.String("old_tier", oldTier),
        slog.String("new_tier", newTier),
    )

    return nil
}
```

---

## 3. 인증 및 보안

### 3.1 OAuth 2.0 인증

```go
// internal/partner/auth/oauth.go
package auth

import (
    "context"
    "crypto/rand"
    "encoding/base64"
    "time"

    "github.com/google/uuid"
)

type OAuthGrantType string

const (
    GrantTypeClientCredentials OAuthGrantType = "client_credentials"
    GrantTypeAuthorizationCode OAuthGrantType = "authorization_code"
    GrantTypeRefreshToken      OAuthGrantType = "refresh_token"
)

type OAuthToken struct {
    AccessToken  string    `json:"access_token"`
    TokenType    string    `json:"token_type"`
    ExpiresIn    int       `json:"expires_in"`
    RefreshToken string    `json:"refresh_token,omitempty"`
    Scope        string    `json:"scope"`
}

type OAuthService struct {
    clientRepo  OAuthClientRepository
    tokenRepo   TokenRepository
    jwtService  *JWTService
    logger      *slog.Logger
}

// Token endpoint handler
func (s *OAuthService) Token(ctx context.Context, req TokenRequest) (*OAuthToken, error) {
    switch OAuthGrantType(req.GrantType) {
    case GrantTypeClientCredentials:
        return s.handleClientCredentials(ctx, req)
    case GrantTypeAuthorizationCode:
        return s.handleAuthorizationCode(ctx, req)
    case GrantTypeRefreshToken:
        return s.handleRefreshToken(ctx, req)
    default:
        return nil, ErrUnsupportedGrantType
    }
}

func (s *OAuthService) handleClientCredentials(ctx context.Context, req TokenRequest) (*OAuthToken, error) {
    // Validate client credentials
    client, err := s.clientRepo.FindByClientID(ctx, req.ClientID)
    if err != nil {
        return nil, ErrInvalidClient
    }

    if !s.verifyClientSecret(client, req.ClientSecret) {
        s.logger.Warn("invalid client secret",
            slog.String("client_id", req.ClientID),
        )
        return nil, ErrInvalidClient
    }

    // Verify requested scopes
    scopes, err := s.validateScopes(client.AllowedScopes, req.Scope)
    if err != nil {
        return nil, ErrInvalidScope
    }

    // Generate tokens
    accessToken, err := s.jwtService.GenerateAccessToken(TokenClaims{
        ClientID:  client.ID,
        PartnerID: client.PartnerID,
        Scopes:    scopes,
        Tier:      client.Tier,
    })
    if err != nil {
        return nil, err
    }

    // Store token metadata
    tokenMeta := &TokenMetadata{
        ID:         uuid.New(),
        ClientID:   client.ID,
        Scopes:     scopes,
        IssuedAt:   time.Now(),
        ExpiresAt:  time.Now().Add(time.Hour),
    }
    if err := s.tokenRepo.Save(ctx, tokenMeta); err != nil {
        return nil, err
    }

    return &OAuthToken{
        AccessToken: accessToken,
        TokenType:   "Bearer",
        ExpiresIn:   3600,
        Scope:       strings.Join(scopes, " "),
    }, nil
}

func (s *OAuthService) validateScopes(allowed []string, requested string) ([]string, error) {
    allowedSet := make(map[string]bool)
    for _, scope := range allowed {
        allowedSet[scope] = true
    }

    requestedScopes := strings.Split(requested, " ")
    var validScopes []string

    for _, scope := range requestedScopes {
        if scope == "" {
            continue
        }
        if !allowedSet[scope] {
            return nil, fmt.Errorf("scope not allowed: %s", scope)
        }
        validScopes = append(validScopes, scope)
    }

    if len(validScopes) == 0 {
        // Return all allowed scopes if none requested
        return allowed, nil
    }

    return validScopes, nil
}

// Scope definitions
var PartnerScopes = map[string]ScopeDefinition{
    "vouchers:read": {
        Name:        "vouchers:read",
        Description: "전표 조회",
        Resources:   []string{"/api/v1/vouchers", "/api/v1/vouchers/*"},
        Methods:     []string{"GET"},
    },
    "vouchers:write": {
        Name:        "vouchers:write",
        Description: "전표 생성/수정",
        Resources:   []string{"/api/v1/vouchers", "/api/v1/vouchers/*"},
        Methods:     []string{"POST", "PUT", "DELETE"},
    },
    "accounts:read": {
        Name:        "accounts:read",
        Description: "계정과목 조회",
        Resources:   []string{"/api/v1/accounts", "/api/v1/accounts/*"},
        Methods:     []string{"GET"},
    },
    "tax_invoices:read": {
        Name:        "tax_invoices:read",
        Description: "세금계산서 조회",
        Resources:   []string{"/api/v1/tax-invoices", "/api/v1/tax-invoices/*"},
        Methods:     []string{"GET"},
    },
    "tax_invoices:write": {
        Name:        "tax_invoices:write",
        Description: "세금계산서 발행",
        Resources:   []string{"/api/v1/tax-invoices", "/api/v1/tax-invoices/*"},
        Methods:     []string{"POST"},
    },
    "reports:read": {
        Name:        "reports:read",
        Description: "리포트 조회",
        Resources:   []string{"/api/v1/reports/*"},
        Methods:     []string{"GET"},
    },
    "webhooks:manage": {
        Name:        "webhooks:manage",
        Description: "웹훅 관리",
        Resources:   []string{"/api/v1/webhooks", "/api/v1/webhooks/*"},
        Methods:     []string{"GET", "POST", "PUT", "DELETE"},
    },
}
```

### 3.2 API 키 관리

```go
// internal/partner/auth/apikey.go
package auth

import (
    "context"
    "crypto/rand"
    "crypto/sha256"
    "encoding/hex"
    "time"
)

type APIKey struct {
    ID          uuid.UUID
    PartnerID   uuid.UUID
    Name        string
    KeyPrefix   string // First 8 chars for identification
    KeyHash     string // SHA-256 hash of full key
    SecretHash  string // SHA-256 hash of secret
    Tier        string
    Scopes      []string
    RateLimit   int
    IsActive    bool
    ExpiresAt   time.Time
    LastUsedAt  *time.Time
    CreatedAt   time.Time
}

type APIKeyService struct {
    repo   APIKeyRepository
    logger *slog.Logger
}

// CreateAPIKey creates a new API key for a partner
func (s *APIKeyService) CreateAPIKey(ctx context.Context, req CreateAPIKeyRequest) (*APIKeyWithCredentials, error) {
    // Generate key and secret
    key := s.generateKey()
    secret := s.generateSecret()

    apiKey := &APIKey{
        ID:        uuid.New(),
        PartnerID: req.PartnerID,
        Name:      req.Name,
        KeyPrefix: key[:8],
        KeyHash:   s.hash(key),
        SecretHash: s.hash(secret),
        Tier:      req.Tier,
        Scopes:    s.getScopesForTier(req.Tier),
        RateLimit: s.getRateLimitForTier(req.Tier),
        IsActive:  true,
        ExpiresAt: req.ExpiresAt,
        CreatedAt: time.Now(),
    }

    if err := s.repo.Save(ctx, apiKey); err != nil {
        return nil, fmt.Errorf("failed to save API key: %w", err)
    }

    // Return credentials (only time they're visible)
    return &APIKeyWithCredentials{
        APIKey: apiKey,
        Key:    key,
        Secret: secret,
    }, nil
}

func (s *APIKeyService) generateKey() string {
    bytes := make([]byte, 24)
    rand.Read(bytes)
    return "kerp_" + hex.EncodeToString(bytes)
}

func (s *APIKeyService) generateSecret() string {
    bytes := make([]byte, 32)
    rand.Read(bytes)
    return hex.EncodeToString(bytes)
}

func (s *APIKeyService) hash(value string) string {
    h := sha256.Sum256([]byte(value))
    return hex.EncodeToString(h[:])
}

// ValidateAPIKey validates an API key and returns the associated partner info
func (s *APIKeyService) ValidateAPIKey(ctx context.Context, key, secret string) (*APIKey, error) {
    if len(key) < 8 {
        return nil, ErrInvalidAPIKey
    }

    prefix := key[:8]
    apiKey, err := s.repo.FindByPrefix(ctx, prefix)
    if err != nil {
        return nil, ErrInvalidAPIKey
    }

    // Verify key and secret
    if s.hash(key) != apiKey.KeyHash || s.hash(secret) != apiKey.SecretHash {
        return nil, ErrInvalidAPIKey
    }

    // Check if active
    if !apiKey.IsActive {
        return nil, ErrAPIKeyInactive
    }

    // Check expiration
    if time.Now().After(apiKey.ExpiresAt) {
        return nil, ErrAPIKeyExpired
    }

    // Update last used
    now := time.Now()
    apiKey.LastUsedAt = &now
    s.repo.Save(ctx, apiKey)

    return apiKey, nil
}

func (s *APIKeyService) getScopesForTier(tier string) []string {
    tierScopes := map[string][]string{
        "basic": {
            "vouchers:read",
            "accounts:read",
            "reports:read",
        },
        "standard": {
            "vouchers:read", "vouchers:write",
            "accounts:read", "accounts:write",
            "tax_invoices:read", "tax_invoices:write",
            "reports:read",
            "webhooks:manage",
        },
        "enterprise": {
            "vouchers:read", "vouchers:write",
            "accounts:read", "accounts:write",
            "tax_invoices:read", "tax_invoices:write",
            "payrolls:read", "payrolls:write",
            "reports:read",
            "webhooks:manage",
            "admin:read",
        },
    }
    return tierScopes[tier]
}

func (s *APIKeyService) getRateLimitForTier(tier string) int {
    tierLimits := map[string]int{
        "basic":      1000,   // per hour
        "standard":   10000,
        "enterprise": 100000,
    }
    return tierLimits[tier]
}
```

### 3.3 Rate Limiting

```go
// internal/partner/ratelimit/limiter.go
package ratelimit

import (
    "context"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
)

type RateLimiter struct {
    redis  *redis.Client
    logger *slog.Logger
}

type RateLimitResult struct {
    Allowed    bool
    Remaining  int
    ResetAt    time.Time
    RetryAfter time.Duration
}

// Check checks and increments the rate limit counter
func (r *RateLimiter) Check(ctx context.Context, partnerID string, limit int) (*RateLimitResult, error) {
    key := fmt.Sprintf("ratelimit:partner:%s", partnerID)
    now := time.Now()
    windowStart := now.Truncate(time.Hour)
    windowEnd := windowStart.Add(time.Hour)

    // Use Redis MULTI/EXEC for atomic operation
    pipe := r.redis.Pipeline()

    // Increment counter
    incr := pipe.Incr(ctx, key)

    // Set expiry if new key
    pipe.ExpireNX(ctx, key, time.Hour)

    // Get TTL
    ttl := pipe.TTL(ctx, key)

    _, err := pipe.Exec(ctx)
    if err != nil {
        return nil, fmt.Errorf("rate limit check failed: %w", err)
    }

    count := int(incr.Val())
    remaining := limit - count
    if remaining < 0 {
        remaining = 0
    }

    result := &RateLimitResult{
        Allowed:   count <= limit,
        Remaining: remaining,
        ResetAt:   windowEnd,
    }

    if !result.Allowed {
        result.RetryAfter = ttl.Val()
    }

    return result, nil
}

// RateLimitMiddleware is the HTTP middleware for rate limiting
func RateLimitMiddleware(limiter *RateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        // Get partner info from context (set by auth middleware)
        partnerID := c.GetString("partner_id")
        rateLimit := c.GetInt("rate_limit")

        if partnerID == "" || rateLimit == 0 {
            c.Next()
            return
        }

        result, err := limiter.Check(c.Request.Context(), partnerID, rateLimit)
        if err != nil {
            c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{
                "error": "rate limit check failed",
            })
            return
        }

        // Set rate limit headers
        c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", rateLimit))
        c.Header("X-RateLimit-Remaining", fmt.Sprintf("%d", result.Remaining))
        c.Header("X-RateLimit-Reset", fmt.Sprintf("%d", result.ResetAt.Unix()))

        if !result.Allowed {
            c.Header("Retry-After", fmt.Sprintf("%.0f", result.RetryAfter.Seconds()))
            c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
                "error":       "rate limit exceeded",
                "retry_after": result.RetryAfter.Seconds(),
            })
            return
        }

        c.Next()
    }
}
```

---

## 4. API 연동

### 4.1 Partner API 엔드포인트

```go
// internal/handler/partner/voucher_handler.go
package partner

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
)

type PartnerVoucherHandler struct {
    service *service.VoucherService
    logger  *slog.Logger
}

// List vouchers - GET /api/partner/v1/vouchers
func (h *PartnerVoucherHandler) List(c *gin.Context) {
    companyID := c.GetString("company_id")
    if companyID == "" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "company_id required"})
        return
    }

    var filter VoucherFilter
    if err := c.ShouldBindQuery(&filter); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    vouchers, total, err := h.service.ListVouchers(
        c.Request.Context(),
        uuid.MustParse(companyID),
        filter,
    )
    if err != nil {
        h.handleError(c, err)
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "data": h.toPartnerResponse(vouchers),
        "meta": gin.H{
            "total":       total,
            "page":        filter.Page,
            "limit":       filter.Limit,
            "total_pages": (total + filter.Limit - 1) / filter.Limit,
        },
    })
}

// Create voucher - POST /api/partner/v1/vouchers
func (h *PartnerVoucherHandler) Create(c *gin.Context) {
    companyID := c.GetString("company_id")

    var req CreateVoucherRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // Validate partner has write permission
    scopes := c.GetStringSlice("scopes")
    if !contains(scopes, "vouchers:write") {
        c.JSON(http.StatusForbidden, gin.H{"error": "insufficient permissions"})
        return
    }

    voucher, err := h.service.CreateVoucher(
        c.Request.Context(),
        uuid.MustParse(companyID),
        req,
    )
    if err != nil {
        h.handleError(c, err)
        return
    }

    // Log partner action
    h.logger.Info("partner created voucher",
        slog.String("partner_id", c.GetString("partner_id")),
        slog.String("voucher_id", voucher.ID.String()),
    )

    c.JSON(http.StatusCreated, gin.H{
        "data": h.toPartnerResponseSingle(voucher),
    })
}

// Partner-specific response format
type PartnerVoucherResponse struct {
    ID          string                 `json:"id"`
    VoucherNo   string                 `json:"voucher_no"`
    VoucherDate string                 `json:"voucher_date"`
    Description string                 `json:"description"`
    Status      string                 `json:"status"`
    TotalDebit  string                 `json:"total_debit"`
    TotalCredit string                 `json:"total_credit"`
    Lines       []PartnerLineResponse  `json:"lines"`
    CreatedAt   string                 `json:"created_at"`
    UpdatedAt   string                 `json:"updated_at"`
}

func (h *PartnerVoucherHandler) toPartnerResponse(vouchers []*domain.Voucher) []PartnerVoucherResponse {
    result := make([]PartnerVoucherResponse, len(vouchers))
    for i, v := range vouchers {
        result[i] = h.toPartnerResponseSingle(v)
    }
    return result
}
```

### 4.2 Partner API 라우터

```go
// internal/handler/partner/router.go
package partner

import (
    "github.com/gin-gonic/gin"
)

func SetupPartnerRoutes(
    r *gin.RouterGroup,
    authMiddleware gin.HandlerFunc,
    rateLimitMiddleware gin.HandlerFunc,
    voucherHandler *PartnerVoucherHandler,
    accountHandler *PartnerAccountHandler,
    taxInvoiceHandler *PartnerTaxInvoiceHandler,
    webhookHandler *WebhookHandler,
) {
    // Partner API v1
    v1 := r.Group("/partner/v1")
    v1.Use(authMiddleware)
    v1.Use(rateLimitMiddleware)
    v1.Use(PartnerAuditMiddleware())

    // Vouchers
    vouchers := v1.Group("/vouchers")
    {
        vouchers.GET("", RequireScope("vouchers:read"), voucherHandler.List)
        vouchers.GET("/:id", RequireScope("vouchers:read"), voucherHandler.Get)
        vouchers.POST("", RequireScope("vouchers:write"), voucherHandler.Create)
        vouchers.PUT("/:id", RequireScope("vouchers:write"), voucherHandler.Update)
        vouchers.DELETE("/:id", RequireScope("vouchers:write"), voucherHandler.Delete)
    }

    // Accounts
    accounts := v1.Group("/accounts")
    {
        accounts.GET("", RequireScope("accounts:read"), accountHandler.List)
        accounts.GET("/:code", RequireScope("accounts:read"), accountHandler.Get)
        accounts.GET("/:code/balance", RequireScope("accounts:read"), accountHandler.GetBalance)
    }

    // Tax Invoices
    taxInvoices := v1.Group("/tax-invoices")
    {
        taxInvoices.GET("", RequireScope("tax_invoices:read"), taxInvoiceHandler.List)
        taxInvoices.GET("/:id", RequireScope("tax_invoices:read"), taxInvoiceHandler.Get)
        taxInvoices.POST("", RequireScope("tax_invoices:write"), taxInvoiceHandler.Create)
    }

    // Webhooks
    webhooks := v1.Group("/webhooks")
    {
        webhooks.GET("", RequireScope("webhooks:manage"), webhookHandler.List)
        webhooks.POST("", RequireScope("webhooks:manage"), webhookHandler.Create)
        webhooks.PUT("/:id", RequireScope("webhooks:manage"), webhookHandler.Update)
        webhooks.DELETE("/:id", RequireScope("webhooks:manage"), webhookHandler.Delete)
        webhooks.POST("/:id/test", RequireScope("webhooks:manage"), webhookHandler.Test)
    }
}

// RequireScope middleware checks if partner has required scope
func RequireScope(scope string) gin.HandlerFunc {
    return func(c *gin.Context) {
        scopes := c.GetStringSlice("scopes")
        for _, s := range scopes {
            if s == scope {
                c.Next()
                return
            }
        }
        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
            "error": fmt.Sprintf("required scope: %s", scope),
        })
    }
}

// PartnerAuditMiddleware logs all partner API calls
func PartnerAuditMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()

        c.Next()

        // Log after request
        slog.Info("partner api call",
            slog.String("partner_id", c.GetString("partner_id")),
            slog.String("method", c.Request.Method),
            slog.String("path", c.Request.URL.Path),
            slog.Int("status", c.Writer.Status()),
            slog.Duration("latency", time.Since(start)),
        )
    }
}
```

### 4.3 OpenAPI 스펙

```yaml
# api/partner/openapi.yaml
openapi: 3.0.3
info:
  title: K-ERP Partner API
  description: API for K-ERP partner integrations
  version: 1.0.0
  contact:
    email: partner-support@kerp.io

servers:
  - url: https://api.kerp.io/partner/v1
    description: Production
  - url: https://sandbox.kerp.io/partner/v1
    description: Sandbox

security:
  - OAuth2: []
  - APIKey: []

paths:
  /vouchers:
    get:
      summary: List vouchers
      operationId: listVouchers
      tags:
        - Vouchers
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
            maximum: 100
        - name: status
          in: query
          schema:
            type: string
            enum: [draft, posted, cancelled]
        - name: from_date
          in: query
          schema:
            type: string
            format: date
        - name: to_date
          in: query
          schema:
            type: string
            format: date
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/VoucherListResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '429':
          $ref: '#/components/responses/RateLimited'

    post:
      summary: Create voucher
      operationId: createVoucher
      tags:
        - Vouchers
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateVoucherRequest'
      responses:
        '201':
          description: Voucher created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/VoucherResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'

components:
  securitySchemes:
    OAuth2:
      type: oauth2
      flows:
        clientCredentials:
          tokenUrl: https://api.kerp.io/oauth/token
          scopes:
            vouchers:read: Read vouchers
            vouchers:write: Create/update vouchers
            accounts:read: Read accounts
            tax_invoices:read: Read tax invoices
            tax_invoices:write: Issue tax invoices

    APIKey:
      type: apiKey
      in: header
      name: X-API-Key

  schemas:
    VoucherListResponse:
      type: object
      properties:
        data:
          type: array
          items:
            $ref: '#/components/schemas/Voucher'
        meta:
          $ref: '#/components/schemas/PaginationMeta'

    Voucher:
      type: object
      properties:
        id:
          type: string
          format: uuid
        voucher_no:
          type: string
        voucher_date:
          type: string
          format: date
        description:
          type: string
        status:
          type: string
          enum: [draft, posted, cancelled]
        total_debit:
          type: string
        total_credit:
          type: string
        lines:
          type: array
          items:
            $ref: '#/components/schemas/VoucherLine'

    CreateVoucherRequest:
      type: object
      required:
        - voucher_date
        - lines
      properties:
        voucher_date:
          type: string
          format: date
        description:
          type: string
          maxLength: 500
        lines:
          type: array
          minItems: 1
          items:
            $ref: '#/components/schemas/VoucherLineInput'

  responses:
    Unauthorized:
      description: Authentication required
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'

    RateLimited:
      description: Rate limit exceeded
      headers:
        X-RateLimit-Limit:
          schema:
            type: integer
        X-RateLimit-Remaining:
          schema:
            type: integer
        Retry-After:
          schema:
            type: integer
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
```

---

## 5. 웹훅 연동

### 5.1 웹훅 이벤트 정의

```go
// internal/partner/webhook/events.go
package webhook

type EventType string

const (
    // Voucher events
    EventVoucherCreated   EventType = "voucher.created"
    EventVoucherUpdated   EventType = "voucher.updated"
    EventVoucherPosted    EventType = "voucher.posted"
    EventVoucherCancelled EventType = "voucher.cancelled"

    // Tax invoice events
    EventTaxInvoiceIssued    EventType = "tax_invoice.issued"
    EventTaxInvoiceCancelled EventType = "tax_invoice.cancelled"
    EventTaxInvoiceReceived  EventType = "tax_invoice.received"

    // Account events
    EventAccountCreated EventType = "account.created"
    EventAccountUpdated EventType = "account.updated"

    // Payment events
    EventPaymentReceived EventType = "payment.received"
    EventPaymentSent     EventType = "payment.sent"
)

type WebhookPayload struct {
    ID          string                 `json:"id"`
    Event       EventType              `json:"event"`
    CreatedAt   string                 `json:"created_at"`
    CompanyID   string                 `json:"company_id"`
    Data        map[string]interface{} `json:"data"`
    APIVersion  string                 `json:"api_version"`
}

// Event definitions with payload schemas
var EventDefinitions = map[EventType]EventDefinition{
    EventVoucherCreated: {
        Name:        "voucher.created",
        Description: "전표가 생성되었을 때 발생",
        PayloadSchema: map[string]interface{}{
            "voucher": "Voucher object",
        },
    },
    EventVoucherPosted: {
        Name:        "voucher.posted",
        Description: "전표가 기장되었을 때 발생",
        PayloadSchema: map[string]interface{}{
            "voucher":   "Voucher object",
            "posted_by": "User ID who posted",
            "posted_at": "Timestamp",
        },
    },
    EventTaxInvoiceIssued: {
        Name:        "tax_invoice.issued",
        Description: "세금계산서가 발행되었을 때 발생",
        PayloadSchema: map[string]interface{}{
            "tax_invoice":     "TaxInvoice object",
            "nts_approval_no": "국세청 승인번호",
        },
    },
}
```

### 5.2 웹훅 서비스

```go
// internal/partner/webhook/service.go
package webhook

import (
    "bytes"
    "context"
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "encoding/json"
    "net/http"
    "time"

    "github.com/google/uuid"
)

type Webhook struct {
    ID          uuid.UUID
    PartnerID   uuid.UUID
    URL         string
    Secret      string
    Events      []EventType
    IsActive    bool
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

type WebhookDelivery struct {
    ID          uuid.UUID
    WebhookID   uuid.UUID
    Event       EventType
    Payload     string
    StatusCode  int
    Response    string
    Duration    time.Duration
    Attempts    int
    DeliveredAt *time.Time
    CreatedAt   time.Time
}

type WebhookService struct {
    repo         WebhookRepository
    deliveryRepo WebhookDeliveryRepository
    httpClient   *http.Client
    queue        MessageQueue
    logger       *slog.Logger
}

// CreateWebhook creates a new webhook subscription
func (s *WebhookService) CreateWebhook(ctx context.Context, req CreateWebhookRequest) (*Webhook, error) {
    // Validate URL
    if err := s.validateURL(req.URL); err != nil {
        return nil, err
    }

    // Generate secret for signature
    secret := s.generateSecret()

    webhook := &Webhook{
        ID:        uuid.New(),
        PartnerID: req.PartnerID,
        URL:       req.URL,
        Secret:    secret,
        Events:    req.Events,
        IsActive:  true,
        CreatedAt: time.Now(),
    }

    if err := s.repo.Save(ctx, webhook); err != nil {
        return nil, err
    }

    return webhook, nil
}

// Dispatch sends webhook to all subscribers
func (s *WebhookService) Dispatch(ctx context.Context, event EventType, companyID uuid.UUID, data map[string]interface{}) error {
    // Find all webhooks subscribed to this event for this company's partners
    webhooks, err := s.repo.FindByEventAndCompany(ctx, event, companyID)
    if err != nil {
        return err
    }

    payload := WebhookPayload{
        ID:         uuid.New().String(),
        Event:      event,
        CreatedAt:  time.Now().Format(time.RFC3339),
        CompanyID:  companyID.String(),
        Data:       data,
        APIVersion: "2024-01-01",
    }

    // Queue delivery for each webhook
    for _, webhook := range webhooks {
        s.queue.Publish("webhook.deliver", DeliveryJob{
            WebhookID: webhook.ID,
            Payload:   payload,
        })
    }

    return nil
}

// DeliverWebhook delivers a webhook with retry logic
func (s *WebhookService) DeliverWebhook(ctx context.Context, webhookID uuid.UUID, payload WebhookPayload) error {
    webhook, err := s.repo.FindByID(ctx, webhookID)
    if err != nil {
        return err
    }

    if !webhook.IsActive {
        return nil
    }

    delivery := &WebhookDelivery{
        ID:        uuid.New(),
        WebhookID: webhookID,
        Event:     payload.Event,
        CreatedAt: time.Now(),
    }

    // Serialize payload
    payloadBytes, err := json.Marshal(payload)
    if err != nil {
        return err
    }
    delivery.Payload = string(payloadBytes)

    // Generate signature
    signature := s.generateSignature(payloadBytes, webhook.Secret)

    // Create request
    req, err := http.NewRequestWithContext(ctx, "POST", webhook.URL, bytes.NewReader(payloadBytes))
    if err != nil {
        return err
    }

    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("X-KERP-Signature", signature)
    req.Header.Set("X-KERP-Event", string(payload.Event))
    req.Header.Set("X-KERP-Delivery-ID", delivery.ID.String())

    // Send with retry
    maxAttempts := 3
    for attempt := 1; attempt <= maxAttempts; attempt++ {
        delivery.Attempts = attempt

        start := time.Now()
        resp, err := s.httpClient.Do(req)
        delivery.Duration = time.Since(start)

        if err != nil {
            s.logger.Warn("webhook delivery failed",
                slog.String("webhook_id", webhookID.String()),
                slog.Int("attempt", attempt),
                slog.Any("error", err),
            )

            if attempt < maxAttempts {
                time.Sleep(time.Duration(attempt*attempt) * time.Second) // Exponential backoff
                continue
            }
            break
        }

        delivery.StatusCode = resp.StatusCode

        // Read response body
        respBody := make([]byte, 1024)
        n, _ := resp.Body.Read(respBody)
        resp.Body.Close()
        delivery.Response = string(respBody[:n])

        if resp.StatusCode >= 200 && resp.StatusCode < 300 {
            now := time.Now()
            delivery.DeliveredAt = &now
            break
        }

        if attempt < maxAttempts {
            time.Sleep(time.Duration(attempt*attempt) * time.Second)
        }
    }

    // Save delivery record
    s.deliveryRepo.Save(ctx, delivery)

    // Log result
    if delivery.DeliveredAt != nil {
        s.logger.Info("webhook delivered",
            slog.String("webhook_id", webhookID.String()),
            slog.String("event", string(payload.Event)),
            slog.Duration("duration", delivery.Duration),
        )
    } else {
        s.logger.Error("webhook delivery failed",
            slog.String("webhook_id", webhookID.String()),
            slog.String("event", string(payload.Event)),
            slog.Int("attempts", delivery.Attempts),
        )
    }

    return nil
}

func (s *WebhookService) generateSignature(payload []byte, secret string) string {
    mac := hmac.New(sha256.New, []byte(secret))
    mac.Write(payload)
    return "sha256=" + hex.EncodeToString(mac.Sum(nil))
}

func (s *WebhookService) generateSecret() string {
    bytes := make([]byte, 32)
    rand.Read(bytes)
    return hex.EncodeToString(bytes)
}
```

### 5.3 웹훅 수신 예제 (파트너측)

```python
# Example: Partner webhook receiver (Python/Flask)

from flask import Flask, request, abort
import hmac
import hashlib
import json

app = Flask(__name__)

WEBHOOK_SECRET = "your_webhook_secret_here"

def verify_signature(payload: bytes, signature: str) -> bool:
    """Verify webhook signature."""
    expected = "sha256=" + hmac.new(
        WEBHOOK_SECRET.encode(),
        payload,
        hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(expected, signature)

@app.route("/webhooks/kerp", methods=["POST"])
def receive_webhook():
    # Get signature from header
    signature = request.headers.get("X-KERP-Signature")
    if not signature:
        abort(401, "Missing signature")

    # Verify signature
    if not verify_signature(request.data, signature):
        abort(401, "Invalid signature")

    # Parse payload
    payload = json.loads(request.data)

    event = payload["event"]
    data = payload["data"]

    # Handle different events
    handlers = {
        "voucher.created": handle_voucher_created,
        "voucher.posted": handle_voucher_posted,
        "tax_invoice.issued": handle_tax_invoice_issued,
    }

    handler = handlers.get(event)
    if handler:
        try:
            handler(data)
        except Exception as e:
            app.logger.error(f"Webhook handler error: {e}")
            # Return 200 to prevent retries for application errors
            # Log the error for investigation

    return {"status": "ok"}, 200

def handle_voucher_created(data):
    """Handle voucher.created event."""
    voucher = data["voucher"]
    print(f"New voucher created: {voucher['voucher_no']}")
    # Sync to your system...

def handle_voucher_posted(data):
    """Handle voucher.posted event."""
    voucher = data["voucher"]
    print(f"Voucher posted: {voucher['voucher_no']}")
    # Update your records...

def handle_tax_invoice_issued(data):
    """Handle tax_invoice.issued event."""
    invoice = data["tax_invoice"]
    nts_no = data.get("nts_approval_no")
    print(f"Tax invoice issued: {invoice['invoice_no']}, NTS: {nts_no}")
    # Record in your system...

if __name__ == "__main__":
    app.run(port=5000)
```

---

## 6. SDK 제공

### 6.1 Go SDK

```go
// sdk/go/kerp/client.go
package kerp

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "net/url"
    "time"
)

// Client is the K-ERP API client
type Client struct {
    baseURL    string
    apiKey     string
    apiSecret  string
    httpClient *http.Client

    // Service clients
    Vouchers    *VoucherService
    Accounts    *AccountService
    TaxInvoices *TaxInvoiceService
    Webhooks    *WebhookService
}

// ClientOption configures the client
type ClientOption func(*Client)

// WithBaseURL sets custom base URL
func WithBaseURL(url string) ClientOption {
    return func(c *Client) {
        c.baseURL = url
    }
}

// WithHTTPClient sets custom HTTP client
func WithHTTPClient(client *http.Client) ClientOption {
    return func(c *Client) {
        c.httpClient = client
    }
}

// NewClient creates a new K-ERP API client
func NewClient(apiKey, apiSecret string, opts ...ClientOption) *Client {
    c := &Client{
        baseURL:   "https://api.kerp.io/partner/v1",
        apiKey:    apiKey,
        apiSecret: apiSecret,
        httpClient: &http.Client{
            Timeout: 30 * time.Second,
        },
    }

    for _, opt := range opts {
        opt(c)
    }

    // Initialize service clients
    c.Vouchers = &VoucherService{client: c}
    c.Accounts = &AccountService{client: c}
    c.TaxInvoices = &TaxInvoiceService{client: c}
    c.Webhooks = &WebhookService{client: c}

    return c
}

// VoucherService handles voucher operations
type VoucherService struct {
    client *Client
}

// List lists vouchers
func (s *VoucherService) List(ctx context.Context, opts *ListOptions) (*VoucherList, error) {
    path := "/vouchers"
    if opts != nil {
        path += "?" + opts.Encode()
    }

    var result VoucherList
    if err := s.client.get(ctx, path, &result); err != nil {
        return nil, err
    }
    return &result, nil
}

// Get retrieves a voucher by ID
func (s *VoucherService) Get(ctx context.Context, id string) (*Voucher, error) {
    var result struct {
        Data Voucher `json:"data"`
    }
    if err := s.client.get(ctx, "/vouchers/"+id, &result); err != nil {
        return nil, err
    }
    return &result.Data, nil
}

// Create creates a new voucher
func (s *VoucherService) Create(ctx context.Context, req *CreateVoucherRequest) (*Voucher, error) {
    var result struct {
        Data Voucher `json:"data"`
    }
    if err := s.client.post(ctx, "/vouchers", req, &result); err != nil {
        return nil, err
    }
    return &result.Data, nil
}

// Internal HTTP methods
func (c *Client) get(ctx context.Context, path string, result interface{}) error {
    req, err := http.NewRequestWithContext(ctx, "GET", c.baseURL+path, nil)
    if err != nil {
        return err
    }
    return c.do(req, result)
}

func (c *Client) post(ctx context.Context, path string, body, result interface{}) error {
    bodyBytes, err := json.Marshal(body)
    if err != nil {
        return err
    }

    req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+path, bytes.NewReader(bodyBytes))
    if err != nil {
        return err
    }
    req.Header.Set("Content-Type", "application/json")

    return c.do(req, result)
}

func (c *Client) do(req *http.Request, result interface{}) error {
    // Add authentication
    req.Header.Set("X-API-Key", c.apiKey)
    req.Header.Set("X-API-Secret", c.apiSecret)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode >= 400 {
        var apiErr APIError
        json.NewDecoder(resp.Body).Decode(&apiErr)
        return &apiErr
    }

    return json.NewDecoder(resp.Body).Decode(result)
}

// Usage example
/*
func main() {
    client := kerp.NewClient("your_api_key", "your_api_secret")

    // List vouchers
    vouchers, err := client.Vouchers.List(context.Background(), &kerp.ListOptions{
        Page:  1,
        Limit: 20,
    })
    if err != nil {
        log.Fatal(err)
    }

    for _, v := range vouchers.Data {
        fmt.Printf("Voucher: %s - %s\n", v.VoucherNo, v.Description)
    }

    // Create voucher
    newVoucher, err := client.Vouchers.Create(context.Background(), &kerp.CreateVoucherRequest{
        VoucherDate: "2024-01-15",
        Description: "Test voucher",
        Lines: []kerp.VoucherLineInput{
            {AccountCode: "110101", DebitAmt: "1000"},
            {AccountCode: "401001", CreditAmt: "1000"},
        },
    })
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Created: %s\n", newVoucher.ID)
}
*/
```

### 6.2 Python SDK

```python
# sdk/python/kerp/client.py

from dataclasses import dataclass
from typing import List, Optional, Dict, Any
import requests
from datetime import date

@dataclass
class Voucher:
    id: str
    voucher_no: str
    voucher_date: str
    description: str
    status: str
    total_debit: str
    total_credit: str
    lines: List[Dict[str, Any]]

@dataclass
class VoucherLine:
    account_code: str
    debit_amt: str = "0"
    credit_amt: str = "0"
    description: str = ""

class KERPClient:
    """K-ERP Partner API Client"""

    def __init__(
        self,
        api_key: str,
        api_secret: str,
        base_url: str = "https://api.kerp.io/partner/v1"
    ):
        self.api_key = api_key
        self.api_secret = api_secret
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            "X-API-Key": api_key,
            "X-API-Secret": api_secret,
            "Content-Type": "application/json",
        })

        # Service clients
        self.vouchers = VoucherService(self)
        self.accounts = AccountService(self)
        self.tax_invoices = TaxInvoiceService(self)

    def _get(self, path: str, params: Optional[Dict] = None) -> Dict:
        response = self.session.get(f"{self.base_url}{path}", params=params)
        response.raise_for_status()
        return response.json()

    def _post(self, path: str, data: Dict) -> Dict:
        response = self.session.post(f"{self.base_url}{path}", json=data)
        response.raise_for_status()
        return response.json()

    def _put(self, path: str, data: Dict) -> Dict:
        response = self.session.put(f"{self.base_url}{path}", json=data)
        response.raise_for_status()
        return response.json()

    def _delete(self, path: str) -> None:
        response = self.session.delete(f"{self.base_url}{path}")
        response.raise_for_status()


class VoucherService:
    """Voucher API operations"""

    def __init__(self, client: KERPClient):
        self._client = client

    def list(
        self,
        page: int = 1,
        limit: int = 20,
        status: Optional[str] = None,
        from_date: Optional[date] = None,
        to_date: Optional[date] = None,
    ) -> Dict:
        """List vouchers with optional filters."""
        params = {"page": page, "limit": limit}
        if status:
            params["status"] = status
        if from_date:
            params["from_date"] = from_date.isoformat()
        if to_date:
            params["to_date"] = to_date.isoformat()

        return self._client._get("/vouchers", params)

    def get(self, voucher_id: str) -> Voucher:
        """Get a voucher by ID."""
        result = self._client._get(f"/vouchers/{voucher_id}")
        return self._to_voucher(result["data"])

    def create(
        self,
        voucher_date: date,
        lines: List[VoucherLine],
        description: str = "",
    ) -> Voucher:
        """Create a new voucher."""
        data = {
            "voucher_date": voucher_date.isoformat(),
            "description": description,
            "lines": [
                {
                    "account_code": line.account_code,
                    "debit_amt": line.debit_amt,
                    "credit_amt": line.credit_amt,
                    "description": line.description,
                }
                for line in lines
            ],
        }
        result = self._client._post("/vouchers", data)
        return self._to_voucher(result["data"])

    def _to_voucher(self, data: Dict) -> Voucher:
        return Voucher(
            id=data["id"],
            voucher_no=data["voucher_no"],
            voucher_date=data["voucher_date"],
            description=data.get("description", ""),
            status=data["status"],
            total_debit=data["total_debit"],
            total_credit=data["total_credit"],
            lines=data.get("lines", []),
        )


# Usage example
"""
from kerp import KERPClient, VoucherLine
from datetime import date

client = KERPClient("your_api_key", "your_api_secret")

# List vouchers
result = client.vouchers.list(page=1, limit=20, status="posted")
for voucher in result["data"]:
    print(f"{voucher['voucher_no']}: {voucher['description']}")

# Create voucher
new_voucher = client.vouchers.create(
    voucher_date=date.today(),
    description="Test voucher from Python SDK",
    lines=[
        VoucherLine(account_code="110101", debit_amt="1000"),
        VoucherLine(account_code="401001", credit_amt="1000"),
    ],
)
print(f"Created voucher: {new_voucher.id}")
"""
```

---

## 7. 테스트 환경

### 7.1 Sandbox 환경

```yaml
sandbox_environment:
  url: "https://sandbox.kerp.io"
  description: "파트너 개발/테스트용 격리 환경"

  features:
    - "프로덕션과 동일한 API"
    - "테스트 데이터 자동 생성"
    - "Rate limit 완화"
    - "실시간 로그 조회"

  test_credentials:
    api_key: "sandbox_test_key_xxxxx"
    api_secret: "sandbox_test_secret_xxxxx"

  test_data:
    companies:
      - id: "test-company-001"
        name: "테스트 회사 1"
        brn: "123-45-67890"
    accounts:
      - code: "110101"
        name: "보통예금"
      - code: "401001"
        name: "상품매출"
    vouchers:
      - "샘플 전표 100건 자동 생성"

  limitations:
    - "외부 시스템 연동 모킹 (국세청, 은행)"
    - "이메일/SMS 실제 발송 안함"
    - "데이터 주기적 리셋 (매주 일요일)"
```

### 7.2 테스트 도구

```go
// sdk/go/kerp/testing/mock.go
package testing

import (
    "context"
    "net/http"
    "net/http/httptest"
    "encoding/json"
)

// MockServer creates a mock K-ERP server for testing
type MockServer struct {
    server   *httptest.Server
    handlers map[string]http.HandlerFunc
}

func NewMockServer() *MockServer {
    m := &MockServer{
        handlers: make(map[string]http.HandlerFunc),
    }

    m.server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        key := r.Method + " " + r.URL.Path
        if handler, ok := m.handlers[key]; ok {
            handler(w, r)
            return
        }
        http.NotFound(w, r)
    }))

    return m
}

func (m *MockServer) URL() string {
    return m.server.URL
}

func (m *MockServer) Close() {
    m.server.Close()
}

// Mock voucher list endpoint
func (m *MockServer) MockVoucherList(vouchers []map[string]interface{}) {
    m.handlers["GET /partner/v1/vouchers"] = func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
            "data": vouchers,
            "meta": map[string]interface{}{
                "total":       len(vouchers),
                "page":        1,
                "limit":       20,
                "total_pages": 1,
            },
        })
    }
}

// Mock voucher create endpoint
func (m *MockServer) MockVoucherCreate(response map[string]interface{}) {
    m.handlers["POST /partner/v1/vouchers"] = func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(map[string]interface{}{
            "data": response,
        })
    }
}

// Usage in tests
/*
func TestVoucherList(t *testing.T) {
    mock := testing.NewMockServer()
    defer mock.Close()

    mock.MockVoucherList([]map[string]interface{}{
        {
            "id":           "test-id-1",
            "voucher_no":   "V-2024-00001",
            "voucher_date": "2024-01-15",
            "status":       "posted",
        },
    })

    client := kerp.NewClient("key", "secret", kerp.WithBaseURL(mock.URL()+"/partner/v1"))

    result, err := client.Vouchers.List(context.Background(), nil)
    assert.NoError(t, err)
    assert.Len(t, result.Data, 1)
    assert.Equal(t, "V-2024-00001", result.Data[0].VoucherNo)
}
*/
```

---

## 8. 운영 가이드

### 8.1 모니터링 대시보드

```typescript
// web/src/app/partner/dashboard/page.tsx
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

interface PartnerStats {
  apiCalls: number;
  successRate: number;
  avgLatency: number;
  webhooksDelivered: number;
}

interface UsageData {
  date: string;
  calls: number;
  errors: number;
}

export default function PartnerDashboard() {
  const stats: PartnerStats = {
    apiCalls: 15420,
    successRate: 99.2,
    avgLatency: 125,
    webhooksDelivered: 342,
  };

  const usageData: UsageData[] = [
    { date: '01/08', calls: 1200, errors: 12 },
    { date: '01/09', calls: 1450, errors: 8 },
    { date: '01/10', calls: 1380, errors: 15 },
    { date: '01/11', calls: 1520, errors: 5 },
    { date: '01/12', calls: 1680, errors: 10 },
    { date: '01/13', calls: 1420, errors: 7 },
    { date: '01/14', calls: 1770, errors: 3 },
  ];

  return (
    <div className="container mx-auto py-8 space-y-8">
      <h1 className="text-3xl font-bold">Partner API Dashboard</h1>

      {/* Stats Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm text-muted-foreground">
              API Calls (Today)
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {stats.apiCalls.toLocaleString()}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm text-muted-foreground">
              Success Rate
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-green-600">
              {stats.successRate}%
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm text-muted-foreground">
              Avg Latency
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.avgLatency}ms</div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm text-muted-foreground">
              Webhooks Delivered
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.webhooksDelivered}</div>
          </CardContent>
        </Card>
      </div>

      {/* Usage Chart */}
      <Card>
        <CardHeader>
          <CardTitle>API Usage (Last 7 Days)</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-80">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={usageData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Line
                  type="monotone"
                  dataKey="calls"
                  stroke="#3b82f6"
                  name="API Calls"
                />
                <Line
                  type="monotone"
                  dataKey="errors"
                  stroke="#ef4444"
                  name="Errors"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### 8.2 트러블슈팅 가이드

```yaml
troubleshooting:
  authentication_errors:
    401_unauthorized:
      causes:
        - "API 키/시크릿 불일치"
        - "만료된 API 키"
        - "비활성화된 파트너 계정"
      solutions:
        - "API 키 확인"
        - "파트너 포털에서 키 갱신"
        - "파트너 지원팀 연락"

    403_forbidden:
      causes:
        - "필요한 scope 없음"
        - "리소스 접근 권한 없음"
      solutions:
        - "OAuth scope 확인"
        - "필요한 권한 요청"

  rate_limiting:
    429_too_many_requests:
      causes:
        - "Rate limit 초과"
      solutions:
        - "Retry-After 헤더 확인"
        - "요청 간격 조절"
        - "tier 업그레이드 고려"

  webhook_issues:
    delivery_failures:
      causes:
        - "엔드포인트 불가"
        - "타임아웃"
        - "시그니처 검증 실패"
      solutions:
        - "엔드포인트 상태 확인"
        - "응답 시간 최적화"
        - "시그니처 검증 로직 확인"

  data_issues:
    validation_errors:
      causes:
        - "필수 필드 누락"
        - "잘못된 형식"
        - "비즈니스 규칙 위반"
      solutions:
        - "API 문서 확인"
        - "요청 데이터 검증"
        - "에러 응답 상세 확인"

support:
  channels:
    - type: "Developer Portal"
      url: "https://developers.kerp.io"
      description: "API 문서, SDK, 샘플 코드"

    - type: "Email Support"
      contact: "partner-support@kerp.io"
      response_time: "영업일 기준 24시간 내"

    - type: "Slack Community"
      url: "https://kerp-partners.slack.com"
      description: "개발자 커뮤니티"
```

---

## 버전 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 0.2 | 2024-01-15 | Partner Team | Go+Python 하이브리드 아키텍처 반영 |
| 0.1 | 2024-01-01 | Partner Team | 초안 작성 |
