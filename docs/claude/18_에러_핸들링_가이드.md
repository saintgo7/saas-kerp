# 18. 에러 핸들링 가이드

## 개요

K-ERP 시스템의 일관된 에러 처리를 위한 가이드.
RFC 7807 Problem Details 기반의 표준화된 에러 응답 체계.

### 에러 처리 원칙

| 원칙 | 설명 |
|------|------|
| 일관성 | 모든 에러는 동일한 형식으로 반환 |
| 추적성 | 에러 ID로 로그 추적 가능 |
| 사용자 친화적 | 클라이언트용 메시지와 내부 메시지 분리 |
| 보안 | 민감한 정보 노출 방지 |

---

## 1. 에러 응답 형식

### 1.1 RFC 7807 Problem Details

```json
{
  "type": "https://api.kerp.example.com/errors/validation-error",
  "title": "Validation Error",
  "status": 400,
  "detail": "입력값이 유효하지 않습니다.",
  "instance": "/api/v1/vouchers",
  "error_id": "err_550e8400-e29b-41d4-a716-446655440000",
  "timestamp": "2024-01-15T09:30:00Z",
  "errors": [
    {
      "field": "voucher_date",
      "code": "required",
      "message": "전표일자는 필수입니다."
    },
    {
      "field": "lines",
      "code": "min_length",
      "message": "최소 1개 이상의 전표 라인이 필요합니다."
    }
  ]
}
```

### 1.2 Go 에러 구조체

```go
// internal/apperror/error.go
package apperror

import (
    "fmt"
    "net/http"
    "time"

    "github.com/google/uuid"
)

// ErrorType 에러 유형 URL
type ErrorType string

const (
    TypeValidation     ErrorType = "https://api.kerp.example.com/errors/validation-error"
    TypeAuthentication ErrorType = "https://api.kerp.example.com/errors/authentication-error"
    TypeAuthorization  ErrorType = "https://api.kerp.example.com/errors/authorization-error"
    TypeNotFound       ErrorType = "https://api.kerp.example.com/errors/not-found"
    TypeConflict       ErrorType = "https://api.kerp.example.com/errors/conflict"
    TypeBusinessRule   ErrorType = "https://api.kerp.example.com/errors/business-rule-violation"
    TypeInternal       ErrorType = "https://api.kerp.example.com/errors/internal-error"
    TypeRateLimit      ErrorType = "https://api.kerp.example.com/errors/rate-limit-exceeded"
    TypeServiceUnavail ErrorType = "https://api.kerp.example.com/errors/service-unavailable"
)

// ProblemDetail RFC 7807 Problem Details
type ProblemDetail struct {
    Type       ErrorType      `json:"type"`
    Title      string         `json:"title"`
    Status     int            `json:"status"`
    Detail     string         `json:"detail"`
    Instance   string         `json:"instance,omitempty"`
    ErrorID    string         `json:"error_id"`
    Timestamp  time.Time      `json:"timestamp"`
    Errors     []FieldError   `json:"errors,omitempty"`
    RetryAfter int            `json:"retry_after,omitempty"` // Rate limit용
}

// FieldError 필드별 에러
type FieldError struct {
    Field   string `json:"field"`
    Code    string `json:"code"`
    Message string `json:"message"`
}

// AppError 애플리케이션 에러
type AppError struct {
    Type       ErrorType
    Title      string
    StatusCode int
    Detail     string
    Cause      error        // 원인 에러 (로깅용)
    Fields     []FieldError // 필드 에러
    Instance   string       // 요청 경로
}

func (e *AppError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("%s: %s (cause: %v)", e.Title, e.Detail, e.Cause)
    }
    return fmt.Sprintf("%s: %s", e.Title, e.Detail)
}

func (e *AppError) Unwrap() error {
    return e.Cause
}

// ToProblemDetail ProblemDetail로 변환
func (e *AppError) ToProblemDetail() *ProblemDetail {
    return &ProblemDetail{
        Type:      e.Type,
        Title:     e.Title,
        Status:    e.StatusCode,
        Detail:    e.Detail,
        Instance:  e.Instance,
        ErrorID:   fmt.Sprintf("err_%s", uuid.New().String()),
        Timestamp: time.Now().UTC(),
        Errors:    e.Fields,
    }
}
```

### 1.3 에러 생성자

```go
// internal/apperror/errors.go
package apperror

import "net/http"

// Validation 에러
func NewValidationError(detail string, fields []FieldError) *AppError {
    return &AppError{
        Type:       TypeValidation,
        Title:      "Validation Error",
        StatusCode: http.StatusBadRequest,
        Detail:     detail,
        Fields:     fields,
    }
}

func ValidationField(field, code, message string) FieldError {
    return FieldError{Field: field, Code: code, Message: message}
}

// 인증 에러
func NewAuthenticationError(detail string) *AppError {
    return &AppError{
        Type:       TypeAuthentication,
        Title:      "Authentication Error",
        StatusCode: http.StatusUnauthorized,
        Detail:     detail,
    }
}

// 인가 에러
func NewAuthorizationError(detail string) *AppError {
    return &AppError{
        Type:       TypeAuthorization,
        Title:      "Authorization Error",
        StatusCode: http.StatusForbidden,
        Detail:     detail,
    }
}

// Not Found 에러
func NewNotFoundError(resource string) *AppError {
    return &AppError{
        Type:       TypeNotFound,
        Title:      "Not Found",
        StatusCode: http.StatusNotFound,
        Detail:     fmt.Sprintf("%s을(를) 찾을 수 없습니다.", resource),
    }
}

// Conflict 에러 (중복 등)
func NewConflictError(detail string) *AppError {
    return &AppError{
        Type:       TypeConflict,
        Title:      "Conflict",
        StatusCode: http.StatusConflict,
        Detail:     detail,
    }
}

// 비즈니스 로직 에러
func NewBusinessRuleError(detail string) *AppError {
    return &AppError{
        Type:       TypeBusinessRule,
        Title:      "Business Rule Violation",
        StatusCode: http.StatusUnprocessableEntity,
        Detail:     detail,
    }
}

// 내부 서버 에러
func NewInternalError(cause error) *AppError {
    return &AppError{
        Type:       TypeInternal,
        Title:      "Internal Server Error",
        StatusCode: http.StatusInternalServerError,
        Detail:     "서버 내부 오류가 발생했습니다. 잠시 후 다시 시도해주세요.",
        Cause:      cause,
    }
}

// Rate Limit 에러
func NewRateLimitError(retryAfter int) *AppError {
    return &AppError{
        Type:       TypeRateLimit,
        Title:      "Rate Limit Exceeded",
        StatusCode: http.StatusTooManyRequests,
        Detail:     "요청 제한을 초과했습니다. 잠시 후 다시 시도해주세요.",
    }
}

// 외부 서비스 에러
func NewServiceUnavailableError(service string, cause error) *AppError {
    return &AppError{
        Type:       TypeServiceUnavail,
        Title:      "Service Unavailable",
        StatusCode: http.StatusServiceUnavailable,
        Detail:     fmt.Sprintf("%s 서비스에 연결할 수 없습니다.", service),
        Cause:      cause,
    }
}
```

---

## 2. 도메인별 에러 코드

### 2.1 에러 코드 체계

```
K-ERP-{도메인}-{카테고리}-{번호}

도메인:
  ACC - 회계 (Accounting)
  TAX - 세무 (Tax)
  HR  - 인사급여 (HR)
  INV - 재고 (Inventory)
  SYS - 시스템 (System)

카테고리:
  VAL - 유효성 검증
  BIZ - 비즈니스 로직
  EXT - 외부 연동
  SEC - 보안
```

### 2.2 회계 도메인 에러

```go
// internal/domain/accounting/errors.go
package accounting

import "kerp/internal/apperror"

// 회계 에러 코드
const (
    ErrCodeVoucherUnbalanced     = "K-ERP-ACC-BIZ-001"
    ErrCodeVoucherAlreadyPosted  = "K-ERP-ACC-BIZ-002"
    ErrCodePeriodClosed          = "K-ERP-ACC-BIZ-003"
    ErrCodeInvalidAccountCode    = "K-ERP-ACC-VAL-001"
    ErrCodeAccountNotFound       = "K-ERP-ACC-VAL-002"
    ErrCodeDuplicateVoucherNo    = "K-ERP-ACC-VAL-003"
)

// 에러 메시지
var accountingErrors = map[string]string{
    ErrCodeVoucherUnbalanced:    "전표의 차변과 대변이 일치하지 않습니다.",
    ErrCodeVoucherAlreadyPosted: "이미 승인된 전표는 수정할 수 없습니다.",
    ErrCodePeriodClosed:         "마감된 회계기간에는 전표를 입력할 수 없습니다.",
    ErrCodeInvalidAccountCode:   "유효하지 않은 계정과목 코드입니다.",
    ErrCodeAccountNotFound:      "계정과목을 찾을 수 없습니다.",
    ErrCodeDuplicateVoucherNo:   "중복된 전표번호입니다.",
}

// ErrVoucherUnbalanced 전표 불균형 에러
func ErrVoucherUnbalanced(debit, credit string) *apperror.AppError {
    return &apperror.AppError{
        Type:       apperror.TypeBusinessRule,
        Title:      "Voucher Unbalanced",
        StatusCode: 422,
        Detail:     fmt.Sprintf("차변(%s)과 대변(%s)이 일치하지 않습니다.", debit, credit),
        Fields: []apperror.FieldError{
            {Field: "lines", Code: ErrCodeVoucherUnbalanced, Message: accountingErrors[ErrCodeVoucherUnbalanced]},
        },
    }
}

// ErrPeriodClosed 회계기간 마감 에러
func ErrPeriodClosed(period string) *apperror.AppError {
    return &apperror.AppError{
        Type:       apperror.TypeBusinessRule,
        Title:      "Period Closed",
        StatusCode: 422,
        Detail:     fmt.Sprintf("회계기간 %s은(는) 마감되었습니다.", period),
        Fields: []apperror.FieldError{
            {Field: "voucher_date", Code: ErrCodePeriodClosed, Message: accountingErrors[ErrCodePeriodClosed]},
        },
    }
}

// ErrAccountNotFound 계정과목 미존재 에러
func ErrAccountNotFound(code string) *apperror.AppError {
    return apperror.NewNotFoundError(fmt.Sprintf("계정과목 %s", code))
}
```

### 2.3 세금계산서 도메인 에러

```go
// internal/domain/tax/errors.go
package tax

import "kerp/internal/apperror"

const (
    ErrCodeInvalidBusinessNumber   = "K-ERP-TAX-VAL-001"
    ErrCodeInvoiceAlreadyIssued    = "K-ERP-TAX-BIZ-001"
    ErrCodePopbillAPIError         = "K-ERP-TAX-EXT-001"
    ErrCodeInvalidTaxAmount        = "K-ERP-TAX-VAL-002"
)

// ErrInvalidBusinessNumber 사업자등록번호 오류
func ErrInvalidBusinessNumber(number string) *apperror.AppError {
    return apperror.NewValidationError(
        "유효하지 않은 사업자등록번호입니다.",
        []apperror.FieldError{
            {Field: "business_number", Code: ErrCodeInvalidBusinessNumber, Message: "사업자등록번호 형식이 올바르지 않습니다."},
        },
    )
}

// ErrPopbillAPIError Popbill API 오류
func ErrPopbillAPIError(code int, message string) *apperror.AppError {
    return &apperror.AppError{
        Type:       apperror.TypeServiceUnavail,
        Title:      "Popbill API Error",
        StatusCode: 502,
        Detail:     fmt.Sprintf("세금계산서 발행 중 오류가 발생했습니다: %s (코드: %d)", message, code),
    }
}
```

### 2.4 인사급여 도메인 에러

```go
// internal/domain/hr/errors.go
package hr

import "kerp/internal/apperror"

const (
    ErrCodePayrollAlreadyCalculated = "K-ERP-HR-BIZ-001"
    ErrCodeInvalidEmployeeStatus    = "K-ERP-HR-BIZ-002"
    ErrCodeEDIGenerationFailed      = "K-ERP-HR-EXT-001"
    ErrCodeDuplicateEmployeeNo      = "K-ERP-HR-VAL-001"
)

// ErrPayrollAlreadyCalculated 급여 이미 계산됨
func ErrPayrollAlreadyCalculated(yearMonth string) *apperror.AppError {
    return &apperror.AppError{
        Type:       apperror.TypeBusinessRule,
        Title:      "Payroll Already Calculated",
        StatusCode: 422,
        Detail:     fmt.Sprintf("%s 급여가 이미 계산되었습니다.", yearMonth),
    }
}

// ErrEDIGenerationFailed EDI 파일 생성 실패
func ErrEDIGenerationFailed(ediType string, cause error) *apperror.AppError {
    return &apperror.AppError{
        Type:       apperror.TypeInternal,
        Title:      "EDI Generation Failed",
        StatusCode: 500,
        Detail:     fmt.Sprintf("%s EDI 파일 생성에 실패했습니다.", ediType),
        Cause:      cause,
    }
}
```

---

## 3. 에러 처리 미들웨어

### 3.1 Gin 에러 핸들러

```go
// internal/middleware/error_handler.go
package middleware

import (
    "errors"
    "net/http"

    "github.com/gin-gonic/gin"
    "go.uber.org/zap"

    "kerp/internal/apperror"
    "kerp/internal/infrastructure/logger"
)

// ErrorHandler 전역 에러 핸들러
func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()

        // 에러가 없으면 패스
        if len(c.Errors) == 0 {
            return
        }

        // 마지막 에러 처리
        err := c.Errors.Last().Err
        handleError(c, err)
    }
}

func handleError(c *gin.Context, err error) {
    log := logger.Logger()

    // AppError인 경우
    var appErr *apperror.AppError
    if errors.As(err, &appErr) {
        appErr.Instance = c.Request.URL.Path
        problem := appErr.ToProblemDetail()

        // 로깅 (5xx만 Error 레벨)
        if appErr.StatusCode >= 500 {
            log.Error("Server error",
                zap.String("error_id", problem.ErrorID),
                zap.String("path", c.Request.URL.Path),
                zap.String("method", c.Request.Method),
                zap.Error(appErr.Cause),
            )
        } else {
            log.Warn("Client error",
                zap.String("error_id", problem.ErrorID),
                zap.String("path", c.Request.URL.Path),
                zap.Int("status", appErr.StatusCode),
            )
        }

        c.JSON(appErr.StatusCode, problem)
        return
    }

    // 알 수 없는 에러 (500)
    internalErr := apperror.NewInternalError(err)
    internalErr.Instance = c.Request.URL.Path
    problem := internalErr.ToProblemDetail()

    log.Error("Unexpected error",
        zap.String("error_id", problem.ErrorID),
        zap.String("path", c.Request.URL.Path),
        zap.Error(err),
    )

    c.JSON(http.StatusInternalServerError, problem)
}
```

### 3.2 Recovery 미들웨어 (Panic 처리)

```go
// internal/middleware/recovery.go
package middleware

import (
    "net/http"
    "runtime/debug"

    "github.com/gin-gonic/gin"
    "go.uber.org/zap"

    "kerp/internal/apperror"
    "kerp/internal/infrastructure/logger"
)

// Recovery Panic 복구 미들웨어
func Recovery() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if r := recover(); r != nil {
                log := logger.Logger()

                // 스택 트레이스
                stack := string(debug.Stack())

                err := apperror.NewInternalError(fmt.Errorf("panic: %v", r))
                err.Instance = c.Request.URL.Path
                problem := err.ToProblemDetail()

                log.Error("Panic recovered",
                    zap.String("error_id", problem.ErrorID),
                    zap.String("path", c.Request.URL.Path),
                    zap.Any("panic", r),
                    zap.String("stack", stack),
                )

                c.AbortWithStatusJSON(http.StatusInternalServerError, problem)
            }
        }()

        c.Next()
    }
}
```

---

## 4. 서비스 레이어 에러 처리

### 4.1 에러 래핑 패턴

```go
// internal/service/voucher_service.go
package service

import (
    "context"
    "fmt"

    "kerp/internal/apperror"
    "kerp/internal/domain"
    "kerp/internal/domain/accounting"
)

func (s *VoucherService) CreateVoucher(ctx context.Context, input *CreateVoucherInput) (*domain.Voucher, error) {
    // 입력 유효성 검증
    if err := input.Validate(); err != nil {
        return nil, err // 이미 AppError
    }

    // 회계기간 확인
    period := input.VoucherDate[:7] // YYYY-MM
    closed, err := s.periodRepo.IsClosed(ctx, period)
    if err != nil {
        return nil, apperror.NewInternalError(fmt.Errorf("failed to check period: %w", err))
    }
    if closed {
        return nil, accounting.ErrPeriodClosed(period)
    }

    // 전표 생성
    voucher := input.ToVoucher()

    // 차대 균형 검증
    if !voucher.IsBalanced() {
        debit, credit := voucher.CalculateTotals()
        return nil, accounting.ErrVoucherUnbalanced(debit.String(), credit.String())
    }

    // 저장
    if err := s.voucherRepo.Create(ctx, voucher); err != nil {
        // DB 에러 분류
        if isDuplicateError(err) {
            return nil, apperror.NewConflictError("중복된 전표번호입니다.")
        }
        return nil, apperror.NewInternalError(fmt.Errorf("failed to create voucher: %w", err))
    }

    return voucher, nil
}

// isDuplicateError PostgreSQL duplicate key 에러 확인
func isDuplicateError(err error) bool {
    // pgconn.PgError 확인
    var pgErr *pgconn.PgError
    if errors.As(err, &pgErr) {
        return pgErr.Code == "23505" // unique_violation
    }
    return false
}
```

### 4.2 입력 유효성 검증

```go
// internal/service/dto/voucher_input.go
package dto

import (
    "time"

    "github.com/go-playground/validator/v10"

    "kerp/internal/apperror"
)

var validate = validator.New()

type CreateVoucherInput struct {
    VoucherDate string             `json:"voucher_date" validate:"required,datetime=2006-01-02"`
    VoucherType string             `json:"voucher_type" validate:"required,oneof=general purchase sales payment receipt"`
    Description string             `json:"description" validate:"max=500"`
    Lines       []VoucherLineInput `json:"lines" validate:"required,min=1,dive"`
}

type VoucherLineInput struct {
    AccountCode  string  `json:"account_code" validate:"required,max=20"`
    DebitAmount  float64 `json:"debit_amount" validate:"min=0"`
    CreditAmount float64 `json:"credit_amount" validate:"min=0"`
    Description  string  `json:"description" validate:"max=200"`
}

// Validate 입력 유효성 검증
func (i *CreateVoucherInput) Validate() error {
    err := validate.Struct(i)
    if err == nil {
        return nil
    }

    // validator 에러를 AppError로 변환
    var fields []apperror.FieldError

    for _, e := range err.(validator.ValidationErrors) {
        field := toJSONFieldName(e.Field())
        code := e.Tag()
        message := formatValidationMessage(e)

        fields = append(fields, apperror.FieldError{
            Field:   field,
            Code:    code,
            Message: message,
        })
    }

    return apperror.NewValidationError("입력값이 유효하지 않습니다.", fields)
}

func formatValidationMessage(e validator.FieldError) string {
    switch e.Tag() {
    case "required":
        return fmt.Sprintf("%s은(는) 필수 입력 항목입니다.", e.Field())
    case "min":
        return fmt.Sprintf("%s은(는) 최소 %s 이상이어야 합니다.", e.Field(), e.Param())
    case "max":
        return fmt.Sprintf("%s은(는) 최대 %s까지 입력 가능합니다.", e.Field(), e.Param())
    case "datetime":
        return fmt.Sprintf("%s의 날짜 형식이 올바르지 않습니다.", e.Field())
    case "oneof":
        return fmt.Sprintf("%s은(는) %s 중 하나여야 합니다.", e.Field(), e.Param())
    default:
        return fmt.Sprintf("%s이(가) 유효하지 않습니다.", e.Field())
    }
}
```

---

## 5. 외부 연동 에러 처리

### 5.1 Popbill API 에러

```go
// internal/infrastructure/popbill/client.go
package popbill

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"

    "kerp/internal/apperror"
)

// PopbillError Popbill API 에러
type PopbillError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
}

// 주요 Popbill 에러 코드
const (
    PopbillErrInvalidCorpNum  = -10000001 // 사업자등록번호 오류
    PopbillErrDuplicateInvoice = -30000001 // 중복 문서
    PopbillErrInvalidAuth     = -10000004 // 인증 오류
)

func (c *Client) IssueTaxInvoice(ctx context.Context, invoice *TaxInvoice) (string, error) {
    resp, err := c.doRequest(ctx, "POST", "/TaxInvoice/Issue", invoice)
    if err != nil {
        return "", apperror.NewServiceUnavailableError("Popbill", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        var popbillErr PopbillError
        if err := json.NewDecoder(resp.Body).Decode(&popbillErr); err != nil {
            return "", apperror.NewInternalError(fmt.Errorf("failed to decode popbill error: %w", err))
        }

        return "", c.convertPopbillError(&popbillErr)
    }

    var result struct {
        NTSConfirmNum string `json:"ntsconfirmNum"`
    }
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return "", apperror.NewInternalError(fmt.Errorf("failed to decode response: %w", err))
    }

    return result.NTSConfirmNum, nil
}

func (c *Client) convertPopbillError(pe *PopbillError) *apperror.AppError {
    switch pe.Code {
    case PopbillErrInvalidCorpNum:
        return apperror.NewValidationError(
            "사업자등록번호가 올바르지 않습니다.",
            []apperror.FieldError{
                {Field: "business_number", Code: "invalid", Message: pe.Message},
            },
        )
    case PopbillErrDuplicateInvoice:
        return apperror.NewConflictError("이미 발행된 세금계산서입니다.")
    case PopbillErrInvalidAuth:
        return apperror.NewInternalError(fmt.Errorf("popbill auth error: %s", pe.Message))
    default:
        return &apperror.AppError{
            Type:       apperror.TypeServiceUnavail,
            Title:      "Popbill Error",
            StatusCode: 502,
            Detail:     fmt.Sprintf("세금계산서 처리 중 오류: %s (코드: %d)", pe.Message, pe.Code),
        }
    }
}
```

### 5.2 DB 에러 처리

```go
// internal/infrastructure/database/errors.go
package database

import (
    "errors"

    "github.com/jackc/pgx/v5/pgconn"

    "kerp/internal/apperror"
)

// PostgreSQL 에러 코드
const (
    PgUniqueViolation     = "23505"
    PgForeignKeyViolation = "23503"
    PgCheckViolation      = "23514"
    PgNotNullViolation    = "23502"
)

// WrapDBError DB 에러를 AppError로 변환
func WrapDBError(err error, entity string) error {
    if err == nil {
        return nil
    }

    var pgErr *pgconn.PgError
    if errors.As(err, &pgErr) {
        switch pgErr.Code {
        case PgUniqueViolation:
            return apperror.NewConflictError(
                fmt.Sprintf("중복된 %s입니다. (%s)", entity, pgErr.ConstraintName),
            )
        case PgForeignKeyViolation:
            return apperror.NewValidationError(
                "참조 무결성 오류",
                []apperror.FieldError{
                    {Field: pgErr.ColumnName, Code: "foreign_key", Message: "참조된 데이터가 존재하지 않습니다."},
                },
            )
        case PgNotNullViolation:
            return apperror.NewValidationError(
                "필수 필드 누락",
                []apperror.FieldError{
                    {Field: pgErr.ColumnName, Code: "required", Message: fmt.Sprintf("%s은(는) 필수입니다.", pgErr.ColumnName)},
                },
            )
        }
    }

    // 기타 DB 에러
    return apperror.NewInternalError(fmt.Errorf("database error: %w", err))
}
```

---

## 6. 프론트엔드 에러 처리

### 6.1 API 클라이언트 에러 처리

```typescript
// web/src/lib/api/client.ts
import axios, { AxiosError, AxiosInstance } from 'axios'

interface ProblemDetail {
  type: string
  title: string
  status: number
  detail: string
  instance?: string
  error_id: string
  timestamp: string
  errors?: FieldError[]
}

interface FieldError {
  field: string
  code: string
  message: string
}

export class ApiError extends Error {
  constructor(
    public status: number,
    public title: string,
    public detail: string,
    public errorId: string,
    public fieldErrors?: FieldError[]
  ) {
    super(detail)
    this.name = 'ApiError'
  }

  static fromProblemDetail(problem: ProblemDetail): ApiError {
    return new ApiError(
      problem.status,
      problem.title,
      problem.detail,
      problem.error_id,
      problem.errors
    )
  }

  getFieldError(field: string): string | undefined {
    return this.fieldErrors?.find(e => e.field === field)?.message
  }

  hasFieldError(field: string): boolean {
    return this.fieldErrors?.some(e => e.field === field) ?? false
  }
}

export const apiClient: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
})

// Response Interceptor
apiClient.interceptors.response.use(
  (response) => response,
  (error: AxiosError<ProblemDetail>) => {
    if (error.response?.data) {
      const problem = error.response.data
      throw ApiError.fromProblemDetail(problem)
    }

    // 네트워크 에러
    throw new ApiError(
      0,
      'Network Error',
      '서버에 연결할 수 없습니다.',
      'network_error'
    )
  }
)
```

### 6.2 React Query 에러 처리

```typescript
// web/src/hooks/useVoucherMutation.ts
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { toast } from 'sonner'
import { ApiError } from '@/lib/api/client'
import { createVoucher, CreateVoucherInput } from '@/lib/api/vouchers'

export function useCreateVoucher() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (input: CreateVoucherInput) => createVoucher(input),
    onSuccess: (data) => {
      toast.success('전표가 생성되었습니다.')
      queryClient.invalidateQueries({ queryKey: ['vouchers'] })
    },
    onError: (error: ApiError) => {
      // 필드 에러가 있으면 폼에서 처리
      if (error.fieldErrors && error.fieldErrors.length > 0) {
        toast.error('입력값을 확인해주세요.')
        return
      }

      // 일반 에러
      toast.error(error.detail, {
        description: `에러 ID: ${error.errorId}`,
      })
    },
  })
}
```

### 6.3 폼 에러 바인딩 (React Hook Form)

```typescript
// web/src/components/voucher/VoucherForm.tsx
import { useForm } from 'react-hook-form'
import { useEffect } from 'react'
import { ApiError } from '@/lib/api/client'
import { useCreateVoucher } from '@/hooks/useVoucherMutation'

export function VoucherForm() {
  const form = useForm<VoucherFormData>()
  const createVoucher = useCreateVoucher()

  // API 에러를 폼에 바인딩
  useEffect(() => {
    if (createVoucher.error instanceof ApiError) {
      const apiError = createVoucher.error
      apiError.fieldErrors?.forEach((fieldError) => {
        form.setError(fieldError.field as any, {
          type: 'server',
          message: fieldError.message,
        })
      })
    }
  }, [createVoucher.error, form])

  const onSubmit = form.handleSubmit((data) => {
    createVoucher.mutate(data)
  })

  return (
    <form onSubmit={onSubmit}>
      <FormField
        control={form.control}
        name="voucher_date"
        render={({ field, fieldState }) => (
          <FormItem>
            <FormLabel>전표일자</FormLabel>
            <FormControl>
              <Input {...field} />
            </FormControl>
            {fieldState.error && (
              <FormMessage>{fieldState.error.message}</FormMessage>
            )}
          </FormItem>
        )}
      />
      {/* ... */}
    </form>
  )
}
```

---

## 7. 에러 로깅 및 모니터링

### 7.1 구조화된 에러 로그

```go
// 에러 발생 시 로그 포맷
{
    "timestamp": "2024-01-15T09:30:00.123Z",
    "level": "error",
    "message": "Voucher creation failed",
    "error_id": "err_550e8400-e29b-41d4-a716-446655440000",
    "error_type": "business_rule_violation",
    "error_code": "K-ERP-ACC-BIZ-001",
    "path": "/api/v1/vouchers",
    "method": "POST",
    "user_id": "user_123",
    "company_id": "company_456",
    "request_id": "req_789",
    "duration_ms": 45,
    "stack_trace": "...",
    "context": {
        "debit_total": "100000",
        "credit_total": "50000"
    }
}
```

### 7.2 Grafana 알림 규칙

```yaml
# 에러율 모니터링
- alert: HighErrorRate
  expr: |
    sum(rate(http_requests_total{status=~"5.."}[5m]))
    /
    sum(rate(http_requests_total[5m])) > 0.05
  for: 5m
  labels:
    severity: critical
  annotations:
    summary: "High 5xx error rate (> 5%)"
    description: "Error rate is {{ $value | humanizePercentage }}"

# 특정 에러 코드 급증
- alert: BusinessRuleViolationSpike
  expr: |
    sum(rate(app_errors_total{error_type="business_rule_violation"}[5m])) > 10
  for: 2m
  labels:
    severity: warning
  annotations:
    summary: "Business rule violation spike"
```

---

**문서 버전**: 1.0
**작성일**: 2025년 1월
**작성자**: K-ERP 개발팀
