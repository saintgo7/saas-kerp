# 21. 데이터 마이그레이션 가이드

## 개요

K-ERP 시스템의 데이터베이스 마이그레이션 전략 및 구현 가이드.
스키마 변경, 데이터 이관, 롤백 절차 정의.

### 마이그레이션 원칙

| 원칙 | 설명 |
|------|------|
| 버전 관리 | 모든 스키마 변경은 버전 관리 |
| 무중단 배포 | Zero-downtime migration |
| 롤백 가능 | 모든 마이그레이션은 롤백 가능 |
| 멱등성 | 여러 번 실행해도 동일한 결과 |

---

## 1. 마이그레이션 도구

### 1.1 golang-migrate

```bash
# 설치
go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest

# 버전 확인
migrate -version
```

### 1.2 디렉토리 구조

```
db/
├── migrations/                    # 스키마 마이그레이션
│   ├── 000001_init_extensions.up.sql
│   ├── 000001_init_extensions.down.sql
│   ├── 000002_create_companies.up.sql
│   ├── 000002_create_companies.down.sql
│   ├── 000003_create_users.up.sql
│   ├── 000003_create_users.down.sql
│   └── ...
├── seeds/                         # 초기 데이터
│   ├── 001_account_plans.sql
│   └── 002_system_settings.sql
└── queries/                       # sqlc 쿼리
    └── ...
```

### 1.3 마이그레이션 명령어

```makefile
# Makefile

DB_URL := postgres://kerp:$(DB_PASSWORD)@localhost:5432/kerp?sslmode=disable

# 마이그레이션 실행
migrate-up:
	migrate -path db/migrations -database "$(DB_URL)" up

# 특정 버전까지 마이그레이션
migrate-up-to:
	@read -p "Version: " version; \
	migrate -path db/migrations -database "$(DB_URL)" up $$version

# 롤백 (1단계)
migrate-down:
	migrate -path db/migrations -database "$(DB_URL)" down 1

# 특정 버전으로 롤백
migrate-down-to:
	@read -p "Version: " version; \
	migrate -path db/migrations -database "$(DB_URL)" down $$version

# 마이그레이션 생성
migrate-create:
	@read -p "Migration name: " name; \
	migrate create -ext sql -dir db/migrations -seq $$name

# 현재 버전 확인
migrate-version:
	migrate -path db/migrations -database "$(DB_URL)" version

# 강제 버전 설정 (dirty 상태 복구)
migrate-force:
	@read -p "Version: " version; \
	migrate -path db/migrations -database "$(DB_URL)" force $$version
```

---

## 2. 마이그레이션 작성 가이드

### 2.1 기본 템플릿

```sql
-- db/migrations/000010_create_vouchers.up.sql

-- 트랜잭션 시작 (실패 시 자동 롤백)
BEGIN;

-- 테이블 생성
CREATE TABLE IF NOT EXISTS vouchers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,

    voucher_no VARCHAR(20) NOT NULL,
    voucher_date DATE NOT NULL,
    voucher_type VARCHAR(20) NOT NULL DEFAULT 'general',
    description TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'draft',

    total_debit NUMERIC(18, 2) NOT NULL DEFAULT 0,
    total_credit NUMERIC(18, 2) NOT NULL DEFAULT 0,

    created_by UUID REFERENCES users(id),
    approved_by UUID REFERENCES users(id),
    approved_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,

    CONSTRAINT vouchers_company_no_unique UNIQUE (company_id, voucher_no),
    CONSTRAINT vouchers_balanced CHECK (total_debit = total_credit)
);

-- 인덱스 생성
CREATE INDEX IF NOT EXISTS idx_vouchers_company_date
    ON vouchers (company_id, voucher_date DESC)
    WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_vouchers_company_status
    ON vouchers (company_id, status)
    WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_vouchers_company_type
    ON vouchers (company_id, voucher_type)
    WHERE deleted_at IS NULL;

-- Updated At 트리거
CREATE TRIGGER vouchers_updated_at
    BEFORE UPDATE ON vouchers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at();

-- RLS 활성화
ALTER TABLE vouchers ENABLE ROW LEVEL SECURITY;
ALTER TABLE vouchers FORCE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation ON vouchers
    FOR ALL
    USING (company_id = current_tenant_id())
    WITH CHECK (company_id = current_tenant_id());

-- 코멘트
COMMENT ON TABLE vouchers IS '전표 테이블';
COMMENT ON COLUMN vouchers.voucher_type IS '전표유형: general(일반), purchase(매입), sales(매출), payment(지급), receipt(수금)';
COMMENT ON COLUMN vouchers.status IS '상태: draft(작성중), pending(승인대기), approved(승인), rejected(반려)';

COMMIT;
```

```sql
-- db/migrations/000010_create_vouchers.down.sql

BEGIN;

-- 역순으로 삭제
DROP POLICY IF EXISTS tenant_isolation ON vouchers;
DROP TRIGGER IF EXISTS vouchers_updated_at ON vouchers;
DROP INDEX IF EXISTS idx_vouchers_company_type;
DROP INDEX IF EXISTS idx_vouchers_company_status;
DROP INDEX IF EXISTS idx_vouchers_company_date;
DROP TABLE IF EXISTS vouchers;

COMMIT;
```

### 2.2 컬럼 추가 (무중단)

```sql
-- db/migrations/000020_add_voucher_reference.up.sql

BEGIN;

-- Step 1: 컬럼 추가 (NULL 허용, 기본값 없음)
ALTER TABLE vouchers
    ADD COLUMN IF NOT EXISTS reference_no VARCHAR(50),
    ADD COLUMN IF NOT EXISTS reference_type VARCHAR(20);

-- Step 2: 인덱스 추가 (CONCURRENTLY - 락 없음)
-- 주의: CONCURRENTLY는 트랜잭션 밖에서 실행해야 함
COMMIT;

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_vouchers_reference
    ON vouchers (company_id, reference_type, reference_no)
    WHERE deleted_at IS NULL;

BEGIN;

-- Step 3: 코멘트
COMMENT ON COLUMN vouchers.reference_no IS '참조 문서 번호';
COMMENT ON COLUMN vouchers.reference_type IS '참조 유형: invoice(세금계산서), order(주문서), contract(계약서)';

COMMIT;
```

```sql
-- db/migrations/000020_add_voucher_reference.down.sql

-- CONCURRENTLY 인덱스는 트랜잭션 밖에서
DROP INDEX CONCURRENTLY IF EXISTS idx_vouchers_reference;

BEGIN;

ALTER TABLE vouchers
    DROP COLUMN IF EXISTS reference_no,
    DROP COLUMN IF EXISTS reference_type;

COMMIT;
```

### 2.3 컬럼 변경 (타입 변경)

```sql
-- db/migrations/000030_change_amount_precision.up.sql

-- 금액 정밀도 변경: NUMERIC(18,2) → NUMERIC(20,4)
-- 주의: 대용량 테이블에서는 시간이 오래 걸릴 수 있음

BEGIN;

-- 1. 새 컬럼 추가
ALTER TABLE voucher_lines
    ADD COLUMN debit_amount_new NUMERIC(20, 4),
    ADD COLUMN credit_amount_new NUMERIC(20, 4);

COMMIT;

-- 2. 데이터 복사 (배치 처리)
DO $$
DECLARE
    batch_size INT := 10000;
    total_rows INT;
    processed INT := 0;
BEGIN
    SELECT COUNT(*) INTO total_rows FROM voucher_lines WHERE debit_amount_new IS NULL;

    WHILE processed < total_rows LOOP
        UPDATE voucher_lines
        SET
            debit_amount_new = debit_amount,
            credit_amount_new = credit_amount
        WHERE id IN (
            SELECT id FROM voucher_lines
            WHERE debit_amount_new IS NULL
            LIMIT batch_size
        );

        processed := processed + batch_size;
        RAISE NOTICE 'Processed % / % rows', LEAST(processed, total_rows), total_rows;

        -- 잠시 대기 (DB 부하 분산)
        PERFORM pg_sleep(0.1);
    END LOOP;
END $$;

BEGIN;

-- 3. 기존 컬럼 삭제 및 이름 변경
ALTER TABLE voucher_lines
    DROP COLUMN debit_amount,
    DROP COLUMN credit_amount;

ALTER TABLE voucher_lines
    RENAME COLUMN debit_amount_new TO debit_amount;
ALTER TABLE voucher_lines
    RENAME COLUMN credit_amount_new TO credit_amount;

-- 4. NOT NULL 제약조건 추가
ALTER TABLE voucher_lines
    ALTER COLUMN debit_amount SET NOT NULL,
    ALTER COLUMN credit_amount SET NOT NULL;

-- 5. 기본값 설정
ALTER TABLE voucher_lines
    ALTER COLUMN debit_amount SET DEFAULT 0,
    ALTER COLUMN credit_amount SET DEFAULT 0;

COMMIT;
```

### 2.4 테이블 파티셔닝

```sql
-- db/migrations/000040_partition_vouchers.up.sql

-- 전표 테이블 월별 파티셔닝 (대용량 데이터 처리)

BEGIN;

-- 1. 기존 테이블 이름 변경
ALTER TABLE vouchers RENAME TO vouchers_old;

-- 2. 파티션 테이블 생성
CREATE TABLE vouchers (
    id UUID NOT NULL DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL,
    voucher_no VARCHAR(20) NOT NULL,
    voucher_date DATE NOT NULL,
    voucher_type VARCHAR(20) NOT NULL DEFAULT 'general',
    description TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'draft',
    total_debit NUMERIC(18, 2) NOT NULL DEFAULT 0,
    total_credit NUMERIC(18, 2) NOT NULL DEFAULT 0,
    created_by UUID,
    approved_by UUID,
    approved_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,
    PRIMARY KEY (id, voucher_date)
) PARTITION BY RANGE (voucher_date);

-- 3. 월별 파티션 생성 (2024년)
CREATE TABLE vouchers_2024_01 PARTITION OF vouchers
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE vouchers_2024_02 PARTITION OF vouchers
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
-- ... 나머지 월
CREATE TABLE vouchers_2024_12 PARTITION OF vouchers
    FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');

-- 4. 기본 파티션 (범위 외 데이터용)
CREATE TABLE vouchers_default PARTITION OF vouchers DEFAULT;

-- 5. 인덱스 생성 (각 파티션에 자동 적용)
CREATE INDEX idx_vouchers_company_date ON vouchers (company_id, voucher_date DESC);
CREATE INDEX idx_vouchers_company_status ON vouchers (company_id, status);

COMMIT;

-- 6. 데이터 마이그레이션 (별도 실행)
INSERT INTO vouchers SELECT * FROM vouchers_old;

-- 7. 외래키 재설정 (파티션 테이블에서는 제한적)
-- 애플리케이션 레벨에서 처리

-- 8. 이전 테이블 삭제 (데이터 검증 후)
-- DROP TABLE vouchers_old;
```

---

## 3. 무중단 마이그레이션 패턴

### 3.1 Expand-Contract 패턴

```
Phase 1: Expand (확장)
┌─────────────────────────────────────────┐
│  기존 컬럼 유지 + 새 컬럼 추가           │
│  애플리케이션: 양쪽 모두 쓰기            │
└─────────────────────────────────────────┘
                    │
                    ▼
Phase 2: Migrate (이관)
┌─────────────────────────────────────────┐
│  기존 데이터를 새 컬럼으로 복사          │
│  백그라운드 배치 처리                    │
└─────────────────────────────────────────┘
                    │
                    ▼
Phase 3: Contract (축소)
┌─────────────────────────────────────────┐
│  기존 컬럼 제거                          │
│  애플리케이션: 새 컬럼만 사용            │
└─────────────────────────────────────────┘
```

### 3.2 컬럼 이름 변경 예시

```sql
-- Step 1: 새 컬럼 추가
ALTER TABLE customers ADD COLUMN business_number VARCHAR(10);

-- Step 2: 데이터 복사 트리거
CREATE OR REPLACE FUNCTION sync_business_number()
RETURNS TRIGGER AS $$
BEGIN
    NEW.business_number := NEW.corp_num;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_business_number_trigger
    BEFORE INSERT OR UPDATE ON customers
    FOR EACH ROW
    EXECUTE FUNCTION sync_business_number();

-- Step 3: 기존 데이터 배치 복사
UPDATE customers SET business_number = corp_num WHERE business_number IS NULL;

-- Step 4: 애플리케이션 배포 (새 컬럼 사용)

-- Step 5: 기존 컬럼 제거
DROP TRIGGER sync_business_number_trigger ON customers;
DROP FUNCTION sync_business_number();
ALTER TABLE customers DROP COLUMN corp_num;
```

### 3.3 테이블 분리 패턴

```sql
-- 기존: users 테이블에 profile 정보 포함
-- 변경: users + user_profiles 분리

-- Step 1: 새 테이블 생성
CREATE TABLE user_profiles (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    bio TEXT,
    avatar_url VARCHAR(500),
    preferences JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Step 2: 데이터 복사
INSERT INTO user_profiles (user_id, bio, avatar_url)
SELECT id, bio, avatar_url FROM users;

-- Step 3: 트리거로 동기화
CREATE OR REPLACE FUNCTION sync_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO user_profiles (user_id) VALUES (NEW.id)
        ON CONFLICT (user_id) DO NOTHING;
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE user_profiles
        SET bio = NEW.bio, avatar_url = NEW.avatar_url
        WHERE user_id = NEW.id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Step 4: 애플리케이션 전환 후 기존 컬럼 제거
ALTER TABLE users DROP COLUMN bio, DROP COLUMN avatar_url;
```

---

## 4. 대용량 데이터 마이그레이션

### 4.1 배치 처리

```go
// internal/migration/batch_migrator.go
package migration

import (
    "context"
    "fmt"
    "time"

    "gorm.io/gorm"
)

type BatchMigrator struct {
    db        *gorm.DB
    batchSize int
    delay     time.Duration
}

func NewBatchMigrator(db *gorm.DB) *BatchMigrator {
    return &BatchMigrator{
        db:        db,
        batchSize: 1000,
        delay:     100 * time.Millisecond,
    }
}

// MigrateInBatches 배치 단위로 마이그레이션 실행
func (m *BatchMigrator) MigrateInBatches(ctx context.Context, query string) error {
    var totalRows int64
    var processedRows int64

    // 전체 개수 확인
    if err := m.db.WithContext(ctx).Raw("SELECT COUNT(*) FROM (" + query + ") AS t").Scan(&totalRows).Error; err != nil {
        return err
    }

    for processedRows < totalRows {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }

        // 배치 실행
        batchQuery := fmt.Sprintf(`
            WITH batch AS (
                SELECT id FROM (%s) AS source
                WHERE NOT migrated
                LIMIT %d
                FOR UPDATE SKIP LOCKED
            )
            UPDATE target_table
            SET migrated = true
            WHERE id IN (SELECT id FROM batch)
            RETURNING id
        `, query, m.batchSize)

        result := m.db.WithContext(ctx).Exec(batchQuery)
        if result.Error != nil {
            return result.Error
        }

        processedRows += result.RowsAffected

        // 진행률 로깅
        progress := float64(processedRows) / float64(totalRows) * 100
        fmt.Printf("Migration progress: %.2f%% (%d/%d)\n", progress, processedRows, totalRows)

        // 부하 분산을 위한 딜레이
        time.Sleep(m.delay)
    }

    return nil
}
```

### 4.2 pg_dump/pg_restore

```bash
#!/bin/bash
# scripts/migrate-large-table.sh

set -e

SOURCE_DB="postgres://user:pass@source-host:5432/kerp"
TARGET_DB="postgres://user:pass@target-host:5432/kerp"
TABLE_NAME="voucher_lines"

echo "=== 대용량 테이블 마이그레이션 시작 ==="

# 1. 소스 데이터 덤프
echo "Dumping $TABLE_NAME..."
pg_dump "$SOURCE_DB" \
    --table="$TABLE_NAME" \
    --data-only \
    --format=custom \
    --file="/tmp/${TABLE_NAME}.dump"

# 2. 타겟에 복원
echo "Restoring to target..."
pg_restore "$TARGET_DB" \
    --data-only \
    --disable-triggers \
    --jobs=4 \
    "/tmp/${TABLE_NAME}.dump"

# 3. 시퀀스 동기화
echo "Syncing sequences..."
psql "$TARGET_DB" -c "
    SELECT setval(
        pg_get_serial_sequence('${TABLE_NAME}', 'id'),
        COALESCE(MAX(id), 1)
    ) FROM ${TABLE_NAME};
"

# 4. 인덱스 재생성
echo "Reindexing..."
psql "$TARGET_DB" -c "REINDEX TABLE ${TABLE_NAME};"

# 5. VACUUM ANALYZE
echo "Running VACUUM ANALYZE..."
psql "$TARGET_DB" -c "VACUUM ANALYZE ${TABLE_NAME};"

echo "=== 마이그레이션 완료 ==="
```

---

## 5. 데이터 이관 (기존 시스템)

### 5.1 이관 워크플로우

```
┌─────────────────────────────────────────────────────────────────────┐
│                    기존 시스템 → K-ERP 이관                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  [1. 데이터 추출]                                                    │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  기존 DB → CSV/Excel Export                                  │    │
│  │  또는 API를 통한 데이터 추출                                 │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                       │
│                              ▼                                       │
│  [2. 데이터 변환]                                                    │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  계정과목 매핑                                               │    │
│  │  코드 체계 변환                                              │    │
│  │  데이터 정합성 검증                                          │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                       │
│                              ▼                                       │
│  [3. 데이터 검증]                                                    │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  차대 균형 검증                                              │    │
│  │  참조 무결성 검증                                            │    │
│  │  비즈니스 룰 검증                                            │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                       │
│                              ▼                                       │
│  [4. 데이터 적재]                                                    │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  Staging 테이블 적재                                         │    │
│  │  검증 후 Production 이관                                     │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 계정과목 매핑

```go
// internal/migration/account_mapper.go
package migration

type AccountMapping struct {
    SourceCode string `json:"source_code"`
    SourceName string `json:"source_name"`
    TargetCode string `json:"target_code"`
    TargetName string `json:"target_name"`
    Verified   bool   `json:"verified"`
}

type AccountMapper struct {
    mappings map[string]*AccountMapping
}

// 표준 매핑 (일반적인 ERP 시스템)
var defaultMappings = []AccountMapping{
    // 자산
    {"1010", "현금", "10101", "현금", true},
    {"1020", "보통예금", "10102", "보통예금", true},
    {"1100", "외상매출금", "10201", "외상매출금", true},
    {"1110", "받을어음", "10202", "받을어음", true},
    {"1200", "재고자산", "10301", "상품", true},

    // 부채
    {"2100", "외상매입금", "20101", "외상매입금", true},
    {"2110", "지급어음", "20102", "지급어음", true},
    {"2200", "미지급금", "20201", "미지급금", true},
    {"2210", "예수금", "20301", "예수금", true},

    // 자본
    {"3100", "자본금", "30101", "자본금", true},
    {"3200", "이익잉여금", "30201", "이익잉여금", true},

    // 수익
    {"4100", "상품매출", "40101", "상품매출", true},
    {"4200", "제품매출", "40102", "제품매출", true},

    // 비용
    {"5100", "상품매입", "50101", "상품매입원가", true},
    {"5200", "급여", "52101", "급여", true},
    {"5210", "복리후생비", "52102", "복리후생비", true},
}

func (m *AccountMapper) Map(sourceCode string) (*AccountMapping, error) {
    if mapping, ok := m.mappings[sourceCode]; ok {
        return mapping, nil
    }
    return nil, fmt.Errorf("매핑되지 않은 계정코드: %s", sourceCode)
}

func (m *AccountMapper) GetUnmappedCodes() []string {
    var unmapped []string
    for code, mapping := range m.mappings {
        if !mapping.Verified {
            unmapped = append(unmapped, code)
        }
    }
    return unmapped
}
```

### 5.3 데이터 검증

```go
// internal/migration/validator.go
package migration

type MigrationValidator struct {
    db *gorm.DB
}

type ValidationResult struct {
    IsValid  bool              `json:"is_valid"`
    Errors   []ValidationError `json:"errors,omitempty"`
    Warnings []string          `json:"warnings,omitempty"`
    Summary  ValidationSummary `json:"summary"`
}

type ValidationError struct {
    Table   string `json:"table"`
    Row     int    `json:"row,omitempty"`
    Field   string `json:"field,omitempty"`
    Message string `json:"message"`
}

type ValidationSummary struct {
    TotalRecords  int `json:"total_records"`
    ValidRecords  int `json:"valid_records"`
    InvalidRecords int `json:"invalid_records"`
}

// ValidateMigrationData 이관 데이터 검증
func (v *MigrationValidator) ValidateMigrationData(ctx context.Context, companyID uuid.UUID) (*ValidationResult, error) {
    result := &ValidationResult{IsValid: true}

    // 1. 전표 차대 균형 검증
    if err := v.validateVoucherBalance(ctx, companyID, result); err != nil {
        return nil, err
    }

    // 2. 계정과목 존재 여부 검증
    if err := v.validateAccountCodes(ctx, companyID, result); err != nil {
        return nil, err
    }

    // 3. 참조 무결성 검증
    if err := v.validateReferentialIntegrity(ctx, companyID, result); err != nil {
        return nil, err
    }

    // 4. 기초잔액 차대 균형 검증
    if err := v.validateOpeningBalance(ctx, companyID, result); err != nil {
        return nil, err
    }

    result.IsValid = len(result.Errors) == 0
    return result, nil
}

func (v *MigrationValidator) validateVoucherBalance(ctx context.Context, companyID uuid.UUID, result *ValidationResult) error {
    type UnbalancedVoucher struct {
        VoucherNo   string
        TotalDebit  decimal.Decimal
        TotalCredit decimal.Decimal
    }

    var unbalanced []UnbalancedVoucher
    err := v.db.WithContext(ctx).Raw(`
        SELECT
            v.voucher_no,
            COALESCE(SUM(vl.debit_amount), 0) as total_debit,
            COALESCE(SUM(vl.credit_amount), 0) as total_credit
        FROM staging_vouchers v
        JOIN staging_voucher_lines vl ON v.id = vl.voucher_id
        WHERE v.company_id = ?
        GROUP BY v.id, v.voucher_no
        HAVING SUM(vl.debit_amount) != SUM(vl.credit_amount)
    `, companyID).Scan(&unbalanced).Error

    if err != nil {
        return err
    }

    for _, v := range unbalanced {
        result.Errors = append(result.Errors, ValidationError{
            Table:   "vouchers",
            Field:   "balance",
            Message: fmt.Sprintf("전표 %s: 차변(%s) ≠ 대변(%s)", v.VoucherNo, v.TotalDebit.String(), v.TotalCredit.String()),
        })
    }

    return nil
}

func (v *MigrationValidator) validateAccountCodes(ctx context.Context, companyID uuid.UUID, result *ValidationResult) error {
    var invalidCodes []string
    err := v.db.WithContext(ctx).Raw(`
        SELECT DISTINCT vl.account_code
        FROM staging_voucher_lines vl
        JOIN staging_vouchers v ON v.id = vl.voucher_id
        WHERE v.company_id = ?
        AND NOT EXISTS (
            SELECT 1 FROM accounts a
            WHERE a.company_id = v.company_id
            AND a.code = vl.account_code
        )
    `, companyID).Pluck("account_code", &invalidCodes).Error

    if err != nil {
        return err
    }

    for _, code := range invalidCodes {
        result.Errors = append(result.Errors, ValidationError{
            Table:   "voucher_lines",
            Field:   "account_code",
            Message: fmt.Sprintf("존재하지 않는 계정코드: %s", code),
        })
    }

    return nil
}
```

---

## 6. 롤백 전략

### 6.1 롤백 절차

```bash
#!/bin/bash
# scripts/rollback-migration.sh

set -e

MIGRATION_VERSION="${1:-}"
DB_URL="postgres://kerp:${DB_PASSWORD}@${DB_HOST}:5432/kerp?sslmode=require"

if [ -z "$MIGRATION_VERSION" ]; then
    echo "Usage: $0 <migration_version>"
    echo "Example: $0 000015"
    exit 1
fi

echo "=== 마이그레이션 롤백 시작 ==="
echo "Target version: $MIGRATION_VERSION"

# 현재 버전 확인
CURRENT_VERSION=$(migrate -path db/migrations -database "$DB_URL" version 2>&1 | grep -oE '[0-9]+')
echo "Current version: $CURRENT_VERSION"

if [ "$CURRENT_VERSION" -le "$MIGRATION_VERSION" ]; then
    echo "Error: Target version must be less than current version"
    exit 1
fi

# 백업 생성
BACKUP_FILE="/tmp/migration_rollback_$(date +%Y%m%d_%H%M%S).sql"
echo "Creating backup: $BACKUP_FILE"
pg_dump "$DB_URL" --schema-only > "$BACKUP_FILE"

# 롤백 실행
echo "Rolling back to version $MIGRATION_VERSION..."
migrate -path db/migrations -database "$DB_URL" goto "$MIGRATION_VERSION"

# 검증
NEW_VERSION=$(migrate -path db/migrations -database "$DB_URL" version 2>&1 | grep -oE '[0-9]+')
echo "New version: $NEW_VERSION"

if [ "$NEW_VERSION" != "$MIGRATION_VERSION" ]; then
    echo "Error: Rollback failed"
    exit 1
fi

echo "=== 롤백 완료 ==="
echo "Backup saved to: $BACKUP_FILE"
```

### 6.2 데이터 복구

```sql
-- 데이터 복구 절차

-- 1. 백업에서 복구
-- pg_restore -d kerp backup.dump

-- 2. 특정 테이블만 복구
-- pg_restore -d kerp --table=vouchers backup.dump

-- 3. Point-in-Time Recovery (PITR)
-- AWS RDS의 경우 특정 시점으로 복구 가능

-- 4. 논리적 복구 (staging 테이블 활용)
BEGIN;

-- 삭제된 데이터 복구
INSERT INTO vouchers
SELECT * FROM vouchers_backup
WHERE id NOT IN (SELECT id FROM vouchers);

-- 변경된 데이터 복구
UPDATE vouchers v
SET
    voucher_no = b.voucher_no,
    description = b.description,
    status = b.status
FROM vouchers_backup b
WHERE v.id = b.id
AND v.updated_at > b.updated_at;

COMMIT;
```

---

## 7. 모니터링 및 알림

### 7.1 마이그레이션 모니터링

```go
// internal/migration/monitor.go
package migration

type MigrationMonitor struct {
    db      *gorm.DB
    metrics MetricsClient
    alerts  AlertClient
}

type MigrationStatus struct {
    Version       int       `json:"version"`
    Status        string    `json:"status"` // pending, running, completed, failed
    StartedAt     time.Time `json:"started_at"`
    CompletedAt   *time.Time `json:"completed_at,omitempty"`
    Duration      string    `json:"duration,omitempty"`
    RowsAffected  int64     `json:"rows_affected"`
    ErrorMessage  string    `json:"error_message,omitempty"`
}

func (m *MigrationMonitor) TrackMigration(ctx context.Context, version int) (*MigrationStatus, error) {
    status := &MigrationStatus{
        Version:   version,
        Status:    "running",
        StartedAt: time.Now(),
    }

    // DB에 상태 기록
    if err := m.saveMigrationStatus(ctx, status); err != nil {
        return nil, err
    }

    // 메트릭 기록
    m.metrics.Increment("migration.started", map[string]string{
        "version": fmt.Sprintf("%d", version),
    })

    return status, nil
}

func (m *MigrationMonitor) CompleteMigration(ctx context.Context, status *MigrationStatus, err error) {
    now := time.Now()
    status.CompletedAt = &now
    status.Duration = now.Sub(status.StartedAt).String()

    if err != nil {
        status.Status = "failed"
        status.ErrorMessage = err.Error()

        // 실패 알림
        m.alerts.Send(Alert{
            Severity: "critical",
            Title:    "Migration Failed",
            Message:  fmt.Sprintf("Migration %d failed: %s", status.Version, err.Error()),
        })

        m.metrics.Increment("migration.failed", nil)
    } else {
        status.Status = "completed"
        m.metrics.Increment("migration.completed", nil)
    }

    m.saveMigrationStatus(ctx, status)
}
```

---

**문서 버전**: 1.0
**작성일**: 2025년 1월
**작성자**: K-ERP 개발팀
