# 10. 실시간 처리 설계

## 개요

K-ERP 시스템의 실시간 데이터 처리를 위한 Redis 캐싱 전략과 Go 고루틴 기반 동시성 처리 설계.

### 실시간 처리 요구사항

| 항목 | 요구사항 | 처리 방식 |
|------|----------|-----------|
| 계정 잔액 | 전표 입력 즉시 반영 | Redis + Write-through |
| 재고 수량 | 입출고 시 즉시 갱신 | Redis + 분산 락 |
| 대시보드 | 1초 이내 갱신 | Redis Pub/Sub |
| 전표 검증 | 차대변 실시간 검증 | 고루틴 병렬 처리 |
| 보고서 | 30초 캐시 | Redis TTL |

---

## 1. Redis 아키텍처

### 1.1 Redis 클러스터 구성

```yaml
# docker-compose.redis.yml
version: '3.8'

services:
  redis-master:
    image: redis:7-alpine
    command: >
      redis-server
      --maxmemory 2gb
      --maxmemory-policy allkeys-lru
      --appendonly yes
      --appendfsync everysec
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data

  redis-replica:
    image: redis:7-alpine
    command: redis-server --replicaof redis-master 6379
    depends_on:
      - redis-master

volumes:
  redis-data:
```

### 1.2 Redis 클라이언트 설정

```go
// internal/infrastructure/redis/client.go
package redis

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
)

type Config struct {
    Host         string        `env:"REDIS_HOST" envDefault:"localhost"`
    Port         int           `env:"REDIS_PORT" envDefault:"6379"`
    Password     string        `env:"REDIS_PASSWORD"`
    DB           int           `env:"REDIS_DB" envDefault:"0"`
    PoolSize     int           `env:"REDIS_POOL_SIZE" envDefault:"100"`
    MinIdleConns int           `env:"REDIS_MIN_IDLE" envDefault:"10"`
    DialTimeout  time.Duration `env:"REDIS_DIAL_TIMEOUT" envDefault:"5s"`
    ReadTimeout  time.Duration `env:"REDIS_READ_TIMEOUT" envDefault:"3s"`
    WriteTimeout time.Duration `env:"REDIS_WRITE_TIMEOUT" envDefault:"3s"`
}

type Client struct {
    rdb    *redis.Client
    config Config
}

func NewClient(cfg Config) (*Client, error) {
    rdb := redis.NewClient(&redis.Options{
        Addr:         fmt.Sprintf("%s:%d", cfg.Host, cfg.Port),
        Password:     cfg.Password,
        DB:           cfg.DB,
        PoolSize:     cfg.PoolSize,
        MinIdleConns: cfg.MinIdleConns,
        DialTimeout:  cfg.DialTimeout,
        ReadTimeout:  cfg.ReadTimeout,
        WriteTimeout: cfg.WriteTimeout,
    })

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := rdb.Ping(ctx).Err(); err != nil {
        return nil, fmt.Errorf("redis connection failed: %w", err)
    }

    return &Client{rdb: rdb, config: cfg}, nil
}

// Generic Get with JSON deserialization
func (c *Client) Get(ctx context.Context, key string, dest interface{}) error {
    val, err := c.rdb.Get(ctx, key).Result()
    if err != nil {
        return err
    }
    return json.Unmarshal([]byte(val), dest)
}

// Generic Set with JSON serialization
func (c *Client) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
    data, err := json.Marshal(value)
    if err != nil {
        return fmt.Errorf("marshal failed: %w", err)
    }
    return c.rdb.Set(ctx, key, data, ttl).Err()
}

// SetNX for distributed locking
func (c *Client) SetNX(ctx context.Context, key string, value interface{}, ttl time.Duration) (bool, error) {
    data, err := json.Marshal(value)
    if err != nil {
        return false, fmt.Errorf("marshal failed: %w", err)
    }
    return c.rdb.SetNX(ctx, key, data, ttl).Result()
}

func (c *Client) Del(ctx context.Context, keys ...string) error {
    return c.rdb.Del(ctx, keys...).Err()
}

func (c *Client) Exists(ctx context.Context, keys ...string) (int64, error) {
    return c.rdb.Exists(ctx, keys...).Result()
}

func (c *Client) Incr(ctx context.Context, key string) (int64, error) {
    return c.rdb.Incr(ctx, key).Result()
}

func (c *Client) IncrByFloat(ctx context.Context, key string, value float64) (float64, error) {
    return c.rdb.IncrByFloat(ctx, key, value).Result()
}

// Pub/Sub
func (c *Client) Publish(ctx context.Context, channel string, message interface{}) error {
    data, err := json.Marshal(message)
    if err != nil {
        return err
    }
    return c.rdb.Publish(ctx, channel, data).Err()
}

func (c *Client) Subscribe(ctx context.Context, channels ...string) *redis.PubSub {
    return c.rdb.Subscribe(ctx, channels...)
}

// Pipeline for batch operations
func (c *Client) Pipeline() redis.Pipeliner {
    return c.rdb.Pipeline()
}

// TxPipeline for transactions
func (c *Client) TxPipeline() redis.Pipeliner {
    return c.rdb.TxPipeline()
}

func (c *Client) Close() error {
    return c.rdb.Close()
}
```

---

## 2. 캐시 키 설계

### 2.1 키 네이밍 규칙

```go
// internal/infrastructure/redis/keys.go
package redis

import (
    "fmt"

    "github.com/google/uuid"
)

// 키 접두어 상수
const (
    PrefixBalance    = "balance"     // 계정 잔액
    PrefixInventory  = "inventory"   // 재고 수량
    PrefixSession    = "session"     // 사용자 세션
    PrefixLock       = "lock"        // 분산 락
    PrefixRate       = "rate"        // Rate Limiting
    PrefixReport     = "report"      // 보고서 캐시
    PrefixDashboard  = "dashboard"   // 대시보드
)

// KeyBuilder 캐시 키 생성기
type KeyBuilder struct {
    companyID uuid.UUID
}

func NewKeyBuilder(companyID uuid.UUID) *KeyBuilder {
    return &KeyBuilder{companyID: companyID}
}

// 계정 잔액 키: balance:{company_id}:{account_code}:{fiscal_year}
func (k *KeyBuilder) BalanceKey(accountCode string, fiscalYear int) string {
    return fmt.Sprintf("%s:%s:%s:%d",
        PrefixBalance, k.companyID, accountCode, fiscalYear)
}

// 재고 잔량 키: inventory:{company_id}:{item_id}:{warehouse_id}
func (k *KeyBuilder) InventoryKey(itemID, warehouseID uuid.UUID) string {
    return fmt.Sprintf("%s:%s:%s:%s",
        PrefixInventory, k.companyID, itemID, warehouseID)
}

// 사용자 세션 키: session:{session_id}
func SessionKey(sessionID string) string {
    return fmt.Sprintf("%s:%s", PrefixSession, sessionID)
}

// 분산 락 키: lock:{resource_type}:{resource_id}
func (k *KeyBuilder) LockKey(resourceType string, resourceID uuid.UUID) string {
    return fmt.Sprintf("%s:%s:%s:%s",
        PrefixLock, k.companyID, resourceType, resourceID)
}

// Rate Limit 키: rate:{company_id}:{user_id}:{endpoint}
func (k *KeyBuilder) RateLimitKey(userID uuid.UUID, endpoint string) string {
    return fmt.Sprintf("%s:%s:%s:%s",
        PrefixRate, k.companyID, userID, endpoint)
}

// 보고서 캐시 키: report:{company_id}:{report_type}:{params_hash}
func (k *KeyBuilder) ReportKey(reportType, paramsHash string) string {
    return fmt.Sprintf("%s:%s:%s:%s",
        PrefixReport, k.companyID, reportType, paramsHash)
}

// 대시보드 키: dashboard:{company_id}:{dashboard_type}
func (k *KeyBuilder) DashboardKey(dashboardType string) string {
    return fmt.Sprintf("%s:%s:%s",
        PrefixDashboard, k.companyID, dashboardType)
}

// 키 패턴 (삭제용)
func (k *KeyBuilder) BalancePattern() string {
    return fmt.Sprintf("%s:%s:*", PrefixBalance, k.companyID)
}

func (k *KeyBuilder) InventoryPattern() string {
    return fmt.Sprintf("%s:%s:*", PrefixInventory, k.companyID)
}
```

### 2.2 TTL 정책

```go
// internal/infrastructure/redis/ttl.go
package redis

import "time"

// TTL 상수 정의
const (
    // 실시간 데이터 (짧은 TTL)
    TTLBalance   = 5 * time.Minute   // 계정 잔액
    TTLInventory = 5 * time.Minute   // 재고 수량

    // 세션/인증 (중간 TTL)
    TTLSession      = 30 * time.Minute // 세션
    TTLRefreshToken = 7 * 24 * time.Hour // 리프레시 토큰

    // 보고서 (긴 TTL)
    TTLDashboard = 30 * time.Second   // 대시보드
    TTLReport    = 5 * time.Minute    // 보고서
    TTLMasterData = 1 * time.Hour     // 기준정보

    // 락 (매우 짧은 TTL)
    TTLLock = 30 * time.Second
)
```

---

## 3. 실시간 잔액 계산

### 3.1 계정 잔액 캐시 서비스

```go
// internal/service/balance/cache_service.go
package balance

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/google/uuid"
    "github.com/redis/go-redis/v9"

    redisclient "k-erp/internal/infrastructure/redis"
)

// AccountBalance 계정 잔액 구조체
type AccountBalance struct {
    AccountCode   string    `json:"account_code"`
    AccountName   string    `json:"account_name"`
    FiscalYear    int       `json:"fiscal_year"`
    DebitTotal    float64   `json:"debit_total"`    // 차변 합계
    CreditTotal   float64   `json:"credit_total"`   // 대변 합계
    Balance       float64   `json:"balance"`        // 잔액
    LastUpdated   time.Time `json:"last_updated"`
}

type BalanceCacheService struct {
    redis      *redisclient.Client
    repo       BalanceRepository
    keyBuilder *redisclient.KeyBuilder
    mu         sync.RWMutex
}

type BalanceRepository interface {
    GetAccountBalance(ctx context.Context, companyID uuid.UUID, accountCode string, fiscalYear int) (*AccountBalance, error)
    GetMultipleBalances(ctx context.Context, companyID uuid.UUID, accountCodes []string, fiscalYear int) ([]*AccountBalance, error)
}

func NewBalanceCacheService(
    redis *redisclient.Client,
    repo BalanceRepository,
    companyID uuid.UUID,
) *BalanceCacheService {
    return &BalanceCacheService{
        redis:      redis,
        repo:       repo,
        keyBuilder: redisclient.NewKeyBuilder(companyID),
    }
}

// GetBalance 잔액 조회 (캐시 우선)
func (s *BalanceCacheService) GetBalance(
    ctx context.Context,
    accountCode string,
    fiscalYear int,
) (*AccountBalance, error) {
    key := s.keyBuilder.BalanceKey(accountCode, fiscalYear)

    // 1. 캐시 조회
    var balance AccountBalance
    err := s.redis.Get(ctx, key, &balance)
    if err == nil {
        return &balance, nil
    }

    // 2. 캐시 미스 - DB 조회
    if err != redis.Nil {
        // Redis 에러 로깅 (하지만 계속 진행)
        fmt.Printf("Redis error: %v\n", err)
    }

    companyID := s.keyBuilder.CompanyID() // 가정: KeyBuilder에 CompanyID() 메서드 추가
    dbBalance, err := s.repo.GetAccountBalance(ctx, companyID, accountCode, fiscalYear)
    if err != nil {
        return nil, fmt.Errorf("failed to get balance from DB: %w", err)
    }

    // 3. 캐시 저장
    if err := s.redis.Set(ctx, key, dbBalance, redisclient.TTLBalance); err != nil {
        fmt.Printf("Failed to cache balance: %v\n", err)
    }

    return dbBalance, nil
}

// GetMultipleBalances 다중 잔액 조회 (파이프라인 사용)
func (s *BalanceCacheService) GetMultipleBalances(
    ctx context.Context,
    accountCodes []string,
    fiscalYear int,
) ([]*AccountBalance, error) {
    if len(accountCodes) == 0 {
        return []*AccountBalance{}, nil
    }

    // 키 생성
    keys := make([]string, len(accountCodes))
    for i, code := range accountCodes {
        keys[i] = s.keyBuilder.BalanceKey(code, fiscalYear)
    }

    // 파이프라인으로 일괄 조회
    pipe := s.redis.Pipeline()
    cmds := make([]*redis.StringCmd, len(keys))

    for i, key := range keys {
        cmds[i] = pipe.Get(ctx, key)
    }

    _, _ = pipe.Exec(ctx)

    // 결과 수집 및 캐시 미스 확인
    results := make([]*AccountBalance, 0, len(accountCodes))
    missingCodes := make([]string, 0)

    for i, cmd := range cmds {
        val, err := cmd.Result()
        if err == redis.Nil {
            missingCodes = append(missingCodes, accountCodes[i])
            continue
        }
        if err != nil {
            continue
        }

        var balance AccountBalance
        if json.Unmarshal([]byte(val), &balance) == nil {
            results = append(results, &balance)
        }
    }

    // 캐시 미스된 항목 DB 조회
    if len(missingCodes) > 0 {
        companyID := s.keyBuilder.CompanyID()
        dbBalances, err := s.repo.GetMultipleBalances(ctx, companyID, missingCodes, fiscalYear)
        if err != nil {
            return nil, err
        }

        // 캐시 저장 및 결과 추가
        for _, bal := range dbBalances {
            key := s.keyBuilder.BalanceKey(bal.AccountCode, fiscalYear)
            s.redis.Set(ctx, key, bal, redisclient.TTLBalance)
            results = append(results, bal)
        }
    }

    return results, nil
}

// UpdateBalance 잔액 갱신 (Write-through)
func (s *BalanceCacheService) UpdateBalance(
    ctx context.Context,
    accountCode string,
    fiscalYear int,
    debitDelta, creditDelta float64,
) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    key := s.keyBuilder.BalanceKey(accountCode, fiscalYear)

    // 현재 잔액 조회
    balance, err := s.GetBalance(ctx, accountCode, fiscalYear)
    if err != nil {
        return err
    }

    // 잔액 갱신
    balance.DebitTotal += debitDelta
    balance.CreditTotal += creditDelta
    balance.Balance = balance.DebitTotal - balance.CreditTotal
    balance.LastUpdated = time.Now()

    // 캐시 갱신
    return s.redis.Set(ctx, key, balance, redisclient.TTLBalance)
}

// InvalidateBalance 잔액 캐시 무효화
func (s *BalanceCacheService) InvalidateBalance(
    ctx context.Context,
    accountCode string,
    fiscalYear int,
) error {
    key := s.keyBuilder.BalanceKey(accountCode, fiscalYear)
    return s.redis.Del(ctx, key)
}

// InvalidateAllBalances 전체 잔액 캐시 무효화
func (s *BalanceCacheService) InvalidateAllBalances(ctx context.Context) error {
    pattern := s.keyBuilder.BalancePattern()

    var cursor uint64
    for {
        keys, nextCursor, err := s.redis.Scan(ctx, cursor, pattern, 100)
        if err != nil {
            return err
        }

        if len(keys) > 0 {
            if err := s.redis.Del(ctx, keys...); err != nil {
                return err
            }
        }

        cursor = nextCursor
        if cursor == 0 {
            break
        }
    }

    return nil
}
```

### 3.2 전표 저장 시 잔액 자동 갱신

```go
// internal/service/voucher/voucher_service.go
package voucher

import (
    "context"
    "fmt"
    "time"

    "github.com/google/uuid"

    "k-erp/internal/domain"
    "k-erp/internal/service/balance"
)

type VoucherService struct {
    repo          VoucherRepository
    balanceCache  *balance.BalanceCacheService
    eventPublisher EventPublisher
}

type EventPublisher interface {
    Publish(ctx context.Context, channel string, event interface{}) error
}

// VoucherCreatedEvent 전표 생성 이벤트
type VoucherCreatedEvent struct {
    VoucherID   uuid.UUID `json:"voucher_id"`
    CompanyID   uuid.UUID `json:"company_id"`
    VoucherDate time.Time `json:"voucher_date"`
    Lines       []VoucherLineEvent `json:"lines"`
    CreatedAt   time.Time `json:"created_at"`
}

type VoucherLineEvent struct {
    AccountCode string  `json:"account_code"`
    DebitAmount float64 `json:"debit_amount"`
    CreditAmount float64 `json:"credit_amount"`
}

// CreateVoucher 전표 생성 및 잔액 갱신
func (s *VoucherService) CreateVoucher(
    ctx context.Context,
    voucher *domain.Voucher,
) error {
    // 1. 차대변 균형 검증
    if err := s.validateBalance(voucher); err != nil {
        return err
    }

    // 2. DB 저장
    if err := s.repo.Create(ctx, voucher); err != nil {
        return fmt.Errorf("failed to create voucher: %w", err)
    }

    // 3. 잔액 캐시 갱신 (고루틴으로 비동기 처리)
    go s.updateBalancesAsync(context.Background(), voucher)

    // 4. 이벤트 발행 (대시보드 갱신용)
    event := s.buildVoucherCreatedEvent(voucher)
    if err := s.eventPublisher.Publish(ctx, "voucher:created", event); err != nil {
        // 이벤트 발행 실패는 로깅만 (전표 생성은 성공)
        fmt.Printf("Failed to publish event: %v\n", err)
    }

    return nil
}

func (s *VoucherService) validateBalance(voucher *domain.Voucher) error {
    var totalDebit, totalCredit float64

    for _, line := range voucher.Lines {
        totalDebit += line.DebitAmount
        totalCredit += line.CreditAmount
    }

    // 소수점 오차 허용 (0.01원)
    if abs(totalDebit-totalCredit) > 0.01 {
        return fmt.Errorf("debit and credit must be equal: debit=%f, credit=%f",
            totalDebit, totalCredit)
    }

    return nil
}

func (s *VoucherService) updateBalancesAsync(ctx context.Context, voucher *domain.Voucher) {
    fiscalYear := voucher.VoucherDate.Year()

    for _, line := range voucher.Lines {
        err := s.balanceCache.UpdateBalance(
            ctx,
            line.AccountCode,
            fiscalYear,
            line.DebitAmount,
            line.CreditAmount,
        )
        if err != nil {
            fmt.Printf("Failed to update balance cache for %s: %v\n",
                line.AccountCode, err)
        }
    }
}

func (s *VoucherService) buildVoucherCreatedEvent(voucher *domain.Voucher) VoucherCreatedEvent {
    lines := make([]VoucherLineEvent, len(voucher.Lines))
    for i, line := range voucher.Lines {
        lines[i] = VoucherLineEvent{
            AccountCode:  line.AccountCode,
            DebitAmount:  line.DebitAmount,
            CreditAmount: line.CreditAmount,
        }
    }

    return VoucherCreatedEvent{
        VoucherID:   voucher.ID,
        CompanyID:   voucher.CompanyID,
        VoucherDate: voucher.VoucherDate,
        Lines:       lines,
        CreatedAt:   time.Now(),
    }
}

func abs(x float64) float64 {
    if x < 0 {
        return -x
    }
    return x
}
```

---

## 4. 분산 락 (Distributed Lock)

### 4.1 Redis 기반 분산 락

```go
// internal/infrastructure/redis/lock.go
package redis

import (
    "context"
    "errors"
    "fmt"
    "time"

    "github.com/google/uuid"
)

var (
    ErrLockAcquireFailed = errors.New("failed to acquire lock")
    ErrLockNotHeld       = errors.New("lock not held")
)

// DistributedLock 분산 락 구조체
type DistributedLock struct {
    client     *Client
    key        string
    value      string // 락 소유자 식별용 UUID
    expiration time.Duration
}

// NewDistributedLock 분산 락 생성
func NewDistributedLock(client *Client, key string, expiration time.Duration) *DistributedLock {
    return &DistributedLock{
        client:     client,
        key:        key,
        value:      uuid.New().String(),
        expiration: expiration,
    }
}

// Acquire 락 획득
func (l *DistributedLock) Acquire(ctx context.Context) error {
    ok, err := l.client.SetNX(ctx, l.key, l.value, l.expiration)
    if err != nil {
        return fmt.Errorf("lock acquire error: %w", err)
    }
    if !ok {
        return ErrLockAcquireFailed
    }
    return nil
}

// AcquireWithRetry 재시도와 함께 락 획득
func (l *DistributedLock) AcquireWithRetry(
    ctx context.Context,
    maxRetries int,
    retryInterval time.Duration,
) error {
    for i := 0; i < maxRetries; i++ {
        err := l.Acquire(ctx)
        if err == nil {
            return nil
        }
        if !errors.Is(err, ErrLockAcquireFailed) {
            return err
        }

        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-time.After(retryInterval):
            // 재시도
        }
    }
    return ErrLockAcquireFailed
}

// Release 락 해제 (Lua 스크립트로 원자적 처리)
func (l *DistributedLock) Release(ctx context.Context) error {
    script := `
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("DEL", KEYS[1])
        else
            return 0
        end
    `

    result, err := l.client.rdb.Eval(ctx, script, []string{l.key}, l.value).Result()
    if err != nil {
        return fmt.Errorf("lock release error: %w", err)
    }

    if result.(int64) == 0 {
        return ErrLockNotHeld
    }

    return nil
}

// Extend 락 연장
func (l *DistributedLock) Extend(ctx context.Context, duration time.Duration) error {
    script := `
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("PEXPIRE", KEYS[1], ARGV[2])
        else
            return 0
        end
    `

    result, err := l.client.rdb.Eval(
        ctx, script, []string{l.key},
        l.value, duration.Milliseconds(),
    ).Result()
    if err != nil {
        return fmt.Errorf("lock extend error: %w", err)
    }

    if result.(int64) == 0 {
        return ErrLockNotHeld
    }

    return nil
}

// WithLock 락을 획득하고 작업 수행 후 해제
func WithLock(
    ctx context.Context,
    client *Client,
    key string,
    expiration time.Duration,
    fn func() error,
) error {
    lock := NewDistributedLock(client, key, expiration)

    if err := lock.AcquireWithRetry(ctx, 3, 100*time.Millisecond); err != nil {
        return fmt.Errorf("failed to acquire lock: %w", err)
    }
    defer lock.Release(ctx)

    return fn()
}
```

### 4.2 재고 동시성 제어

```go
// internal/service/inventory/inventory_service.go
package inventory

import (
    "context"
    "fmt"

    "github.com/google/uuid"

    redisclient "k-erp/internal/infrastructure/redis"
)

type InventoryService struct {
    repo       InventoryRepository
    redis      *redisclient.Client
    keyBuilder *redisclient.KeyBuilder
}

// AdjustStock 재고 조정 (락 사용)
func (s *InventoryService) AdjustStock(
    ctx context.Context,
    itemID uuid.UUID,
    warehouseID uuid.UUID,
    quantity float64, // 양수: 입고, 음수: 출고
) error {
    lockKey := s.keyBuilder.LockKey("inventory", itemID)

    return redisclient.WithLock(ctx, s.redis, lockKey, redisclient.TTLLock, func() error {
        // 현재 재고 조회
        current, err := s.repo.GetStock(ctx, itemID, warehouseID)
        if err != nil {
            return fmt.Errorf("failed to get current stock: %w", err)
        }

        // 재고 부족 검증 (출고 시)
        if quantity < 0 && current.Quantity+quantity < 0 {
            return fmt.Errorf("insufficient stock: current=%f, requested=%f",
                current.Quantity, -quantity)
        }

        // DB 업데이트
        newQuantity := current.Quantity + quantity
        if err := s.repo.UpdateStock(ctx, itemID, warehouseID, newQuantity); err != nil {
            return fmt.Errorf("failed to update stock: %w", err)
        }

        // 캐시 무효화
        cacheKey := s.keyBuilder.InventoryKey(itemID, warehouseID)
        s.redis.Del(ctx, cacheKey)

        return nil
    })
}

// TransferStock 창고 간 재고 이동
func (s *InventoryService) TransferStock(
    ctx context.Context,
    itemID uuid.UUID,
    fromWarehouse uuid.UUID,
    toWarehouse uuid.UUID,
    quantity float64,
) error {
    // 두 창고 모두 락 필요 (데드락 방지를 위해 정렬된 순서로)
    lockKey1 := s.keyBuilder.LockKey("inventory", itemID)

    return redisclient.WithLock(ctx, s.redis, lockKey1, redisclient.TTLLock, func() error {
        // 출고
        if err := s.adjustStockInternal(ctx, itemID, fromWarehouse, -quantity); err != nil {
            return fmt.Errorf("출고 실패: %w", err)
        }

        // 입고
        if err := s.adjustStockInternal(ctx, itemID, toWarehouse, quantity); err != nil {
            // 롤백 (출고 취소)
            s.adjustStockInternal(ctx, itemID, fromWarehouse, quantity)
            return fmt.Errorf("입고 실패: %w", err)
        }

        return nil
    })
}

func (s *InventoryService) adjustStockInternal(
    ctx context.Context,
    itemID uuid.UUID,
    warehouseID uuid.UUID,
    quantity float64,
) error {
    current, err := s.repo.GetStock(ctx, itemID, warehouseID)
    if err != nil {
        return err
    }

    if quantity < 0 && current.Quantity+quantity < 0 {
        return fmt.Errorf("재고 부족")
    }

    return s.repo.UpdateStock(ctx, itemID, warehouseID, current.Quantity+quantity)
}
```

---

## 5. Go 고루틴 패턴

### 5.1 Worker Pool 패턴

```go
// internal/infrastructure/worker/pool.go
package worker

import (
    "context"
    "fmt"
    "sync"
)

// Job 작업 인터페이스
type Job interface {
    Execute(ctx context.Context) error
    ID() string
}

// Result 작업 결과
type Result struct {
    JobID string
    Error error
}

// WorkerPool 워커 풀
type WorkerPool struct {
    workerCount int
    jobQueue    chan Job
    results     chan Result
    wg          sync.WaitGroup
    ctx         context.Context
    cancel      context.CancelFunc
}

// NewWorkerPool 워커 풀 생성
func NewWorkerPool(workerCount, queueSize int) *WorkerPool {
    ctx, cancel := context.WithCancel(context.Background())

    return &WorkerPool{
        workerCount: workerCount,
        jobQueue:    make(chan Job, queueSize),
        results:     make(chan Result, queueSize),
        ctx:         ctx,
        cancel:      cancel,
    }
}

// Start 워커 풀 시작
func (p *WorkerPool) Start() {
    for i := 0; i < p.workerCount; i++ {
        p.wg.Add(1)
        go p.worker(i)
    }
}

func (p *WorkerPool) worker(id int) {
    defer p.wg.Done()

    for {
        select {
        case <-p.ctx.Done():
            return
        case job, ok := <-p.jobQueue:
            if !ok {
                return
            }

            err := job.Execute(p.ctx)
            p.results <- Result{
                JobID: job.ID(),
                Error: err,
            }
        }
    }
}

// Submit 작업 제출
func (p *WorkerPool) Submit(job Job) error {
    select {
    case p.jobQueue <- job:
        return nil
    case <-p.ctx.Done():
        return p.ctx.Err()
    }
}

// Results 결과 채널 반환
func (p *WorkerPool) Results() <-chan Result {
    return p.results
}

// Stop 워커 풀 중지
func (p *WorkerPool) Stop() {
    p.cancel()
    close(p.jobQueue)
    p.wg.Wait()
    close(p.results)
}
```

### 5.2 배치 처리 예시 (급여 계산)

```go
// internal/service/payroll/batch_service.go
package payroll

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/google/uuid"

    "k-erp/internal/infrastructure/worker"
)

// PayrollCalculationJob 급여 계산 작업
type PayrollCalculationJob struct {
    id         string
    employeeID uuid.UUID
    month      time.Time
    calculator *PayrollCalculator
}

func NewPayrollCalculationJob(
    employeeID uuid.UUID,
    month time.Time,
    calculator *PayrollCalculator,
) *PayrollCalculationJob {
    return &PayrollCalculationJob{
        id:         fmt.Sprintf("payroll-%s-%s", employeeID, month.Format("2006-01")),
        employeeID: employeeID,
        month:      month,
        calculator: calculator,
    }
}

func (j *PayrollCalculationJob) ID() string {
    return j.id
}

func (j *PayrollCalculationJob) Execute(ctx context.Context) error {
    return j.calculator.CalculateForEmployee(ctx, j.employeeID, j.month)
}

// BatchPayrollService 배치 급여 처리 서비스
type BatchPayrollService struct {
    calculator   *PayrollCalculator
    employeeRepo EmployeeRepository
}

// ProcessMonthlyPayroll 월급여 일괄 처리
func (s *BatchPayrollService) ProcessMonthlyPayroll(
    ctx context.Context,
    companyID uuid.UUID,
    month time.Time,
) (*BatchResult, error) {
    // 1. 대상 직원 조회
    employees, err := s.employeeRepo.FindActiveByCompany(ctx, companyID)
    if err != nil {
        return nil, fmt.Errorf("failed to get employees: %w", err)
    }

    if len(employees) == 0 {
        return &BatchResult{Total: 0}, nil
    }

    // 2. 워커 풀 생성 (CPU 코어 수 * 2)
    workerCount := min(len(employees), 10)
    pool := worker.NewWorkerPool(workerCount, len(employees))
    pool.Start()

    // 3. 작업 제출
    for _, emp := range employees {
        job := NewPayrollCalculationJob(emp.ID, month, s.calculator)
        if err := pool.Submit(job); err != nil {
            pool.Stop()
            return nil, fmt.Errorf("failed to submit job: %w", err)
        }
    }

    // 4. 결과 수집
    result := &BatchResult{
        Total:    len(employees),
        Success:  0,
        Failed:   0,
        Errors:   make([]string, 0),
    }

    var wg sync.WaitGroup
    wg.Add(1)

    go func() {
        defer wg.Done()
        collected := 0
        for res := range pool.Results() {
            if res.Error != nil {
                result.Failed++
                result.Errors = append(result.Errors,
                    fmt.Sprintf("%s: %v", res.JobID, res.Error))
            } else {
                result.Success++
            }
            collected++
            if collected >= len(employees) {
                break
            }
        }
    }()

    wg.Wait()
    pool.Stop()

    return result, nil
}

type BatchResult struct {
    Total   int      `json:"total"`
    Success int      `json:"success"`
    Failed  int      `json:"failed"`
    Errors  []string `json:"errors,omitempty"`
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 5.3 Fan-Out/Fan-In 패턴 (보고서 생성)

```go
// internal/service/report/parallel_report.go
package report

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/google/uuid"
)

// ReportSection 보고서 섹션
type ReportSection struct {
    Name    string      `json:"name"`
    Data    interface{} `json:"data"`
    Error   string      `json:"error,omitempty"`
}

// FinancialReport 재무 보고서
type FinancialReport struct {
    GeneratedAt     time.Time        `json:"generated_at"`
    Period          string           `json:"period"`
    Sections        []ReportSection  `json:"sections"`
}

type ParallelReportService struct {
    balanceService    BalanceSheetService
    incomeService     IncomeStatementService
    cashFlowService   CashFlowService
    ratioService      FinancialRatioService
}

// GenerateFinancialReport 재무 보고서 병렬 생성
func (s *ParallelReportService) GenerateFinancialReport(
    ctx context.Context,
    companyID uuid.UUID,
    startDate, endDate time.Time,
) (*FinancialReport, error) {

    // 결과 수집 채널
    sectionChan := make(chan ReportSection, 4)

    // WaitGroup으로 완료 대기
    var wg sync.WaitGroup

    // Fan-Out: 4개 섹션 병렬 생성
    sections := []struct {
        name string
        fn   func(context.Context, uuid.UUID, time.Time, time.Time) (interface{}, error)
    }{
        {"재무상태표", s.generateBalanceSheet},
        {"손익계산서", s.generateIncomeStatement},
        {"현금흐름표", s.generateCashFlow},
        {"재무비율", s.generateFinancialRatios},
    }

    for _, section := range sections {
        wg.Add(1)
        go func(name string, fn func(context.Context, uuid.UUID, time.Time, time.Time) (interface{}, error)) {
            defer wg.Done()

            data, err := fn(ctx, companyID, startDate, endDate)
            result := ReportSection{Name: name}

            if err != nil {
                result.Error = err.Error()
            } else {
                result.Data = data
            }

            sectionChan <- result
        }(section.name, section.fn)
    }

    // 채널 닫기 고루틴
    go func() {
        wg.Wait()
        close(sectionChan)
    }()

    // Fan-In: 결과 수집
    report := &FinancialReport{
        GeneratedAt: time.Now(),
        Period:      fmt.Sprintf("%s ~ %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
        Sections:    make([]ReportSection, 0, 4),
    }

    for section := range sectionChan {
        report.Sections = append(report.Sections, section)
    }

    return report, nil
}

func (s *ParallelReportService) generateBalanceSheet(
    ctx context.Context,
    companyID uuid.UUID,
    startDate, endDate time.Time,
) (interface{}, error) {
    return s.balanceService.Generate(ctx, companyID, endDate)
}

func (s *ParallelReportService) generateIncomeStatement(
    ctx context.Context,
    companyID uuid.UUID,
    startDate, endDate time.Time,
) (interface{}, error) {
    return s.incomeService.Generate(ctx, companyID, startDate, endDate)
}

func (s *ParallelReportService) generateCashFlow(
    ctx context.Context,
    companyID uuid.UUID,
    startDate, endDate time.Time,
) (interface{}, error) {
    return s.cashFlowService.Generate(ctx, companyID, startDate, endDate)
}

func (s *ParallelReportService) generateFinancialRatios(
    ctx context.Context,
    companyID uuid.UUID,
    startDate, endDate time.Time,
) (interface{}, error) {
    return s.ratioService.Calculate(ctx, companyID, endDate)
}
```

---

## 6. Pub/Sub 실시간 알림

### 6.1 이벤트 발행자

```go
// internal/infrastructure/pubsub/publisher.go
package pubsub

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    redisclient "k-erp/internal/infrastructure/redis"
)

// 이벤트 채널 상수
const (
    ChannelVoucherCreated     = "events:voucher:created"
    ChannelVoucherApproved    = "events:voucher:approved"
    ChannelBalanceUpdated     = "events:balance:updated"
    ChannelInventoryChanged   = "events:inventory:changed"
    ChannelPayrollProcessed   = "events:payroll:processed"
    ChannelNotification       = "events:notification"
)

// Event 기본 이벤트 구조체
type Event struct {
    ID        string      `json:"id"`
    Type      string      `json:"type"`
    Timestamp time.Time   `json:"timestamp"`
    CompanyID string      `json:"company_id"`
    Payload   interface{} `json:"payload"`
}

// Publisher 이벤트 발행자
type Publisher struct {
    redis *redisclient.Client
}

func NewPublisher(redis *redisclient.Client) *Publisher {
    return &Publisher{redis: redis}
}

// Publish 이벤트 발행
func (p *Publisher) Publish(ctx context.Context, channel string, payload interface{}) error {
    event := Event{
        ID:        fmt.Sprintf("%d", time.Now().UnixNano()),
        Type:      channel,
        Timestamp: time.Now(),
        Payload:   payload,
    }

    data, err := json.Marshal(event)
    if err != nil {
        return fmt.Errorf("failed to marshal event: %w", err)
    }

    return p.redis.Publish(ctx, channel, data)
}

// PublishWithCompany 회사 ID 포함 이벤트 발행
func (p *Publisher) PublishWithCompany(
    ctx context.Context,
    channel string,
    companyID string,
    payload interface{},
) error {
    event := Event{
        ID:        fmt.Sprintf("%d", time.Now().UnixNano()),
        Type:      channel,
        Timestamp: time.Now(),
        CompanyID: companyID,
        Payload:   payload,
    }

    data, err := json.Marshal(event)
    if err != nil {
        return fmt.Errorf("failed to marshal event: %w", err)
    }

    // 회사별 채널로 발행
    companyChannel := fmt.Sprintf("%s:%s", channel, companyID)
    return p.redis.Publish(ctx, companyChannel, data)
}
```

### 6.2 이벤트 구독자

```go
// internal/infrastructure/pubsub/subscriber.go
package pubsub

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/redis/go-redis/v9"

    redisclient "k-erp/internal/infrastructure/redis"
)

// EventHandler 이벤트 핸들러 함수 타입
type EventHandler func(ctx context.Context, event *Event) error

// Subscriber 이벤트 구독자
type Subscriber struct {
    redis    *redisclient.Client
    handlers map[string][]EventHandler
    pubsub   *redis.PubSub
}

func NewSubscriber(redis *redisclient.Client) *Subscriber {
    return &Subscriber{
        redis:    redis,
        handlers: make(map[string][]EventHandler),
    }
}

// Subscribe 채널 구독
func (s *Subscriber) Subscribe(channel string, handler EventHandler) {
    if s.handlers[channel] == nil {
        s.handlers[channel] = make([]EventHandler, 0)
    }
    s.handlers[channel] = append(s.handlers[channel], handler)
}

// Start 구독 시작
func (s *Subscriber) Start(ctx context.Context) error {
    channels := make([]string, 0, len(s.handlers))
    for ch := range s.handlers {
        channels = append(channels, ch)
    }

    if len(channels) == 0 {
        return nil
    }

    s.pubsub = s.redis.Subscribe(ctx, channels...)

    go s.listen(ctx)

    return nil
}

func (s *Subscriber) listen(ctx context.Context) {
    ch := s.pubsub.Channel()

    for {
        select {
        case <-ctx.Done():
            return
        case msg := <-ch:
            if msg == nil {
                continue
            }

            var event Event
            if err := json.Unmarshal([]byte(msg.Payload), &event); err != nil {
                fmt.Printf("Failed to unmarshal event: %v\n", err)
                continue
            }

            handlers := s.handlers[msg.Channel]
            for _, handler := range handlers {
                if err := handler(ctx, &event); err != nil {
                    fmt.Printf("Handler error for %s: %v\n", msg.Channel, err)
                }
            }
        }
    }
}

// Stop 구독 중지
func (s *Subscriber) Stop() error {
    if s.pubsub != nil {
        return s.pubsub.Close()
    }
    return nil
}
```

### 6.3 WebSocket을 통한 실시간 알림

```go
// internal/handler/websocket/handler.go
package websocket

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "sync"

    "github.com/gin-gonic/gin"
    "github.com/gorilla/websocket"

    "k-erp/internal/infrastructure/pubsub"
)

var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
    CheckOrigin: func(r *http.Request) bool {
        // 프로덕션에서는 Origin 검증 필요
        return true
    },
}

// Client WebSocket 클라이언트
type Client struct {
    conn      *websocket.Conn
    companyID string
    userID    string
    send      chan []byte
}

// Hub WebSocket 허브
type Hub struct {
    clients    map[string]map[*Client]bool // companyID -> clients
    register   chan *Client
    unregister chan *Client
    broadcast  chan *BroadcastMessage
    mu         sync.RWMutex
}

type BroadcastMessage struct {
    CompanyID string
    Data      []byte
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[string]map[*Client]bool),
        register:   make(chan *Client),
        unregister: make(chan *Client),
        broadcast:  make(chan *BroadcastMessage, 256),
    }
}

// Run 허브 실행
func (h *Hub) Run(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return

        case client := <-h.register:
            h.mu.Lock()
            if h.clients[client.companyID] == nil {
                h.clients[client.companyID] = make(map[*Client]bool)
            }
            h.clients[client.companyID][client] = true
            h.mu.Unlock()

        case client := <-h.unregister:
            h.mu.Lock()
            if clients, ok := h.clients[client.companyID]; ok {
                if _, ok := clients[client]; ok {
                    delete(clients, client)
                    close(client.send)
                }
            }
            h.mu.Unlock()

        case msg := <-h.broadcast:
            h.mu.RLock()
            clients := h.clients[msg.CompanyID]
            for client := range clients {
                select {
                case client.send <- msg.Data:
                default:
                    close(client.send)
                    delete(clients, client)
                }
            }
            h.mu.RUnlock()
        }
    }
}

// BroadcastToCompany 특정 회사에 메시지 브로드캐스트
func (h *Hub) BroadcastToCompany(companyID string, data interface{}) error {
    jsonData, err := json.Marshal(data)
    if err != nil {
        return err
    }

    h.broadcast <- &BroadcastMessage{
        CompanyID: companyID,
        Data:      jsonData,
    }

    return nil
}

// WebSocketHandler WebSocket 핸들러
type WebSocketHandler struct {
    hub *Hub
}

func NewWebSocketHandler(hub *Hub) *WebSocketHandler {
    return &WebSocketHandler{hub: hub}
}

// HandleWebSocket WebSocket 연결 처리
func (h *WebSocketHandler) HandleWebSocket(c *gin.Context) {
    companyID := c.GetString("company_id")
    userID := c.GetString("user_id")

    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        fmt.Printf("WebSocket upgrade failed: %v\n", err)
        return
    }

    client := &Client{
        conn:      conn,
        companyID: companyID,
        userID:    userID,
        send:      make(chan []byte, 256),
    }

    h.hub.register <- client

    go client.writePump()
    go client.readPump(h.hub)
}

func (c *Client) readPump(hub *Hub) {
    defer func() {
        hub.unregister <- c
        c.conn.Close()
    }()

    for {
        _, _, err := c.conn.ReadMessage()
        if err != nil {
            break
        }
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()

    for {
        message, ok := <-c.send
        if !ok {
            c.conn.WriteMessage(websocket.CloseMessage, []byte{})
            return
        }

        if err := c.conn.WriteMessage(websocket.TextMessage, message); err != nil {
            return
        }
    }
}

// SetupEventSubscription 이벤트 구독 설정
func SetupEventSubscription(hub *Hub, subscriber *pubsub.Subscriber) {
    // 전표 생성 이벤트 구독
    subscriber.Subscribe(pubsub.ChannelVoucherCreated, func(ctx context.Context, event *pubsub.Event) error {
        return hub.BroadcastToCompany(event.CompanyID, map[string]interface{}{
            "type":    "voucher_created",
            "payload": event.Payload,
        })
    })

    // 잔액 변경 이벤트 구독
    subscriber.Subscribe(pubsub.ChannelBalanceUpdated, func(ctx context.Context, event *pubsub.Event) error {
        return hub.BroadcastToCompany(event.CompanyID, map[string]interface{}{
            "type":    "balance_updated",
            "payload": event.Payload,
        })
    })

    // 재고 변경 이벤트 구독
    subscriber.Subscribe(pubsub.ChannelInventoryChanged, func(ctx context.Context, event *pubsub.Event) error {
        return hub.BroadcastToCompany(event.CompanyID, map[string]interface{}{
            "type":    "inventory_changed",
            "payload": event.Payload,
        })
    })
}
```

---

## 7. 캐시 무효화 전략

### 7.1 이벤트 기반 캐시 무효화

```go
// internal/service/cache/invalidator.go
package cache

import (
    "context"
    "fmt"

    "github.com/google/uuid"

    redisclient "k-erp/internal/infrastructure/redis"
    "k-erp/internal/infrastructure/pubsub"
)

// CacheInvalidator 캐시 무효화 서비스
type CacheInvalidator struct {
    redis      *redisclient.Client
    subscriber *pubsub.Subscriber
}

func NewCacheInvalidator(
    redis *redisclient.Client,
    subscriber *pubsub.Subscriber,
) *CacheInvalidator {
    return &CacheInvalidator{
        redis:      redis,
        subscriber: subscriber,
    }
}

// Setup 캐시 무효화 이벤트 구독 설정
func (c *CacheInvalidator) Setup() {
    // 전표 생성 시 잔액 캐시 무효화
    c.subscriber.Subscribe(pubsub.ChannelVoucherCreated, c.handleVoucherCreated)

    // 재고 변경 시 재고 캐시 무효화
    c.subscriber.Subscribe(pubsub.ChannelInventoryChanged, c.handleInventoryChanged)
}

func (c *CacheInvalidator) handleVoucherCreated(ctx context.Context, event *pubsub.Event) error {
    companyID, err := uuid.Parse(event.CompanyID)
    if err != nil {
        return fmt.Errorf("invalid company ID: %w", err)
    }

    keyBuilder := redisclient.NewKeyBuilder(companyID)

    // 전표에 포함된 계정의 잔액 캐시 무효화
    payload, ok := event.Payload.(map[string]interface{})
    if !ok {
        return nil
    }

    lines, ok := payload["lines"].([]interface{})
    if !ok {
        return nil
    }

    for _, line := range lines {
        lineMap, ok := line.(map[string]interface{})
        if !ok {
            continue
        }

        accountCode, _ := lineMap["account_code"].(string)
        fiscalYear := int(payload["fiscal_year"].(float64))

        key := keyBuilder.BalanceKey(accountCode, fiscalYear)
        if err := c.redis.Del(ctx, key); err != nil {
            fmt.Printf("Failed to invalidate balance cache: %v\n", err)
        }
    }

    // 대시보드 캐시도 무효화
    dashboardKey := keyBuilder.DashboardKey("financial")
    c.redis.Del(ctx, dashboardKey)

    return nil
}

func (c *CacheInvalidator) handleInventoryChanged(ctx context.Context, event *pubsub.Event) error {
    companyID, err := uuid.Parse(event.CompanyID)
    if err != nil {
        return fmt.Errorf("invalid company ID: %w", err)
    }

    keyBuilder := redisclient.NewKeyBuilder(companyID)

    payload, ok := event.Payload.(map[string]interface{})
    if !ok {
        return nil
    }

    itemID, _ := uuid.Parse(payload["item_id"].(string))
    warehouseID, _ := uuid.Parse(payload["warehouse_id"].(string))

    key := keyBuilder.InventoryKey(itemID, warehouseID)
    return c.redis.Del(ctx, key)
}
```

### 7.2 TTL 기반 자동 만료

```go
// internal/service/cache/ttl_policy.go
package cache

import (
    "time"
)

// CacheTTLPolicy TTL 정책
type CacheTTLPolicy struct {
    defaultTTL time.Duration
    policies   map[string]time.Duration
}

func NewCacheTTLPolicy() *CacheTTLPolicy {
    return &CacheTTLPolicy{
        defaultTTL: 5 * time.Minute,
        policies: map[string]time.Duration{
            // 실시간 데이터 (짧은 TTL)
            "balance":   5 * time.Minute,
            "inventory": 5 * time.Minute,
            "dashboard": 30 * time.Second,

            // 준실시간 데이터 (중간 TTL)
            "report":     5 * time.Minute,
            "statistics": 10 * time.Minute,

            // 정적 데이터 (긴 TTL)
            "master_data": 1 * time.Hour,
            "code_table":  24 * time.Hour,
            "company_info": 1 * time.Hour,

            // 세션 관련
            "session":       30 * time.Minute,
            "refresh_token": 7 * 24 * time.Hour,
        },
    }
}

func (p *CacheTTLPolicy) GetTTL(cacheType string) time.Duration {
    if ttl, ok := p.policies[cacheType]; ok {
        return ttl
    }
    return p.defaultTTL
}
```

---

## 8. 성능 최적화

### 8.1 Redis 파이프라인 활용

```go
// internal/service/dashboard/dashboard_service.go
package dashboard

import (
    "context"
    "time"

    "github.com/google/uuid"
    "github.com/redis/go-redis/v9"

    redisclient "k-erp/internal/infrastructure/redis"
)

type DashboardService struct {
    redis      *redisclient.Client
    keyBuilder *redisclient.KeyBuilder
}

// DashboardData 대시보드 데이터
type DashboardData struct {
    SalesTotal      float64   `json:"sales_total"`
    PurchaseTotal   float64   `json:"purchase_total"`
    CashBalance     float64   `json:"cash_balance"`
    AccountsReceivable float64 `json:"accounts_receivable"`
    AccountsPayable float64   `json:"accounts_payable"`
    UpdatedAt       time.Time `json:"updated_at"`
}

// GetDashboardData 대시보드 데이터 조회 (파이프라인 사용)
func (s *DashboardService) GetDashboardData(ctx context.Context, fiscalYear int) (*DashboardData, error) {
    // 필요한 계정 코드
    accounts := []string{
        "4100", // 매출
        "5100", // 매입
        "1101", // 현금
        "1201", // 외상매출금
        "2101", // 외상매입금
    }

    // 파이프라인으로 일괄 조회
    pipe := s.redis.Pipeline()
    cmds := make(map[string]*redis.StringCmd)

    for _, code := range accounts {
        key := s.keyBuilder.BalanceKey(code, fiscalYear)
        cmds[code] = pipe.Get(ctx, key)
    }

    _, err := pipe.Exec(ctx)
    if err != nil && err != redis.Nil {
        return nil, err
    }

    // 결과 매핑
    data := &DashboardData{
        UpdatedAt: time.Now(),
    }

    if val, err := cmds["4100"].Float64(); err == nil {
        data.SalesTotal = val
    }
    if val, err := cmds["5100"].Float64(); err == nil {
        data.PurchaseTotal = val
    }
    if val, err := cmds["1101"].Float64(); err == nil {
        data.CashBalance = val
    }
    if val, err := cmds["1201"].Float64(); err == nil {
        data.AccountsReceivable = val
    }
    if val, err := cmds["2101"].Float64(); err == nil {
        data.AccountsPayable = val
    }

    return data, nil
}
```

### 8.2 벌크 캐시 워밍

```go
// internal/service/cache/warmer.go
package cache

import (
    "context"
    "fmt"
    "sync"

    "github.com/google/uuid"

    redisclient "k-erp/internal/infrastructure/redis"
)

// CacheWarmer 캐시 워밍 서비스
type CacheWarmer struct {
    redis        *redisclient.Client
    balanceRepo  BalanceRepository
    inventoryRepo InventoryRepository
}

// WarmCompanyCache 회사별 캐시 워밍
func (w *CacheWarmer) WarmCompanyCache(ctx context.Context, companyID uuid.UUID) error {
    keyBuilder := redisclient.NewKeyBuilder(companyID)

    var wg sync.WaitGroup
    errChan := make(chan error, 2)

    // 잔액 캐시 워밍
    wg.Add(1)
    go func() {
        defer wg.Done()
        if err := w.warmBalanceCache(ctx, companyID, keyBuilder); err != nil {
            errChan <- fmt.Errorf("balance cache warming failed: %w", err)
        }
    }()

    // 재고 캐시 워밍
    wg.Add(1)
    go func() {
        defer wg.Done()
        if err := w.warmInventoryCache(ctx, companyID, keyBuilder); err != nil {
            errChan <- fmt.Errorf("inventory cache warming failed: %w", err)
        }
    }()

    wg.Wait()
    close(errChan)

    // 에러 수집
    var errors []error
    for err := range errChan {
        errors = append(errors, err)
    }

    if len(errors) > 0 {
        return fmt.Errorf("cache warming errors: %v", errors)
    }

    return nil
}

func (w *CacheWarmer) warmBalanceCache(
    ctx context.Context,
    companyID uuid.UUID,
    keyBuilder *redisclient.KeyBuilder,
) error {
    fiscalYear := time.Now().Year()

    balances, err := w.balanceRepo.GetAllBalances(ctx, companyID, fiscalYear)
    if err != nil {
        return err
    }

    pipe := w.redis.TxPipeline()

    for _, bal := range balances {
        key := keyBuilder.BalanceKey(bal.AccountCode, fiscalYear)
        data, _ := json.Marshal(bal)
        pipe.Set(ctx, key, data, redisclient.TTLBalance)
    }

    _, err = pipe.Exec(ctx)
    return err
}

func (w *CacheWarmer) warmInventoryCache(
    ctx context.Context,
    companyID uuid.UUID,
    keyBuilder *redisclient.KeyBuilder,
) error {
    stocks, err := w.inventoryRepo.GetAllStocks(ctx, companyID)
    if err != nil {
        return err
    }

    pipe := w.redis.TxPipeline()

    for _, stock := range stocks {
        key := keyBuilder.InventoryKey(stock.ItemID, stock.WarehouseID)
        data, _ := json.Marshal(stock)
        pipe.Set(ctx, key, data, redisclient.TTLInventory)
    }

    _, err = pipe.Exec(ctx)
    return err
}
```

---

## 9. 모니터링

### 9.1 Redis 메트릭

```go
// internal/infrastructure/redis/metrics.go
package redis

import (
    "context"
    "time"

    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    redisOperations = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "redis_operations_total",
            Help: "Total Redis operations",
        },
        []string{"operation", "status"},
    )

    redisLatency = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "redis_operation_latency_seconds",
            Help:    "Redis operation latency",
            Buckets: []float64{.001, .005, .01, .025, .05, .1, .25, .5, 1},
        },
        []string{"operation"},
    )

    cacheHitRatio = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "cache_requests_total",
            Help: "Cache hit/miss counter",
        },
        []string{"type", "result"}, // result: hit or miss
    )
)

// WithMetrics 메트릭 수집 래퍼
func WithMetrics(operation string, fn func() error) error {
    start := time.Now()
    err := fn()
    duration := time.Since(start).Seconds()

    status := "success"
    if err != nil {
        status = "error"
    }

    redisOperations.WithLabelValues(operation, status).Inc()
    redisLatency.WithLabelValues(operation).Observe(duration)

    return err
}

// RecordCacheHit 캐시 히트 기록
func RecordCacheHit(cacheType string) {
    cacheHitRatio.WithLabelValues(cacheType, "hit").Inc()
}

// RecordCacheMiss 캐시 미스 기록
func RecordCacheMiss(cacheType string) {
    cacheHitRatio.WithLabelValues(cacheType, "miss").Inc()
}
```

### 9.2 고루틴 모니터링

```go
// internal/infrastructure/monitor/goroutine.go
package monitor

import (
    "runtime"
    "time"

    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    goroutineCount = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "go_goroutines_active",
            Help: "Number of active goroutines",
        },
    )

    workerPoolSize = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "worker_pool_size",
            Help: "Worker pool size",
        },
        []string{"pool_name"},
    )

    workerPoolJobs = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "worker_pool_pending_jobs",
            Help: "Number of pending jobs in worker pool",
        },
        []string{"pool_name"},
    )
)

// StartGoroutineMonitor 고루틴 모니터 시작
func StartGoroutineMonitor(interval time.Duration) {
    go func() {
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for range ticker.C {
            goroutineCount.Set(float64(runtime.NumGoroutine()))
        }
    }()
}

// UpdateWorkerPoolMetrics 워커 풀 메트릭 업데이트
func UpdateWorkerPoolMetrics(poolName string, size, pendingJobs int) {
    workerPoolSize.WithLabelValues(poolName).Set(float64(size))
    workerPoolJobs.WithLabelValues(poolName).Set(float64(pendingJobs))
}
```

---

## 10. 체크리스트

### 구현 체크리스트

- [ ] Redis 클러스터 구성
- [ ] 캐시 키 네이밍 규칙 적용
- [ ] TTL 정책 구현
- [ ] 분산 락 구현 (재고, 전표)
- [ ] 실시간 잔액 캐시 서비스
- [ ] Worker Pool 구현
- [ ] Pub/Sub 이벤트 시스템
- [ ] WebSocket 실시간 알림
- [ ] 캐시 무효화 전략
- [ ] 캐시 워밍 서비스
- [ ] Prometheus 메트릭 연동

### 성능 목표

| 항목 | 목표 | 측정 방법 |
|------|------|----------|
| 캐시 히트율 | > 90% | Prometheus |
| Redis 응답시간 | < 5ms (p99) | Histogram |
| 잔액 조회 | < 10ms | API Latency |
| 고루틴 수 | < 1000 | runtime.NumGoroutine |
| 워커 풀 처리량 | > 100 jobs/sec | Counter |
