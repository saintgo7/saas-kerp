# K-ERP v0.2 - 세금계산서 연동 설계

**문서 버전**: 0.2.0
**작성일**: 2026-01-16
**상태**: 검토 대기

---

## 목차

1. [개요](#1-개요)
2. [Provider 아키텍처](#2-provider-아키텍처)
3. [홈택스 스크래핑 (Python)](#3-홈택스-스크래핑-python)
4. [국세청 API (Go)](#4-국세청-api-go)
5. [Popbill ASP (Go)](#5-popbill-asp-go)
6. [Provider 선택 로직](#6-provider-선택-로직)
7. [에러 처리](#7-에러-처리)

---

## 1. 개요

### 1.1 설계 목표

1. **비용 최소화**: 무료 방식 우선 사용 (스크래핑 → NTS API → Popbill)
2. **안정성 보장**: Fallback 체인으로 발행 실패 방지
3. **유연성**: Provider 추가/제거 용이한 플러그인 구조

### 1.2 Provider 우선순위

| 우선순위 | Provider | 비용 | 구현 언어 | 특징 |
|----------|----------|------|----------|------|
| 1 | 홈택스 스크래핑 | 무료 | Python | 공인인증서 필요, 불안정 가능성 |
| 2 | 국세청 API | 무료 | Go | 공식 API, 안정적 |
| 3 | Popbill ASP | 유료 (건당 500원) | Go | 가장 안정적, SLA 보장 |

### 1.3 예상 비용 절감

```
월 10,000건 발행 기준:

시나리오 A (Popbill만 사용):
  10,000건 × 500원 = 5,000,000원/월

시나리오 B (하이브리드):
  - 스크래핑 성공 (70%): 7,000건 × 0원 = 0원
  - NTS API 성공 (20%): 2,000건 × 0원 = 0원
  - Popbill (10%): 1,000건 × 500원 = 500,000원/월

절감액: 4,500,000원/월 (90% 절감)
```

---

## 2. Provider 아키텍처

### 2.1 클래스 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Invoice Provider Architecture                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────┐      │
│  │                    <<interface>>                               │      │
│  │                   InvoiceProvider                              │      │
│  ├───────────────────────────────────────────────────────────────┤      │
│  │  + Name() string                                               │      │
│  │  + Priority() int                                              │      │
│  │  + IsAvailable(ctx) bool                                       │      │
│  │  + Issue(ctx, req) (*IssueResponse, error)                     │      │
│  │  + Search(ctx, req) ([]*Invoice, error)                        │      │
│  │  + GetDetail(ctx, ntsNum) (*Invoice, error)                    │      │
│  └───────────────────────────────────────────────────────────────┘      │
│                              △                                          │
│                              │                                          │
│          ┌───────────────────┼───────────────────┐                      │
│          │                   │                   │                      │
│  ┌───────┴───────┐   ┌───────┴───────┐   ┌───────┴───────┐             │
│  │ ScraperProvider│   │ NTSAPIProvider│   │ PopbillProvider│             │
│  │ (gRPC Client) │   │    (Go)       │   │     (Go)       │             │
│  │ Priority: 1   │   │ Priority: 2   │   │  Priority: 3   │             │
│  └───────────────┘   └───────────────┘   └───────────────┘             │
│          │                                                              │
│          │ gRPC                                                         │
│          ▼                                                              │
│  ┌───────────────┐                                                      │
│  │ Python        │                                                      │
│  │ Tax Scraper   │                                                      │
│  │ Service       │                                                      │
│  └───────────────┘                                                      │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────┐      │
│  │                    ProviderChain                               │      │
│  ├───────────────────────────────────────────────────────────────┤      │
│  │  - providers: []InvoiceProvider                                │      │
│  │  + Issue(ctx, req) (*IssueResponse, error)                     │      │
│  │  + Search(ctx, req) ([]*Invoice, error)                        │      │
│  └───────────────────────────────────────────────────────────────┘      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Go 인터페이스 정의

```go
// internal/provider/invoice/interface.go
package invoice

import (
    "context"
    "time"

    "github.com/google/uuid"
    "github.com/kerp/internal/domain"
)

// Provider 세금계산서 Provider 인터페이스
type Provider interface {
    // Name Provider 이름 반환
    Name() string

    // Priority 우선순위 반환 (낮을수록 우선)
    Priority() int

    // IsAvailable 사용 가능 여부 확인
    IsAvailable(ctx context.Context) bool

    // Issue 세금계산서 발행
    Issue(ctx context.Context, req *IssueRequest) (*IssueResponse, error)

    // Search 세금계산서 목록 조회
    Search(ctx context.Context, req *SearchRequest) (*SearchResponse, error)

    // GetDetail 세금계산서 상세 조회
    GetDetail(ctx context.Context, ntsConfirmNum string) (*domain.Invoice, error)

    // Cancel 세금계산서 취소 (가능한 경우)
    Cancel(ctx context.Context, ntsConfirmNum string, reason string) error
}

// IssueRequest 발행 요청
type IssueRequest struct {
    CompanyID uuid.UUID `json:"company_id"`

    // 발행 정보
    IssueType string    `json:"issue_type"` // "normal" | "reverse"
    IssueDate time.Time `json:"issue_date"`

    // 공급자 정보
    Supplier SupplierInfo `json:"supplier"`

    // 공급받는자 정보
    Buyer BuyerInfo `json:"buyer"`

    // 금액
    SupplyAmount int64 `json:"supply_amount"` // 공급가액
    TaxAmount    int64 `json:"tax_amount"`    // 세액
    TotalAmount  int64 `json:"total_amount"`  // 합계

    // 품목
    Items []InvoiceItem `json:"items"`

    // 비고
    Remarks string `json:"remarks,omitempty"`
}

// SupplierInfo 공급자 정보
type SupplierInfo struct {
    BRN         string `json:"brn"`          // 사업자등록번호 (10자리)
    CorpNum     string `json:"corp_num"`     // 법인등록번호 (선택)
    Name        string `json:"name"`         // 상호
    CEOName     string `json:"ceo_name"`     // 대표자명
    Address     string `json:"address"`      // 주소
    BusinessType string `json:"business_type"` // 업태
    BusinessItem string `json:"business_item"` // 종목
    Email       string `json:"email"`        // 이메일
    Phone       string `json:"phone"`        // 전화번호
}

// BuyerInfo 공급받는자 정보
type BuyerInfo struct {
    BRN         string `json:"brn"`
    CorpNum     string `json:"corp_num"`
    Name        string `json:"name"`
    CEOName     string `json:"ceo_name"`
    Address     string `json:"address"`
    BusinessType string `json:"business_type"`
    BusinessItem string `json:"business_item"`
    Email       string `json:"email"`
    Phone       string `json:"phone"`
}

// InvoiceItem 품목 정보
type InvoiceItem struct {
    SerialNum    int       `json:"serial_num"`    // 일련번호
    ItemDate     time.Time `json:"item_date"`     // 거래일자
    ItemName     string    `json:"item_name"`     // 품목명
    Spec         string    `json:"spec"`          // 규격
    Quantity     float64   `json:"quantity"`      // 수량
    UnitPrice    int64     `json:"unit_price"`    // 단가
    SupplyAmount int64     `json:"supply_amount"` // 공급가액
    TaxAmount    int64     `json:"tax_amount"`    // 세액
    Remarks      string    `json:"remarks"`       // 비고
}

// IssueResponse 발행 응답
type IssueResponse struct {
    NTSConfirmNum string    `json:"nts_confirm_num"` // 국세청 승인번호
    IssueID       string    `json:"issue_id"`        // Provider별 발행 ID
    IssuedAt      time.Time `json:"issued_at"`
    Provider      string    `json:"provider"`        // 사용된 Provider
}

// SearchRequest 조회 요청
type SearchRequest struct {
    CompanyID   uuid.UUID `json:"company_id"`
    StartDate   time.Time `json:"start_date"`
    EndDate     time.Time `json:"end_date"`
    InvoiceType string    `json:"invoice_type"` // "sales" | "purchase" | "all"
    Page        int       `json:"page"`
    PageSize    int       `json:"page_size"`
}

// SearchResponse 조회 응답
type SearchResponse struct {
    Invoices   []*domain.Invoice `json:"invoices"`
    TotalCount int               `json:"total_count"`
    Page       int               `json:"page"`
    PageSize   int               `json:"page_size"`
}
```

---

## 3. 홈택스 스크래핑 (Python)

### 3.1 gRPC Proto 정의

```protobuf
// api/proto/scraper.proto
syntax = "proto3";

package kerp.scraper.v1;

option go_package = "github.com/kerp/api/proto/scraper";

service ScraperService {
    // 세금계산서 발행
    rpc IssueInvoice(IssueRequest) returns (IssueResponse);

    // 세금계산서 목록 조회
    rpc SearchInvoices(SearchRequest) returns (SearchResponse);

    // 세금계산서 상세 조회
    rpc GetInvoice(GetInvoiceRequest) returns (Invoice);

    // 발행 취소
    rpc CancelInvoice(CancelRequest) returns (CancelResponse);

    // 헬스 체크
    rpc HealthCheck(HealthRequest) returns (HealthResponse);
}

// 발행 요청
message IssueRequest {
    string company_id = 1;

    // 인증 정보
    CertificateInfo certificate = 2;

    // 발행 유형
    string issue_type = 3;  // "normal" | "reverse"
    string issue_date = 4;  // YYYY-MM-DD

    // 공급자 정보
    SupplierInfo supplier = 5;

    // 공급받는자 정보
    BuyerInfo buyer = 6;

    // 금액
    int64 supply_amount = 7;
    int64 tax_amount = 8;
    int64 total_amount = 9;

    // 품목
    repeated InvoiceItem items = 10;

    // 비고
    string remarks = 11;
}

// 인증서 정보
message CertificateInfo {
    string cert_path = 1;      // 인증서 파일 경로
    string cert_password = 2;  // 인증서 비밀번호
    string business_number = 3; // 사업자번호
}

// 공급자 정보
message SupplierInfo {
    string brn = 1;           // 사업자등록번호
    string corp_num = 2;      // 법인등록번호
    string name = 3;          // 상호
    string ceo_name = 4;      // 대표자명
    string address = 5;       // 주소
    string business_type = 6; // 업태
    string business_item = 7; // 종목
    string email = 8;
    string phone = 9;
}

// 공급받는자 정보
message BuyerInfo {
    string brn = 1;
    string corp_num = 2;
    string name = 3;
    string ceo_name = 4;
    string address = 5;
    string business_type = 6;
    string business_item = 7;
    string email = 8;
    string phone = 9;
}

// 품목 정보
message InvoiceItem {
    int32 serial_num = 1;
    string item_date = 2;
    string item_name = 3;
    string spec = 4;
    double quantity = 5;
    int64 unit_price = 6;
    int64 supply_amount = 7;
    int64 tax_amount = 8;
    string remarks = 9;
}

// 발행 응답
message IssueResponse {
    bool success = 1;
    string nts_confirm_num = 2;  // 국세청 승인번호
    string issue_id = 3;
    string issued_at = 4;
    string error_code = 5;
    string error_message = 6;
}

// 조회 요청
message SearchRequest {
    string company_id = 1;
    CertificateInfo certificate = 2;
    string start_date = 3;
    string end_date = 4;
    string invoice_type = 5;  // "sales" | "purchase" | "all"
    int32 page = 6;
    int32 page_size = 7;
}

// 조회 응답
message SearchResponse {
    repeated Invoice invoices = 1;
    int32 total_count = 2;
    int32 page = 3;
    int32 page_size = 4;
}

// 세금계산서
message Invoice {
    string nts_confirm_num = 1;
    string issue_date = 2;
    string invoice_type = 3;

    SupplierInfo supplier = 4;
    BuyerInfo buyer = 5;

    int64 supply_amount = 6;
    int64 tax_amount = 7;
    int64 total_amount = 8;

    repeated InvoiceItem items = 9;

    string status = 10;
    string created_at = 11;
}

// 상세 조회 요청
message GetInvoiceRequest {
    string company_id = 1;
    CertificateInfo certificate = 2;
    string nts_confirm_num = 3;
}

// 취소 요청
message CancelRequest {
    string company_id = 1;
    CertificateInfo certificate = 2;
    string nts_confirm_num = 3;
    string reason = 4;
}

// 취소 응답
message CancelResponse {
    bool success = 1;
    string cancelled_at = 2;
    string error_code = 3;
    string error_message = 4;
}

// 헬스 체크 요청
message HealthRequest {}

// 헬스 체크 응답
message HealthResponse {
    HealthStatus status = 1;
    string message = 2;
}

enum HealthStatus {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
}
```

### 3.2 Python gRPC 서버 구현

```python
# tax-scraper/src/server.py
"""gRPC 서버 구현"""

import asyncio
import logging
from concurrent import futures
from datetime import datetime

import grpc
from grpc_reflection.v1alpha import reflection

from .proto import scraper_pb2, scraper_pb2_grpc
from .scraper.hometax import HometaxScraper, HometaxCredential
from .scraper.hometax import InvoiceSearchCriteria

logger = logging.getLogger(__name__)


class ScraperServicer(scraper_pb2_grpc.ScraperServiceServicer):
    """세금계산서 스크래핑 gRPC 서비스"""

    def __init__(self, config: dict):
        self.config = config
        self._scraper_pool = {}

    async def IssueInvoice(
        self,
        request: scraper_pb2.IssueRequest,
        context: grpc.aio.ServicerContext,
    ) -> scraper_pb2.IssueResponse:
        """세금계산서 발행"""
        logger.info(f"IssueInvoice request: company_id={request.company_id}")

        try:
            # 인증 정보 추출
            credential = HometaxCredential(
                cert_path=request.certificate.cert_path,
                cert_password=request.certificate.cert_password,
                business_number=request.certificate.business_number,
            )

            # 스크래퍼 인스턴스 생성/재사용
            async with HometaxScraper(credential) as scraper:
                # 로그인
                await scraper.login()

                # 발행 데이터 구성
                invoice_data = self._build_invoice_data(request)

                # 세금계산서 발행
                result = await scraper.issue_invoice(invoice_data)

            return scraper_pb2.IssueResponse(
                success=True,
                nts_confirm_num=result["nts_confirm_num"],
                issue_id=result.get("issue_id", ""),
                issued_at=result["issued_at"],
            )

        except Exception as e:
            logger.exception(f"IssueInvoice failed: {e}")
            return scraper_pb2.IssueResponse(
                success=False,
                error_code="ISSUE_FAILED",
                error_message=str(e),
            )

    async def SearchInvoices(
        self,
        request: scraper_pb2.SearchRequest,
        context: grpc.aio.ServicerContext,
    ) -> scraper_pb2.SearchResponse:
        """세금계산서 목록 조회"""
        logger.info(
            f"SearchInvoices: company_id={request.company_id}, "
            f"date={request.start_date}~{request.end_date}"
        )

        try:
            credential = HometaxCredential(
                cert_path=request.certificate.cert_path,
                cert_password=request.certificate.cert_password,
                business_number=request.certificate.business_number,
            )

            async with HometaxScraper(credential) as scraper:
                await scraper.login()

                criteria = InvoiceSearchCriteria(
                    start_date=datetime.strptime(request.start_date, "%Y-%m-%d").date(),
                    end_date=datetime.strptime(request.end_date, "%Y-%m-%d").date(),
                    invoice_type=request.invoice_type,
                    page=request.page,
                    page_size=request.page_size,
                )

                results = await scraper.search_invoices(criteria)

            # Proto 메시지로 변환
            invoices = [self._to_proto_invoice(inv) for inv in results]

            return scraper_pb2.SearchResponse(
                invoices=invoices,
                total_count=len(invoices),
                page=request.page,
                page_size=request.page_size,
            )

        except Exception as e:
            logger.exception(f"SearchInvoices failed: {e}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return scraper_pb2.SearchResponse()

    async def GetInvoice(
        self,
        request: scraper_pb2.GetInvoiceRequest,
        context: grpc.aio.ServicerContext,
    ) -> scraper_pb2.Invoice:
        """세금계산서 상세 조회"""
        logger.info(f"GetInvoice: nts_confirm_num={request.nts_confirm_num}")

        try:
            credential = HometaxCredential(
                cert_path=request.certificate.cert_path,
                cert_password=request.certificate.cert_password,
                business_number=request.certificate.business_number,
            )

            async with HometaxScraper(credential) as scraper:
                await scraper.login()
                result = await scraper.get_invoice_detail(request.nts_confirm_num)

            return self._to_proto_invoice(result)

        except Exception as e:
            logger.exception(f"GetInvoice failed: {e}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return scraper_pb2.Invoice()

    async def CancelInvoice(
        self,
        request: scraper_pb2.CancelRequest,
        context: grpc.aio.ServicerContext,
    ) -> scraper_pb2.CancelResponse:
        """세금계산서 취소"""
        logger.info(f"CancelInvoice: nts_confirm_num={request.nts_confirm_num}")

        try:
            credential = HometaxCredential(
                cert_path=request.certificate.cert_path,
                cert_password=request.certificate.cert_password,
                business_number=request.certificate.business_number,
            )

            async with HometaxScraper(credential) as scraper:
                await scraper.login()
                result = await scraper.cancel_invoice(
                    request.nts_confirm_num,
                    request.reason
                )

            return scraper_pb2.CancelResponse(
                success=True,
                cancelled_at=result["cancelled_at"],
            )

        except Exception as e:
            logger.exception(f"CancelInvoice failed: {e}")
            return scraper_pb2.CancelResponse(
                success=False,
                error_code="CANCEL_FAILED",
                error_message=str(e),
            )

    async def HealthCheck(
        self,
        request: scraper_pb2.HealthRequest,
        context: grpc.aio.ServicerContext,
    ) -> scraper_pb2.HealthResponse:
        """헬스 체크"""
        return scraper_pb2.HealthResponse(
            status=scraper_pb2.HealthStatus.SERVING,
            message="Tax Scraper Service is running",
        )

    def _build_invoice_data(self, request: scraper_pb2.IssueRequest) -> dict:
        """Proto 요청을 발행 데이터로 변환"""
        return {
            "issue_type": request.issue_type,
            "issue_date": request.issue_date,
            "supplier": {
                "brn": request.supplier.brn,
                "name": request.supplier.name,
                "ceo_name": request.supplier.ceo_name,
                "address": request.supplier.address,
                "business_type": request.supplier.business_type,
                "business_item": request.supplier.business_item,
                "email": request.supplier.email,
            },
            "buyer": {
                "brn": request.buyer.brn,
                "name": request.buyer.name,
                "ceo_name": request.buyer.ceo_name,
                "address": request.buyer.address,
                "email": request.buyer.email,
            },
            "supply_amount": request.supply_amount,
            "tax_amount": request.tax_amount,
            "total_amount": request.total_amount,
            "items": [
                {
                    "serial_num": item.serial_num,
                    "item_date": item.item_date,
                    "item_name": item.item_name,
                    "quantity": item.quantity,
                    "unit_price": item.unit_price,
                    "supply_amount": item.supply_amount,
                    "tax_amount": item.tax_amount,
                }
                for item in request.items
            ],
        }

    def _to_proto_invoice(self, data: dict) -> scraper_pb2.Invoice:
        """딕셔너리를 Proto Invoice로 변환"""
        return scraper_pb2.Invoice(
            nts_confirm_num=data.get("nts_confirm_num", ""),
            issue_date=data.get("issue_date", ""),
            invoice_type=data.get("invoice_type", ""),
            supplier=scraper_pb2.SupplierInfo(
                brn=data.get("supplier_brn", ""),
                name=data.get("supplier_name", ""),
            ),
            buyer=scraper_pb2.BuyerInfo(
                brn=data.get("buyer_brn", ""),
                name=data.get("buyer_name", ""),
            ),
            supply_amount=data.get("supply_amount", 0),
            tax_amount=data.get("tax_amount", 0),
            total_amount=data.get("total_amount", 0),
            status=data.get("status", ""),
        )


async def serve(config: dict):
    """gRPC 서버 시작"""
    server = grpc.aio.server(
        futures.ThreadPoolExecutor(max_workers=10),
        options=[
            ("grpc.max_send_message_length", 10 * 1024 * 1024),
            ("grpc.max_receive_message_length", 10 * 1024 * 1024),
        ],
    )

    # 서비스 등록
    scraper_pb2_grpc.add_ScraperServiceServicer_to_server(
        ScraperServicer(config), server
    )

    # Reflection 등록 (디버깅용)
    SERVICE_NAMES = (
        scraper_pb2.DESCRIPTOR.services_by_name["ScraperService"].full_name,
        reflection.SERVICE_NAME,
    )
    reflection.enable_server_reflection(SERVICE_NAMES, server)

    # 포트 바인딩
    port = config.get("port", 50051)
    server.add_insecure_port(f"[::]:{port}")

    logger.info(f"Starting Tax Scraper gRPC server on port {port}")
    await server.start()
    await server.wait_for_termination()
```

### 3.3 Go Scraper Provider 구현

```go
// internal/provider/invoice/scraper.go
package invoice

import (
    "context"
    "fmt"
    "time"

    "github.com/kerp/internal/domain"
    "github.com/kerp/internal/grpc"
    pb "github.com/kerp/api/proto/scraper"
    "go.uber.org/zap"
)

// ScraperProvider 홈택스 스크래핑 Provider
type ScraperProvider struct {
    client     *grpc.ScraperClient
    certStore  CertificateStore
    logger     *zap.Logger
    timeout    time.Duration
}

// CertificateStore 인증서 저장소 인터페이스
type CertificateStore interface {
    GetCertificate(ctx context.Context, companyID string) (*Certificate, error)
}

// Certificate 인증서 정보
type Certificate struct {
    CertPath     string
    CertPassword string
    BusinessNum  string
}

// NewScraperProvider 생성
func NewScraperProvider(
    client *grpc.ScraperClient,
    certStore CertificateStore,
    logger *zap.Logger,
) *ScraperProvider {
    return &ScraperProvider{
        client:    client,
        certStore: certStore,
        logger:    logger,
        timeout:   30 * time.Second,
    }
}

// Name Provider 이름
func (p *ScraperProvider) Name() string {
    return "scraper"
}

// Priority 우선순위 (1 = 최우선)
func (p *ScraperProvider) Priority() int {
    return 1
}

// IsAvailable 사용 가능 여부
func (p *ScraperProvider) IsAvailable(ctx context.Context) bool {
    if err := p.client.HealthCheck(ctx); err != nil {
        p.logger.Warn("scraper health check failed", zap.Error(err))
        return false
    }
    return true
}

// Issue 세금계산서 발행
func (p *ScraperProvider) Issue(ctx context.Context, req *IssueRequest) (*IssueResponse, error) {
    // 인증서 조회
    cert, err := p.certStore.GetCertificate(ctx, req.CompanyID.String())
    if err != nil {
        return nil, fmt.Errorf("failed to get certificate: %w", err)
    }

    // gRPC 요청 생성
    grpcReq := &pb.IssueRequest{
        CompanyId: req.CompanyID.String(),
        Certificate: &pb.CertificateInfo{
            CertPath:       cert.CertPath,
            CertPassword:   cert.CertPassword,
            BusinessNumber: cert.BusinessNum,
        },
        IssueType: req.IssueType,
        IssueDate: req.IssueDate.Format("2006-01-02"),
        Supplier: &pb.SupplierInfo{
            Brn:          req.Supplier.BRN,
            Name:         req.Supplier.Name,
            CeoName:      req.Supplier.CEOName,
            Address:      req.Supplier.Address,
            BusinessType: req.Supplier.BusinessType,
            BusinessItem: req.Supplier.BusinessItem,
            Email:        req.Supplier.Email,
        },
        Buyer: &pb.BuyerInfo{
            Brn:     req.Buyer.BRN,
            Name:    req.Buyer.Name,
            CeoName: req.Buyer.CEOName,
            Address: req.Buyer.Address,
            Email:   req.Buyer.Email,
        },
        SupplyAmount: req.SupplyAmount,
        TaxAmount:    req.TaxAmount,
        TotalAmount:  req.TotalAmount,
    }

    // 품목 추가
    for _, item := range req.Items {
        grpcReq.Items = append(grpcReq.Items, &pb.InvoiceItem{
            SerialNum:    int32(item.SerialNum),
            ItemDate:     item.ItemDate.Format("2006-01-02"),
            ItemName:     item.ItemName,
            Spec:         item.Spec,
            Quantity:     item.Quantity,
            UnitPrice:    item.UnitPrice,
            SupplyAmount: item.SupplyAmount,
            TaxAmount:    item.TaxAmount,
        })
    }

    // gRPC 호출
    ctx, cancel := context.WithTimeout(ctx, p.timeout)
    defer cancel()

    resp, err := p.client.IssueInvoice(ctx, grpcReq)
    if err != nil {
        return nil, fmt.Errorf("scraper issue failed: %w", err)
    }

    if !resp.Success {
        return nil, fmt.Errorf("scraper issue error: %s - %s",
            resp.ErrorCode, resp.ErrorMessage)
    }

    issuedAt, _ := time.Parse(time.RFC3339, resp.IssuedAt)

    return &IssueResponse{
        NTSConfirmNum: resp.NtsConfirmNum,
        IssueID:       resp.IssueId,
        IssuedAt:      issuedAt,
        Provider:      p.Name(),
    }, nil
}

// Search 세금계산서 조회
func (p *ScraperProvider) Search(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
    cert, err := p.certStore.GetCertificate(ctx, req.CompanyID.String())
    if err != nil {
        return nil, fmt.Errorf("failed to get certificate: %w", err)
    }

    grpcReq := &pb.SearchRequest{
        CompanyId: req.CompanyID.String(),
        Certificate: &pb.CertificateInfo{
            CertPath:       cert.CertPath,
            CertPassword:   cert.CertPassword,
            BusinessNumber: cert.BusinessNum,
        },
        StartDate:   req.StartDate.Format("2006-01-02"),
        EndDate:     req.EndDate.Format("2006-01-02"),
        InvoiceType: req.InvoiceType,
        Page:        int32(req.Page),
        PageSize:    int32(req.PageSize),
    }

    ctx, cancel := context.WithTimeout(ctx, p.timeout)
    defer cancel()

    resp, err := p.client.SearchInvoices(ctx, grpcReq)
    if err != nil {
        return nil, fmt.Errorf("scraper search failed: %w", err)
    }

    invoices := make([]*domain.Invoice, 0, len(resp.Invoices))
    for _, inv := range resp.Invoices {
        invoices = append(invoices, p.toDomainInvoice(inv))
    }

    return &SearchResponse{
        Invoices:   invoices,
        TotalCount: int(resp.TotalCount),
        Page:       int(resp.Page),
        PageSize:   int(resp.PageSize),
    }, nil
}

// GetDetail 상세 조회
func (p *ScraperProvider) GetDetail(ctx context.Context, ntsConfirmNum string) (*domain.Invoice, error) {
    // 구현 생략
    return nil, nil
}

// Cancel 취소
func (p *ScraperProvider) Cancel(ctx context.Context, ntsConfirmNum, reason string) error {
    // 구현 생략
    return nil
}

func (p *ScraperProvider) toDomainInvoice(inv *pb.Invoice) *domain.Invoice {
    issueDate, _ := time.Parse("2006-01-02", inv.IssueDate)
    return &domain.Invoice{
        NTSConfirmNum: inv.NtsConfirmNum,
        IssueDate:     issueDate,
        InvoiceType:   inv.InvoiceType,
        SupplierBRN:   inv.Supplier.Brn,
        SupplierName:  inv.Supplier.Name,
        BuyerBRN:      inv.Buyer.Brn,
        BuyerName:     inv.Buyer.Name,
        SupplyAmount:  inv.SupplyAmount,
        TaxAmount:     inv.TaxAmount,
        TotalAmount:   inv.TotalAmount,
        Status:        inv.Status,
    }
}
```

---

## 4. 국세청 API (Go)

### 4.1 NTS API Provider

```go
// internal/provider/invoice/nts_api.go
package invoice

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "time"

    "github.com/kerp/internal/domain"
    "go.uber.org/zap"
)

// NTSAPIProvider 국세청 API Provider
type NTSAPIProvider struct {
    httpClient *http.Client
    apiKey     string
    baseURL    string
    logger     *zap.Logger
}

// NTSAPIConfig 설정
type NTSAPIConfig struct {
    APIKey  string
    BaseURL string
    Timeout time.Duration
}

// NewNTSAPIProvider 생성
func NewNTSAPIProvider(cfg *NTSAPIConfig, logger *zap.Logger) *NTSAPIProvider {
    return &NTSAPIProvider{
        httpClient: &http.Client{Timeout: cfg.Timeout},
        apiKey:     cfg.APIKey,
        baseURL:    cfg.BaseURL,
        logger:     logger,
    }
}

// Name Provider 이름
func (p *NTSAPIProvider) Name() string {
    return "nts_api"
}

// Priority 우선순위 (2 = 두 번째)
func (p *NTSAPIProvider) Priority() int {
    return 2
}

// IsAvailable 사용 가능 여부
func (p *NTSAPIProvider) IsAvailable(ctx context.Context) bool {
    // API 키가 설정되어 있고, 헬스체크 통과
    if p.apiKey == "" {
        return false
    }

    req, _ := http.NewRequestWithContext(ctx, "GET", p.baseURL+"/health", nil)
    resp, err := p.httpClient.Do(req)
    if err != nil {
        p.logger.Warn("NTS API health check failed", zap.Error(err))
        return false
    }
    defer resp.Body.Close()

    return resp.StatusCode == http.StatusOK
}

// Issue 세금계산서 발행
func (p *NTSAPIProvider) Issue(ctx context.Context, req *IssueRequest) (*IssueResponse, error) {
    // NTS API 호출 구현
    // ...
    return nil, fmt.Errorf("not implemented")
}

// Search 세금계산서 조회
func (p *NTSAPIProvider) Search(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
    // NTS API 호출 구현
    // ...
    return nil, fmt.Errorf("not implemented")
}

// GetDetail 상세 조회
func (p *NTSAPIProvider) GetDetail(ctx context.Context, ntsConfirmNum string) (*domain.Invoice, error) {
    return nil, fmt.Errorf("not implemented")
}

// Cancel 취소
func (p *NTSAPIProvider) Cancel(ctx context.Context, ntsConfirmNum, reason string) error {
    return fmt.Errorf("not implemented")
}
```

---

## 5. Popbill ASP (Go)

### 5.1 Popbill Provider

```go
// internal/provider/invoice/popbill.go
package invoice

import (
    "context"
    "crypto/hmac"
    "crypto/sha256"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "net/http"
    "time"

    "github.com/kerp/internal/domain"
    "go.uber.org/zap"
)

// PopbillProvider Popbill ASP Provider
type PopbillProvider struct {
    httpClient   *http.Client
    linkID       string
    secretKey    string
    baseURL      string
    isProduction bool
    logger       *zap.Logger
}

// PopbillConfig 설정
type PopbillConfig struct {
    LinkID       string
    SecretKey    string
    IsProduction bool
    Timeout      time.Duration
}

// NewPopbillProvider 생성
func NewPopbillProvider(cfg *PopbillConfig, logger *zap.Logger) *PopbillProvider {
    baseURL := "https://popbill.linkhub.co.kr"
    if !cfg.IsProduction {
        baseURL = "https://sandbox-popbill.linkhub.co.kr"
    }

    return &PopbillProvider{
        httpClient:   &http.Client{Timeout: cfg.Timeout},
        linkID:       cfg.LinkID,
        secretKey:    cfg.SecretKey,
        baseURL:      baseURL,
        isProduction: cfg.IsProduction,
        logger:       logger,
    }
}

// Name Provider 이름
func (p *PopbillProvider) Name() string {
    return "popbill"
}

// Priority 우선순위 (3 = 최후 수단)
func (p *PopbillProvider) Priority() int {
    return 3
}

// IsAvailable 항상 사용 가능 (유료 서비스)
func (p *PopbillProvider) IsAvailable(ctx context.Context) bool {
    return p.linkID != "" && p.secretKey != ""
}

// Issue 세금계산서 발행
func (p *PopbillProvider) Issue(ctx context.Context, req *IssueRequest) (*IssueResponse, error) {
    // 액세스 토큰 발급
    token, err := p.getAccessToken(ctx, req.Supplier.BRN)
    if err != nil {
        return nil, fmt.Errorf("failed to get access token: %w", err)
    }

    // 발행 요청 생성
    popbillReq := p.buildIssueRequest(req)

    // API 호출
    endpoint := fmt.Sprintf("/Taxinvoice/%s", req.Supplier.BRN)
    resp, err := p.doRequest(ctx, "POST", endpoint, token, popbillReq)
    if err != nil {
        return nil, fmt.Errorf("popbill issue failed: %w", err)
    }

    var result struct {
        Code      int    `json:"code"`
        Message   string `json:"message"`
        NTSConfirmNum string `json:"ntsconfirmNum"`
    }
    if err := json.Unmarshal(resp, &result); err != nil {
        return nil, fmt.Errorf("failed to parse response: %w", err)
    }

    if result.Code != 1 {
        return nil, fmt.Errorf("popbill error: %d - %s", result.Code, result.Message)
    }

    return &IssueResponse{
        NTSConfirmNum: result.NTSConfirmNum,
        IssueID:       result.NTSConfirmNum,
        IssuedAt:      time.Now(),
        Provider:      p.Name(),
    }, nil
}

// getAccessToken 액세스 토큰 발급
func (p *PopbillProvider) getAccessToken(ctx context.Context, corpNum string) (string, error) {
    // Linkhub 토큰 발급 로직
    timestamp := time.Now().Format(time.RFC3339)

    // HMAC-SHA256 서명 생성
    msg := fmt.Sprintf("%s\n%s\n", p.linkID, timestamp)
    h := hmac.New(sha256.New, []byte(p.secretKey))
    h.Write([]byte(msg))
    signature := base64.StdEncoding.EncodeToString(h.Sum(nil))

    // 토큰 요청
    req, err := http.NewRequestWithContext(ctx, "GET",
        fmt.Sprintf("https://auth.linkhub.co.kr/POPBILL_TEST/Token?access_id=%s",
            p.linkID), nil)
    if err != nil {
        return "", err
    }

    req.Header.Set("x-lh-date", timestamp)
    req.Header.Set("x-lh-version", "2.0")
    req.Header.Set("Authorization", "LINKHUB "+p.linkID+" "+signature)

    resp, err := p.httpClient.Do(req)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()

    var tokenResp struct {
        SessionToken string `json:"session_token"`
    }
    if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
        return "", err
    }

    return tokenResp.SessionToken, nil
}

// buildIssueRequest Popbill 발행 요청 생성
func (p *PopbillProvider) buildIssueRequest(req *IssueRequest) map[string]interface{} {
    return map[string]interface{}{
        "writeDate":      req.IssueDate.Format("20060102"),
        "issueType":      "정발행",
        "taxType":        "과세",
        "invoicerCorpNum": req.Supplier.BRN,
        "invoicerCorpName": req.Supplier.Name,
        "invoicerCEOName": req.Supplier.CEOName,
        "invoicerAddr":    req.Supplier.Address,
        "invoicerBizType": req.Supplier.BusinessType,
        "invoicerBizClass": req.Supplier.BusinessItem,
        "invoicerEmail":   req.Supplier.Email,
        "invoiceeCorpNum": req.Buyer.BRN,
        "invoiceeCorpName": req.Buyer.Name,
        "invoiceeCEOName": req.Buyer.CEOName,
        "invoiceeAddr":    req.Buyer.Address,
        "invoiceeEmail":   req.Buyer.Email,
        "supplyCostTotal": req.SupplyAmount,
        "taxTotal":        req.TaxAmount,
        "totalAmount":     req.TotalAmount,
    }
}

// doRequest HTTP 요청 수행
func (p *PopbillProvider) doRequest(
    ctx context.Context,
    method, endpoint, token string,
    body interface{},
) ([]byte, error) {
    // 구현 생략
    return nil, nil
}

// Search 조회
func (p *PopbillProvider) Search(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
    return nil, fmt.Errorf("not implemented")
}

// GetDetail 상세 조회
func (p *PopbillProvider) GetDetail(ctx context.Context, ntsConfirmNum string) (*domain.Invoice, error) {
    return nil, fmt.Errorf("not implemented")
}

// Cancel 취소
func (p *PopbillProvider) Cancel(ctx context.Context, ntsConfirmNum, reason string) error {
    return fmt.Errorf("not implemented")
}
```

---

## 6. Provider 선택 로직

### 6.1 ProviderChain 구현

```go
// internal/provider/invoice/chain.go
package invoice

import (
    "context"
    "sort"

    "github.com/kerp/pkg/errors"
    "go.uber.org/zap"
)

// ProviderChain Provider 체인
type ProviderChain struct {
    providers []Provider
    logger    *zap.Logger
    metrics   *ProviderMetrics
}

// ProviderMetrics 메트릭
type ProviderMetrics struct {
    // Prometheus 메트릭 등
}

// NewProviderChain 생성
func NewProviderChain(providers []Provider, logger *zap.Logger) *ProviderChain {
    // 우선순위 정렬
    sort.Slice(providers, func(i, j int) bool {
        return providers[i].Priority() < providers[j].Priority()
    })

    return &ProviderChain{
        providers: providers,
        logger:    logger,
    }
}

// Issue 세금계산서 발행 (Fallback 체인)
func (c *ProviderChain) Issue(ctx context.Context, req *IssueRequest) (*IssueResponse, error) {
    var lastErr error

    for _, provider := range c.providers {
        // 사용 가능 여부 확인
        if !provider.IsAvailable(ctx) {
            c.logger.Info("provider not available, skipping",
                zap.String("provider", provider.Name()),
                zap.Int("priority", provider.Priority()))
            continue
        }

        c.logger.Info("attempting invoice issue",
            zap.String("provider", provider.Name()),
            zap.Int("priority", provider.Priority()))

        // 발행 시도
        resp, err := provider.Issue(ctx, req)
        if err != nil {
            c.logger.Warn("provider failed, trying next",
                zap.String("provider", provider.Name()),
                zap.Error(err))
            lastErr = err

            // 메트릭 기록
            // c.metrics.RecordFailure(provider.Name())
            continue
        }

        c.logger.Info("invoice issued successfully",
            zap.String("provider", provider.Name()),
            zap.String("nts_confirm_num", resp.NTSConfirmNum))

        // 메트릭 기록
        // c.metrics.RecordSuccess(provider.Name())

        return resp, nil
    }

    return nil, errors.Wrap(lastErr, "all providers failed to issue invoice")
}

// Search 세금계산서 조회 (첫 번째 성공 Provider 사용)
func (c *ProviderChain) Search(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
    for _, provider := range c.providers {
        if !provider.IsAvailable(ctx) {
            continue
        }

        resp, err := provider.Search(ctx, req)
        if err != nil {
            c.logger.Warn("search failed, trying next provider",
                zap.String("provider", provider.Name()),
                zap.Error(err))
            continue
        }

        return resp, nil
    }

    return nil, errors.New("all providers failed to search invoices")
}
```

### 6.2 서비스 레이어 통합

```go
// internal/service/invoice_service.go
package service

import (
    "context"

    "github.com/google/uuid"
    "github.com/kerp/internal/domain"
    "github.com/kerp/internal/provider/invoice"
    "github.com/kerp/internal/repository"
    "go.uber.org/zap"
)

// InvoiceService 세금계산서 서비스
type InvoiceService struct {
    chain  *invoice.ProviderChain
    repo   repository.InvoiceRepository
    logger *zap.Logger
}

// NewInvoiceService 생성
func NewInvoiceService(
    chain *invoice.ProviderChain,
    repo repository.InvoiceRepository,
    logger *zap.Logger,
) *InvoiceService {
    return &InvoiceService{
        chain:  chain,
        repo:   repo,
        logger: logger,
    }
}

// Issue 세금계산서 발행
func (s *InvoiceService) Issue(ctx context.Context, req *invoice.IssueRequest) (*domain.Invoice, error) {
    // Provider 체인으로 발행
    resp, err := s.chain.Issue(ctx, req)
    if err != nil {
        return nil, err
    }

    // 도메인 모델 생성
    inv := &domain.Invoice{
        ID:            uuid.New(),
        CompanyID:     req.CompanyID,
        NTSConfirmNum: resp.NTSConfirmNum,
        IssueDate:     req.IssueDate,
        InvoiceType:   "sales",
        IssueType:     req.IssueType,
        SupplierBRN:   req.Supplier.BRN,
        SupplierName:  req.Supplier.Name,
        BuyerBRN:      req.Buyer.BRN,
        BuyerName:     req.Buyer.Name,
        SupplyAmount:  req.SupplyAmount,
        TaxAmount:     req.TaxAmount,
        TotalAmount:   req.TotalAmount,
        Provider:      resp.Provider,
        ProviderRef:   resp.IssueID,
    }

    // DB 저장
    if err := s.repo.Create(ctx, inv); err != nil {
        s.logger.Error("failed to save invoice",
            zap.String("nts_confirm_num", inv.NTSConfirmNum),
            zap.Error(err))
        // 발행은 성공했으므로 경고만
    }

    return inv, nil
}

// Search 세금계산서 조회
func (s *InvoiceService) Search(ctx context.Context, req *invoice.SearchRequest) (*invoice.SearchResponse, error) {
    return s.chain.Search(ctx, req)
}
```

---

## 7. 에러 처리

### 7.1 에러 타입 정의

```go
// pkg/errors/invoice_errors.go
package errors

import "errors"

var (
    // ErrProviderUnavailable Provider 사용 불가
    ErrProviderUnavailable = errors.New("provider unavailable")

    // ErrInvoiceNotFound 세금계산서 미존재
    ErrInvoiceNotFound = errors.New("invoice not found")

    // ErrInvoiceAlreadyIssued 이미 발행된 세금계산서
    ErrInvoiceAlreadyIssued = errors.New("invoice already issued")

    // ErrInvoiceCancelFailed 취소 실패
    ErrInvoiceCancelFailed = errors.New("invoice cancel failed")

    // ErrCertificateNotFound 인증서 미존재
    ErrCertificateNotFound = errors.New("certificate not found")

    // ErrCertificateExpired 인증서 만료
    ErrCertificateExpired = errors.New("certificate expired")

    // ErrAllProvidersFailed 모든 Provider 실패
    ErrAllProvidersFailed = errors.New("all providers failed")
)

// ProviderError Provider 에러
type ProviderError struct {
    Provider string
    Code     string
    Message  string
    Cause    error
}

func (e *ProviderError) Error() string {
    return e.Provider + ": " + e.Code + " - " + e.Message
}

func (e *ProviderError) Unwrap() error {
    return e.Cause
}
```

### 7.2 재시도 정책

```go
// internal/provider/invoice/retry.go
package invoice

import (
    "context"
    "time"

    "github.com/cenkalti/backoff/v4"
)

// RetryConfig 재시도 설정
type RetryConfig struct {
    MaxRetries     int
    InitialBackoff time.Duration
    MaxBackoff     time.Duration
    Multiplier     float64
}

// DefaultRetryConfig 기본 재시도 설정
var DefaultRetryConfig = &RetryConfig{
    MaxRetries:     3,
    InitialBackoff: 500 * time.Millisecond,
    MaxBackoff:     10 * time.Second,
    Multiplier:     2.0,
}

// WithRetry 재시도 래퍼
func WithRetry(ctx context.Context, cfg *RetryConfig, fn func() error) error {
    bo := backoff.NewExponentialBackOff()
    bo.InitialInterval = cfg.InitialBackoff
    bo.MaxInterval = cfg.MaxBackoff
    bo.Multiplier = cfg.Multiplier
    bo.MaxElapsedTime = 0 // 무제한

    retryCount := 0
    return backoff.Retry(func() error {
        if retryCount >= cfg.MaxRetries {
            return backoff.Permanent(ErrMaxRetriesExceeded)
        }
        retryCount++

        err := fn()
        if err != nil {
            // 재시도 불가능한 에러 체크
            if isNonRetryable(err) {
                return backoff.Permanent(err)
            }
            return err
        }
        return nil
    }, backoff.WithContext(bo, ctx))
}

// isNonRetryable 재시도 불가능한 에러인지 확인
func isNonRetryable(err error) bool {
    // 인증 에러, 잘못된 요청 등은 재시도 불가
    // ... 구현
    return false
}

var ErrMaxRetriesExceeded = errors.New("max retries exceeded")
```

---

**다음 문서**: [03_4대보험_연동_설계.md](./03_4대보험_연동_설계.md)
