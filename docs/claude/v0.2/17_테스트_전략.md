# K-ERP v0.2 - 테스트 전략

**문서 버전**: 0.2.0
**작성일**: 2026-01-16
**상태**: 검토 대기

---

## 목차

1. [테스트 전략 개요](#1-테스트-전략-개요)
2. [단위 테스트](#2-단위-테스트)
3. [통합 테스트](#3-통합-테스트)
4. [E2E 테스트](#4-e2e-테스트)
5. [테스트 자동화](#5-테스트-자동화)

---

## 1. 테스트 전략 개요

### 1.1 테스트 피라미드

```
                    ┌─────────┐
                   /│  E2E    │\        10%
                  / │ Tests   │ \       (Critical Paths)
                 /  └─────────┘  \
                /                 \
               /   ┌───────────┐   \
              /    │Integration│    \   20%
             /     │  Tests    │     \  (Service Boundaries)
            /      └───────────┘      \
           /                           \
          /      ┌─────────────┐        \
         /       │    Unit     │         \  70%
        /        │   Tests     │          \ (Business Logic)
       /         └─────────────┘           \
      ─────────────────────────────────────────
```

### 1.2 테스트 유형별 목표

| 테스트 유형 | 목적 | 커버리지 목표 | 실행 시점 |
|------------|------|---------------|-----------|
| 단위 테스트 | 개별 함수/메서드 검증 | 80% 이상 | 커밋 시 |
| 통합 테스트 | 서비스 간 연동 검증 | 주요 경로 | PR 시 |
| E2E 테스트 | 사용자 시나리오 검증 | Critical Path | 배포 전 |
| 성능 테스트 | 응답시간/처리량 검증 | SLA 기준 | 릴리스 전 |
| 보안 테스트 | 취약점 검증 | OWASP Top 10 | 릴리스 전 |

### 1.3 테스트 환경

| 환경 | 용도 | 데이터 |
|------|------|--------|
| Local | 개발 중 테스트 | Mock/In-memory |
| CI | 자동화 테스트 | Docker 컨테이너 |
| Staging | 통합/E2E 테스트 | 샘플 데이터 |
| Production | 스모크 테스트 | 실제 데이터 (읽기 전용) |

---

## 2. 단위 테스트

### 2.1 Go 단위 테스트

```go
// internal/service/invoice/service_test.go
package invoice

import (
    "context"
    "testing"
    "time"

    "github.com/google/uuid"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"

    "github.com/kerp/internal/domain"
)

// Mock Repository
type MockInvoiceRepository struct {
    mock.Mock
}

func (m *MockInvoiceRepository) Create(ctx context.Context, invoice *domain.Invoice) error {
    args := m.Called(ctx, invoice)
    return args.Error(0)
}

func (m *MockInvoiceRepository) FindByID(ctx context.Context, id uuid.UUID) (*domain.Invoice, error) {
    args := m.Called(ctx, id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*domain.Invoice), args.Error(1)
}

// 테이블 드리븐 테스트
func TestInvoiceService_ValidateInvoice(t *testing.T) {
    tests := []struct {
        name        string
        invoice     *domain.Invoice
        expectError bool
        errorCode   string
    }{
        {
            name: "valid invoice",
            invoice: &domain.Invoice{
                InvoiceType:  domain.InvoiceTypeSales,
                IssueDate:    time.Now(),
                SupplyAmount: 1000000,
                TaxAmount:    100000,
                Supplier: domain.Party{
                    BusinessNumber: "123-45-67890",
                    CompanyName:    "공급자 주식회사",
                },
                Buyer: domain.Party{
                    BusinessNumber: "234-56-78901",
                    CompanyName:    "공급받는자 주식회사",
                },
            },
            expectError: false,
        },
        {
            name: "missing supplier business number",
            invoice: &domain.Invoice{
                InvoiceType:  domain.InvoiceTypeSales,
                IssueDate:    time.Now(),
                SupplyAmount: 1000000,
                TaxAmount:    100000,
                Supplier: domain.Party{
                    CompanyName: "공급자 주식회사",
                },
            },
            expectError: true,
            errorCode:   "INVALID_SUPPLIER",
        },
        {
            name: "invalid tax amount",
            invoice: &domain.Invoice{
                InvoiceType:  domain.InvoiceTypeSales,
                IssueDate:    time.Now(),
                SupplyAmount: 1000000,
                TaxAmount:    50000,  // Should be 100000 (10%)
            },
            expectError: true,
            errorCode:   "INVALID_TAX_AMOUNT",
        },
        {
            name: "future issue date",
            invoice: &domain.Invoice{
                InvoiceType:  domain.InvoiceTypeSales,
                IssueDate:    time.Now().AddDate(0, 0, 7),
                SupplyAmount: 1000000,
                TaxAmount:    100000,
            },
            expectError: true,
            errorCode:   "INVALID_ISSUE_DATE",
        },
    }

    svc := NewService(nil, nil)

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := svc.ValidateInvoice(tt.invoice)

            if tt.expectError {
                assert.Error(t, err)
                if tt.errorCode != "" {
                    var appErr *AppError
                    assert.ErrorAs(t, err, &appErr)
                    assert.Equal(t, tt.errorCode, appErr.Code)
                }
            } else {
                assert.NoError(t, err)
            }
        })
    }
}

func TestInvoiceService_CalculateTax(t *testing.T) {
    tests := []struct {
        name         string
        supplyAmount int64
        expectedTax  int64
    }{
        {"standard", 1000000, 100000},
        {"with rounding", 1234567, 123457},
        {"zero amount", 0, 0},
        {"small amount", 100, 10},
    }

    svc := NewService(nil, nil)

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tax := svc.CalculateTax(tt.supplyAmount)
            assert.Equal(t, tt.expectedTax, tax)
        })
    }
}
```

### 2.2 Python 단위 테스트

```python
# python-services/tax-scraper/tests/test_crypto.py
import pytest
from shared.crypto.seed import SEEDCipher

class TestSEEDCipher:
    """SEED-CBC 암호화 테스트"""

    @pytest.fixture
    def cipher(self):
        key = b'0123456789ABCDEF'  # 16 bytes
        return SEEDCipher(key)

    def test_encrypt_decrypt(self, cipher):
        """암호화 후 복호화 시 원본 복원"""
        plaintext = "홈택스 테스트 데이터"

        encrypted = cipher.encrypt(plaintext)
        decrypted = cipher.decrypt(encrypted)

        assert decrypted == plaintext

    def test_encrypt_produces_different_output(self, cipher):
        """동일 입력에 대해 다른 암호문 (IV 랜덤)"""
        plaintext = "테스트"

        encrypted1 = cipher.encrypt(plaintext)
        encrypted2 = cipher.encrypt(plaintext)

        assert encrypted1 != encrypted2

    def test_invalid_key_length(self):
        """잘못된 키 길이 예외 처리"""
        with pytest.raises(ValueError, match="Key must be 16 bytes"):
            SEEDCipher(b'short')

    def test_decrypt_corrupted_data(self, cipher):
        """손상된 데이터 복호화 실패"""
        with pytest.raises(Exception):
            cipher.decrypt(b'corrupted data')


# python-services/tax-scraper/tests/test_parser.py
import pytest
from datetime import date
from decimal import Decimal
from src.parser import HometaxParser

class TestHometaxParser:
    """홈택스 HTML 파싱 테스트"""

    @pytest.fixture
    def parser(self):
        return HometaxParser()

    def test_parse_invoice_list(self, parser):
        """세금계산서 목록 파싱"""
        html = """
        <table id="grid1_body_table">
            <tr>
                <td>20260115-12345678-00000001</td>
                <td>2026-01-15</td>
                <td>123-45-67890</td>
                <td>(주)공급자</td>
                <td>1,000,000</td>
                <td>100,000</td>
            </tr>
        </table>
        """

        invoices = parser.parse_invoice_list(html)

        assert len(invoices) == 1
        assert invoices[0].nts_confirm_num == "20260115-12345678-00000001"
        assert invoices[0].issue_date == date(2026, 1, 15)
        assert invoices[0].supply_amount == Decimal("1000000")

    def test_parse_empty_list(self, parser):
        """빈 목록 처리"""
        html = '<table id="grid1_body_table"></table>'

        invoices = parser.parse_invoice_list(html)

        assert len(invoices) == 0

    def test_parse_invoice_detail(self, parser):
        """세금계산서 상세 파싱"""
        html = """
        <div class="detail">
            <span id="ntsConfirmNum">20260115-12345678-00000001</span>
            <span id="supplyAmount">10,000,000</span>
            <table id="itemList">
                <tr><td>웹개발</td><td>1</td><td>10,000,000</td></tr>
            </table>
        </div>
        """

        detail = parser.parse_invoice_detail(html)

        assert detail.nts_confirm_num == "20260115-12345678-00000001"
        assert len(detail.items) == 1
        assert detail.items[0].description == "웹개발"
```

### 2.3 Mock 전략

```go
// internal/mocks/provider_mock.go
package mocks

import (
    "context"

    "github.com/kerp/internal/domain"
    "github.com/stretchr/testify/mock"
)

type MockProvider struct {
    mock.Mock
    name     string
    priority int
    isFree   bool
}

func NewMockProvider(name string, priority int, isFree bool) *MockProvider {
    return &MockProvider{
        name:     name,
        priority: priority,
        isFree:   isFree,
    }
}

func (m *MockProvider) Name() string     { return m.name }
func (m *MockProvider) Priority() int    { return m.priority }
func (m *MockProvider) IsFree() bool     { return m.isFree }

func (m *MockProvider) IsAvailable(ctx context.Context) bool {
    args := m.Called(ctx)
    return args.Bool(0)
}

func (m *MockProvider) GetInvoices(ctx context.Context, req *GetInvoicesRequest) ([]*domain.Invoice, error) {
    args := m.Called(ctx, req)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).([]*domain.Invoice), args.Error(1)
}
```

---

## 3. 통합 테스트

### 3.1 데이터베이스 통합 테스트

```go
// tests/integration/repository_test.go
//go:build integration

package integration

import (
    "context"
    "testing"

    "github.com/stretchr/testify/suite"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"

    "github.com/kerp/internal/repository"
)

type RepositoryTestSuite struct {
    suite.Suite
    container *postgres.PostgresContainer
    repo      *repository.PostgresRepository
    ctx       context.Context
}

func (s *RepositoryTestSuite) SetupSuite() {
    s.ctx = context.Background()

    // Start PostgreSQL container
    container, err := postgres.RunContainer(s.ctx,
        testcontainers.WithImage("postgres:16-alpine"),
        postgres.WithDatabase("kerp_test"),
        postgres.WithUsername("kerp"),
        postgres.WithPassword("kerp_test"),
    )
    s.Require().NoError(err)
    s.container = container

    // Get connection string
    connStr, err := container.ConnectionString(s.ctx)
    s.Require().NoError(err)

    // Run migrations
    err = runMigrations(connStr)
    s.Require().NoError(err)

    // Create repository
    s.repo, err = repository.NewPostgresRepository(connStr)
    s.Require().NoError(err)
}

func (s *RepositoryTestSuite) TearDownSuite() {
    if s.container != nil {
        s.container.Terminate(s.ctx)
    }
}

func (s *RepositoryTestSuite) TestVoucherRepository_CreateAndFind() {
    // Given
    voucher := &domain.Voucher{
        CompanyID:   testCompanyID,
        VoucherDate: time.Now(),
        VoucherType: domain.VoucherTypeGeneral,
        Description: "테스트 전표",
        Entries: []domain.VoucherEntry{
            {AccountID: accountCash, DebitAmount: 100000},
            {AccountID: accountRevenue, CreditAmount: 100000},
        },
    }

    // When
    err := s.repo.Voucher().Create(s.ctx, voucher)
    s.Require().NoError(err)

    // Then
    found, err := s.repo.Voucher().FindByID(s.ctx, voucher.ID)
    s.Require().NoError(err)
    s.Equal(voucher.Description, found.Description)
    s.Len(found.Entries, 2)
}

func (s *RepositoryTestSuite) TestVoucherRepository_BalanceValidation() {
    // Given - unbalanced voucher
    voucher := &domain.Voucher{
        CompanyID:   testCompanyID,
        VoucherDate: time.Now(),
        VoucherType: domain.VoucherTypeGeneral,
        Entries: []domain.VoucherEntry{
            {AccountID: accountCash, DebitAmount: 100000},
            {AccountID: accountRevenue, CreditAmount: 50000},  // Unbalanced
        },
    }

    // When
    err := s.repo.Voucher().Create(s.ctx, voucher)

    // Then
    s.Error(err)
    s.Contains(err.Error(), "balance")
}

func TestRepositorySuite(t *testing.T) {
    suite.Run(t, new(RepositoryTestSuite))
}
```

### 3.2 gRPC 통합 테스트

```go
// tests/integration/grpc_test.go
//go:build integration

package integration

import (
    "context"
    "testing"
    "time"

    "github.com/stretchr/testify/suite"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"

    pb "github.com/kerp/api/proto/scraper"
)

type GRPCTestSuite struct {
    suite.Suite
    conn   *grpc.ClientConn
    client pb.ScraperServiceClient
}

func (s *GRPCTestSuite) SetupSuite() {
    // Connect to test Python service
    conn, err := grpc.Dial("localhost:50051",
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithBlock(),
        grpc.WithTimeout(10*time.Second),
    )
    s.Require().NoError(err)
    s.conn = conn
    s.client = pb.NewScraperServiceClient(conn)
}

func (s *GRPCTestSuite) TearDownSuite() {
    if s.conn != nil {
        s.conn.Close()
    }
}

func (s *GRPCTestSuite) TestHealthCheck() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    resp, err := s.client.HealthCheck(ctx, &pb.HealthRequest{})

    s.NoError(err)
    s.Equal("OK", resp.Status)
}

func (s *GRPCTestSuite) TestScrapeInvoices_InvalidCert() {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    req := &pb.ScrapeRequest{
        CertPath:     "/invalid/path",
        CertPassword: "wrong",
        StartDate:    "20260101",
        EndDate:      "20260131",
        InvoiceType:  pb.InvoiceType_PURCHASE,
    }

    _, err := s.client.ScrapeInvoices(ctx, req)

    s.Error(err)
    // Check error code
}

func TestGRPCSuite(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test")
    }
    suite.Run(t, new(GRPCTestSuite))
}
```

### 3.3 Provider Chain 통합 테스트

```go
// tests/integration/provider_chain_test.go
//go:build integration

package integration

func (s *ProviderChainTestSuite) TestFallbackOnFailure() {
    // Given
    scraperProvider := mocks.NewMockProvider("scraper", 1, true)
    scraperProvider.On("IsAvailable", mock.Anything).Return(true)
    scraperProvider.On("GetInvoices", mock.Anything, mock.Anything).
        Return(nil, errors.New("scraping failed"))

    popbillProvider := mocks.NewMockProvider("popbill", 3, false)
    popbillProvider.On("IsAvailable", mock.Anything).Return(true)
    popbillProvider.On("GetInvoices", mock.Anything, mock.Anything).
        Return([]*domain.Invoice{{ID: uuid.New()}}, nil)

    chain := invoice.NewProviderChain(scraperProvider, popbillProvider)

    // When
    invoices, err := chain.GetInvoices(context.Background(), &invoice.GetInvoicesRequest{})

    // Then
    s.NoError(err)
    s.Len(invoices, 1)
    popbillProvider.AssertCalled(s.T(), "GetInvoices", mock.Anything, mock.Anything)
}
```

---

## 4. E2E 테스트

### 4.1 Playwright 설정

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  timeout: 60000,
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 4 : undefined,
  reporter: [
    ['html'],
    ['junit', { outputFile: 'test-results/junit.xml' }],
  ],
  use: {
    baseURL: process.env.BASE_URL || 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'mobile',
      use: { ...devices['iPhone 13'] },
    },
  ],
});
```

### 4.2 E2E 테스트 시나리오

```typescript
// e2e/invoice.spec.ts
import { test, expect } from '@playwright/test';

test.describe('세금계산서 발행', () => {
  test.beforeEach(async ({ page }) => {
    // 로그인
    await page.goto('/login');
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('세금계산서 목록 조회', async ({ page }) => {
    await page.goto('/invoices');

    // 목록이 로드되었는지 확인
    await expect(page.locator('table')).toBeVisible();
    await expect(page.locator('table tbody tr')).toHaveCount.greaterThan(0);
  });

  test('세금계산서 발행 성공', async ({ page }) => {
    await page.goto('/invoices');
    await page.click('button:has-text("새 세금계산서")');

    // 폼 작성
    await page.fill('input[name="buyerBusinessNumber"]', '234-56-78901');
    await page.click('button:has-text("조회")');

    // 거래처 정보 자동 완성 확인
    await expect(page.locator('input[name="buyerCompanyName"]')).toHaveValue(/.+/);

    // 품목 추가
    await page.fill('input[name="items.0.description"]', '소프트웨어 개발');
    await page.fill('input[name="items.0.quantity"]', '1');
    await page.fill('input[name="items.0.unitPrice"]', '10000000');

    // 금액 확인
    await expect(page.locator('[data-testid="supply-amount"]')).toHaveText('10,000,000');
    await expect(page.locator('[data-testid="tax-amount"]')).toHaveText('1,000,000');

    // 발행
    await page.click('button:has-text("발행")');

    // 발행 완료 확인
    await expect(page.locator('.toast-success')).toBeVisible();
    await expect(page).toHaveURL(/\/invoices\/[a-f0-9-]+/);
  });

  test('유효성 검사 실패', async ({ page }) => {
    await page.goto('/invoices/new');

    // 빈 폼 제출
    await page.click('button:has-text("발행")');

    // 에러 메시지 확인
    await expect(page.locator('.field-error')).toHaveCount.greaterThan(0);
    await expect(page.locator('text=사업자등록번호를 입력해주세요')).toBeVisible();
  });
});

test.describe('급여 계산', () => {
  test('월급여 계산 및 확정', async ({ page }) => {
    await page.goto('/payroll');

    // 계산 대상 기간 선택
    await page.selectOption('select[name="year"]', '2026');
    await page.selectOption('select[name="month"]', '1');

    // 일괄 계산
    await page.click('button:has-text("일괄 계산")');

    // 계산 완료 대기
    await expect(page.locator('[data-testid="calculation-status"]')).toHaveText('계산 완료');

    // 결과 확인
    const totalRow = page.locator('tr:has-text("합계")');
    await expect(totalRow.locator('[data-testid="total-net-pay"]')).toHaveText(/[\d,]+/);

    // 확정
    await page.click('button:has-text("확정")');
    await page.click('button:has-text("확인")');  // 확인 모달

    await expect(page.locator('.toast-success')).toHaveText(/확정되었습니다/);
  });
});
```

### 4.3 API E2E 테스트

```typescript
// e2e/api/invoice.api.spec.ts
import { test, expect } from '@playwright/test';

test.describe('세금계산서 API', () => {
  let authToken: string;

  test.beforeAll(async ({ request }) => {
    // 인증 토큰 획득
    const response = await request.post('/api/v1/auth/login', {
      data: {
        email: 'test@example.com',
        password: 'password123',
      },
    });
    const body = await response.json();
    authToken = body.data.access_token;
  });

  test('세금계산서 목록 조회', async ({ request }) => {
    const response = await request.get('/api/v1/invoices', {
      headers: {
        Authorization: `Bearer ${authToken}`,
      },
      params: {
        start_date: '2026-01-01',
        end_date: '2026-01-31',
      },
    });

    expect(response.ok()).toBeTruthy();
    const body = await response.json();
    expect(body.success).toBe(true);
    expect(body.data.items).toBeInstanceOf(Array);
  });

  test('세금계산서 발행', async ({ request }) => {
    const response = await request.post('/api/v1/invoices', {
      headers: {
        Authorization: `Bearer ${authToken}`,
      },
      data: {
        type: 'sales',
        issue_date: '2026-01-15',
        buyer: {
          business_number: '234-56-78901',
          company_name: '테스트 고객사',
        },
        items: [
          {
            date: '2026-01-15',
            description: 'API 테스트',
            quantity: 1,
            unit_price: 100000,
          },
        ],
      },
    });

    expect(response.status()).toBe(202);  // Accepted (async)
    const body = await response.json();
    expect(body.data.status).toBe('pending');
  });
});
```

---

## 5. 테스트 자동화

### 5.1 GitHub Actions 테스트 워크플로우

```yaml
# .github/workflows/test.yml
name: Test

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [develop]

jobs:
  unit-test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Run Go tests
        run: |
          go test -v -race -coverprofile=coverage.out ./...
          go tool cover -func=coverage.out

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Run Python tests
        working-directory: python-services
        run: |
          pip install -r requirements.txt -r requirements-dev.txt
          pytest --cov --cov-report=xml

      - name: Upload coverage
        uses: codecov/codecov-action@v4

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-test
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: kerp_test
          POSTGRES_USER: kerp
          POSTGRES_PASSWORD: kerp_test
        ports:
          - 5432:5432
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Run migrations
        run: make migrate-up
        env:
          DATABASE_URL: postgres://kerp:kerp_test@localhost:5432/kerp_test?sslmode=disable

      - name: Run integration tests
        run: go test -v -tags=integration ./tests/integration/...
        env:
          DATABASE_URL: postgres://kerp:kerp_test@localhost:5432/kerp_test?sslmode=disable
          REDIS_URL: redis://localhost:6379

  e2e-test:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: integration-test
    steps:
      - uses: actions/checkout@v4

      - name: Start services
        run: docker-compose -f docker-compose.test.yml up -d

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          cd web
          npm ci
          npx playwright install --with-deps

      - name: Run E2E tests
        run: |
          cd web
          npx playwright test

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: web/playwright-report/
```

### 5.2 커버리지 요구사항

```yaml
# codecov.yml
coverage:
  precision: 2
  round: down
  status:
    project:
      default:
        target: 80%
        threshold: 2%
    patch:
      default:
        target: 80%
        threshold: 5%

flags:
  go:
    paths:
      - internal/
      - pkg/
    carryforward: true
  python:
    paths:
      - python-services/
    carryforward: true
```

---

**다음 문서**: [18_에러_핸들링_가이드.md](./18_에러_핸들링_가이드.md)
