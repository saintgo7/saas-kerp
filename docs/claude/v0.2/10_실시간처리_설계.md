# K-ERP v0.2 - 실시간 처리 설계

**문서 버전**: 0.2.0
**작성일**: 2026-01-16
**상태**: 검토 대기

---

## 목차

1. [실시간 처리 아키텍처](#1-실시간-처리-아키텍처)
2. [NATS JetStream 설계](#2-nats-jetstream-설계)
3. [이벤트 기반 처리](#3-이벤트-기반-처리)
4. [WebSocket 실시간 알림](#4-websocket-실시간-알림)
5. [비동기 작업 처리](#5-비동기-작업-처리)

---

## 1. 실시간 처리 아키텍처

### 1.1 전체 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       실시간 처리 아키텍처                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────────────────────┐   │
│  │  Client     │────▶│  API Server │────▶│  NATS JetStream             │   │
│  │  (Browser)  │◀────│  (Go)       │◀────│  (Message Broker)           │   │
│  └─────────────┘     └─────────────┘     └─────────────────────────────┘   │
│        │                    │                          │                    │
│        │ WebSocket          │                          │                    │
│        ▼                    ▼                          ▼                    │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────────────────────┐   │
│  │  Real-time  │     │  Worker     │     │  Consumers                  │   │
│  │  Updates    │     │  Process    │     │  - Invoice Processor        │   │
│  │  - 알림     │     │  - 비동기   │     │  - Insurance Reporter       │   │
│  │  - 상태변경 │     │    작업처리 │     │  - Notification Sender      │   │
│  └─────────────┘     └─────────────┘     │  - Report Generator         │   │
│                                          └─────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 처리 유형별 분류

| 처리 유형 | 기술 | 지연 허용 | 사용 사례 |
|-----------|------|-----------|-----------|
| 동기 처리 | HTTP Request | < 200ms | CRUD 작업, 조회 |
| 실시간 알림 | WebSocket | < 1s | 상태 변경, 알림 |
| 비동기 처리 | NATS JetStream | 수초~수분 | 세금계산서 발행, 리포트 |
| 배치 처리 | Cron + Worker | 수분~수시간 | 4대보험 신고, 정산 |

### 1.3 메시지 흐름

```
┌────────────────────────────────────────────────────────────────────────┐
│                        Message Flow                                     │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  1. API Request                                                        │
│     Client ─────▶ API Server ─────▶ Validate ─────▶ Publish to NATS    │
│                        │                                    │          │
│                        │                                    ▼          │
│  2. Async Processing   │         ┌──────────────────────────────────┐ │
│                        │         │ NATS JetStream                   │ │
│                        │         │  Streams:                        │ │
│                        │         │  - INVOICES (세금계산서)          │ │
│                        │         │  - INSURANCE (4대보험)            │ │
│                        │         │  - NOTIFICATIONS (알림)           │ │
│                        │         │  - REPORTS (리포트)               │ │
│                        │         └──────────────────────────────────┘ │
│                        │                         │                     │
│                        │                         ▼                     │
│  3. Worker Consume     │         ┌──────────────────────────────────┐ │
│                        │         │ Worker (Consumer)                │ │
│                        │         │  - Process message               │ │
│                        │         │  - Call Python services (gRPC)   │ │
│                        │         │  - Update database               │ │
│                        │         │  - Publish result event          │ │
│                        │         └──────────────────────────────────┘ │
│                        │                         │                     │
│                        │                         ▼                     │
│  4. Notify Client      ◀─────────────────── WebSocket ◀───────────────│
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

---

## 2. NATS JetStream 설계

### 2.1 Stream 정의

```go
// internal/infrastructure/nats/streams.go
package nats

import (
    "time"

    "github.com/nats-io/nats.go"
)

type StreamConfig struct {
    Name        string
    Subjects    []string
    Retention   nats.RetentionPolicy
    MaxAge      time.Duration
    MaxMsgs     int64
    MaxBytes    int64
    Replicas    int
}

var Streams = []StreamConfig{
    // 세금계산서 처리 스트림
    {
        Name:      "INVOICES",
        Subjects:  []string{"invoice.>"},
        Retention: nats.WorkQueuePolicy,
        MaxAge:    7 * 24 * time.Hour,
        MaxMsgs:   100000,
        MaxBytes:  1 << 30, // 1GB
        Replicas:  3,
    },
    // 4대보험 처리 스트림
    {
        Name:      "INSURANCE",
        Subjects:  []string{"insurance.>"},
        Retention: nats.WorkQueuePolicy,
        MaxAge:    30 * 24 * time.Hour,
        MaxMsgs:   50000,
        MaxBytes:  512 << 20, // 512MB
        Replicas:  3,
    },
    // 알림 스트림
    {
        Name:      "NOTIFICATIONS",
        Subjects:  []string{"notification.>"},
        Retention: nats.InterestPolicy,
        MaxAge:    24 * time.Hour,
        MaxMsgs:   500000,
        MaxBytes:  256 << 20, // 256MB
        Replicas:  3,
    },
    // 리포트 생성 스트림
    {
        Name:      "REPORTS",
        Subjects:  []string{"report.>"},
        Retention: nats.WorkQueuePolicy,
        MaxAge:    7 * 24 * time.Hour,
        MaxMsgs:   10000,
        MaxBytes:  128 << 20, // 128MB
        Replicas:  3,
    },
}
```

### 2.2 Consumer 정의

```go
// internal/infrastructure/nats/consumers.go
package nats

import (
    "time"

    "github.com/nats-io/nats.go"
)

type ConsumerConfig struct {
    Stream       string
    Name         string
    FilterSubject string
    MaxDeliver   int
    AckWait      time.Duration
    MaxAckPending int
}

var Consumers = []ConsumerConfig{
    // 세금계산서 발행 Consumer
    {
        Stream:        "INVOICES",
        Name:          "invoice-issuer",
        FilterSubject: "invoice.issue.*",
        MaxDeliver:    5,
        AckWait:       60 * time.Second,
        MaxAckPending: 100,
    },
    // 세금계산서 스크래핑 Consumer
    {
        Stream:        "INVOICES",
        Name:          "invoice-scraper",
        FilterSubject: "invoice.scrape.*",
        MaxDeliver:    3,
        AckWait:       120 * time.Second,  // 스크래핑은 시간 소요
        MaxAckPending: 10,
    },
    // 4대보험 신고 Consumer
    {
        Stream:        "INSURANCE",
        Name:          "insurance-reporter",
        FilterSubject: "insurance.report.*",
        MaxDeliver:    3,
        AckWait:       180 * time.Second,
        MaxAckPending: 5,
    },
    // 알림톡 발송 Consumer
    {
        Stream:        "NOTIFICATIONS",
        Name:          "notification-sender",
        FilterSubject: "notification.send.*",
        MaxDeliver:    3,
        AckWait:       30 * time.Second,
        MaxAckPending: 200,
    },
}
```

### 2.3 NATS 클라이언트 구현

```go
// internal/infrastructure/nats/client.go
package nats

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/nats-io/nats.go"
    "github.com/rs/zerolog/log"
)

type Client struct {
    conn *nats.Conn
    js   nats.JetStreamContext
}

func NewClient(url string) (*Client, error) {
    opts := []nats.Option{
        nats.RetryOnFailedConnect(true),
        nats.MaxReconnects(10),
        nats.ReconnectWait(2 * time.Second),
        nats.DisconnectErrHandler(func(nc *nats.Conn, err error) {
            log.Warn().Err(err).Msg("NATS disconnected")
        }),
        nats.ReconnectHandler(func(nc *nats.Conn) {
            log.Info().Str("url", nc.ConnectedUrl()).Msg("NATS reconnected")
        }),
    }

    conn, err := nats.Connect(url, opts...)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to NATS: %w", err)
    }

    js, err := conn.JetStream()
    if err != nil {
        conn.Close()
        return nil, fmt.Errorf("failed to create JetStream context: %w", err)
    }

    return &Client{conn: conn, js: js}, nil
}

func (c *Client) Close() error {
    c.conn.Close()
    return nil
}

// Stream 초기화
func (c *Client) SetupStreams(ctx context.Context) error {
    for _, cfg := range Streams {
        _, err := c.js.AddStream(&nats.StreamConfig{
            Name:      cfg.Name,
            Subjects:  cfg.Subjects,
            Retention: cfg.Retention,
            MaxAge:    cfg.MaxAge,
            MaxMsgs:   cfg.MaxMsgs,
            MaxBytes:  cfg.MaxBytes,
            Replicas:  cfg.Replicas,
            Storage:   nats.FileStorage,
        })
        if err != nil && err != nats.ErrStreamNameAlreadyInUse {
            return fmt.Errorf("failed to create stream %s: %w", cfg.Name, err)
        }
        log.Info().Str("stream", cfg.Name).Msg("Stream created/verified")
    }
    return nil
}

// 메시지 발행
func (c *Client) Publish(ctx context.Context, subject string, data interface{}) error {
    payload, err := json.Marshal(data)
    if err != nil {
        return fmt.Errorf("failed to marshal message: %w", err)
    }

    _, err = c.js.Publish(subject, payload)
    if err != nil {
        return fmt.Errorf("failed to publish message: %w", err)
    }

    return nil
}

// Consumer 구독
func (c *Client) Subscribe(consumerName string, handler func(*nats.Msg) error) (*nats.Subscription, error) {
    var cfg ConsumerConfig
    for _, consumer := range Consumers {
        if consumer.Name == consumerName {
            cfg = consumer
            break
        }
    }

    if cfg.Name == "" {
        return nil, fmt.Errorf("consumer not found: %s", consumerName)
    }

    sub, err := c.js.PullSubscribe(
        cfg.FilterSubject,
        cfg.Name,
        nats.AckWait(cfg.AckWait),
        nats.MaxDeliver(cfg.MaxDeliver),
        nats.MaxAckPending(cfg.MaxAckPending),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to subscribe: %w", err)
    }

    // Start consuming goroutine
    go func() {
        for {
            msgs, err := sub.Fetch(10, nats.MaxWait(5*time.Second))
            if err != nil {
                if err == nats.ErrTimeout {
                    continue
                }
                log.Error().Err(err).Str("consumer", consumerName).Msg("Fetch error")
                continue
            }

            for _, msg := range msgs {
                if err := handler(msg); err != nil {
                    log.Error().Err(err).Str("subject", msg.Subject).Msg("Handler error")
                    msg.Nak()
                } else {
                    msg.Ack()
                }
            }
        }
    }()

    return sub, nil
}
```

---

## 3. 이벤트 기반 처리

### 3.1 이벤트 정의

```go
// internal/domain/events/events.go
package events

import (
    "time"

    "github.com/google/uuid"
)

type Event interface {
    EventType() string
    AggregateID() uuid.UUID
    OccurredAt() time.Time
}

type BaseEvent struct {
    ID          uuid.UUID `json:"id"`
    Type        string    `json:"type"`
    AggregateID uuid.UUID `json:"aggregate_id"`
    CompanyID   uuid.UUID `json:"company_id"`
    Timestamp   time.Time `json:"timestamp"`
}

func (e BaseEvent) EventType() string       { return e.Type }
func (e BaseEvent) AggregateID() uuid.UUID  { return e.AggregateID }
func (e BaseEvent) OccurredAt() time.Time   { return e.Timestamp }

// 세금계산서 이벤트
type InvoiceIssueRequested struct {
    BaseEvent
    InvoiceID    uuid.UUID `json:"invoice_id"`
    InvoiceType  string    `json:"invoice_type"`
    SupplyAmount int64     `json:"supply_amount"`
    TaxAmount    int64     `json:"tax_amount"`
}

type InvoiceIssued struct {
    BaseEvent
    InvoiceID     uuid.UUID `json:"invoice_id"`
    NTSConfirmNum string    `json:"nts_confirm_num"`
    IssuedAt      time.Time `json:"issued_at"`
    Provider      string    `json:"provider"`
}

type InvoiceIssueFailed struct {
    BaseEvent
    InvoiceID    uuid.UUID `json:"invoice_id"`
    ErrorCode    string    `json:"error_code"`
    ErrorMessage string    `json:"error_message"`
}

// 4대보험 이벤트
type InsuranceReportRequested struct {
    BaseEvent
    ReportID   uuid.UUID `json:"report_id"`
    AgencyType string    `json:"agency_type"`
    ReportType string    `json:"report_type"`
    EmployeeID uuid.UUID `json:"employee_id"`
}

type InsuranceReportSubmitted struct {
    BaseEvent
    ReportID      uuid.UUID `json:"report_id"`
    ReceiptNumber string    `json:"receipt_number"`
    SubmittedAt   time.Time `json:"submitted_at"`
}

// 알림 이벤트
type NotificationRequested struct {
    BaseEvent
    NotificationType string                 `json:"notification_type"`
    Channel          string                 `json:"channel"` // alimtalk, sms, email
    Recipient        string                 `json:"recipient"`
    TemplateCode     string                 `json:"template_code"`
    Variables        map[string]string      `json:"variables"`
}
```

### 3.2 이벤트 발행자

```go
// internal/service/events/publisher.go
package events

import (
    "context"
    "fmt"

    "github.com/google/uuid"
    "github.com/kerp/internal/domain/events"
    "github.com/kerp/internal/infrastructure/nats"
)

type Publisher struct {
    natsClient *nats.Client
}

func NewPublisher(natsClient *nats.Client) *Publisher {
    return &Publisher{natsClient: natsClient}
}

// 세금계산서 발행 요청 이벤트
func (p *Publisher) PublishInvoiceIssueRequested(ctx context.Context,
    companyID, invoiceID uuid.UUID, invoiceType string,
    supplyAmount, taxAmount int64) error {

    event := events.InvoiceIssueRequested{
        BaseEvent: events.BaseEvent{
            ID:          uuid.New(),
            Type:        "invoice.issue.requested",
            AggregateID: invoiceID,
            CompanyID:   companyID,
            Timestamp:   time.Now(),
        },
        InvoiceID:    invoiceID,
        InvoiceType:  invoiceType,
        SupplyAmount: supplyAmount,
        TaxAmount:    taxAmount,
    }

    subject := fmt.Sprintf("invoice.issue.%s", companyID)
    return p.natsClient.Publish(ctx, subject, event)
}

// 4대보험 신고 요청 이벤트
func (p *Publisher) PublishInsuranceReportRequested(ctx context.Context,
    companyID, reportID uuid.UUID, agencyType, reportType string,
    employeeID uuid.UUID) error {

    event := events.InsuranceReportRequested{
        BaseEvent: events.BaseEvent{
            ID:          uuid.New(),
            Type:        "insurance.report.requested",
            AggregateID: reportID,
            CompanyID:   companyID,
            Timestamp:   time.Now(),
        },
        ReportID:   reportID,
        AgencyType: agencyType,
        ReportType: reportType,
        EmployeeID: employeeID,
    }

    subject := fmt.Sprintf("insurance.report.%s", companyID)
    return p.natsClient.Publish(ctx, subject, event)
}

// 알림 발송 요청 이벤트
func (p *Publisher) PublishNotificationRequested(ctx context.Context,
    companyID uuid.UUID, notifType, channel, recipient, templateCode string,
    variables map[string]string) error {

    event := events.NotificationRequested{
        BaseEvent: events.BaseEvent{
            ID:          uuid.New(),
            Type:        "notification.send.requested",
            CompanyID:   companyID,
            Timestamp:   time.Now(),
        },
        NotificationType: notifType,
        Channel:          channel,
        Recipient:        recipient,
        TemplateCode:     templateCode,
        Variables:        variables,
    }

    subject := fmt.Sprintf("notification.send.%s", channel)
    return p.natsClient.Publish(ctx, subject, event)
}
```

### 3.3 이벤트 핸들러

```go
// internal/worker/handlers/invoice_handler.go
package handlers

import (
    "context"
    "encoding/json"

    "github.com/nats-io/nats.go"
    "github.com/kerp/internal/domain/events"
    "github.com/kerp/internal/service/invoice"
    "github.com/rs/zerolog/log"
)

type InvoiceHandler struct {
    invoiceService *invoice.Service
    eventPublisher *events.Publisher
}

func NewInvoiceHandler(invoiceService *invoice.Service,
    eventPublisher *events.Publisher) *InvoiceHandler {
    return &InvoiceHandler{
        invoiceService: invoiceService,
        eventPublisher: eventPublisher,
    }
}

func (h *InvoiceHandler) HandleIssueRequested(msg *nats.Msg) error {
    ctx := context.Background()

    var event events.InvoiceIssueRequested
    if err := json.Unmarshal(msg.Data, &event); err != nil {
        return err
    }

    log.Info().
        Str("invoice_id", event.InvoiceID.String()).
        Str("company_id", event.CompanyID.String()).
        Msg("Processing invoice issue request")

    // Provider Chain으로 세금계산서 발행
    result, err := h.invoiceService.IssueInvoice(ctx, event.InvoiceID)
    if err != nil {
        // 실패 이벤트 발행
        h.eventPublisher.PublishInvoiceIssueFailed(ctx,
            event.CompanyID, event.InvoiceID, "ISSUE_FAILED", err.Error())
        return err
    }

    // 성공 이벤트 발행
    h.eventPublisher.PublishInvoiceIssued(ctx,
        event.CompanyID, event.InvoiceID,
        result.NTSConfirmNum, result.IssueDate, result.Provider)

    // 알림 발송 요청
    h.eventPublisher.PublishNotificationRequested(ctx,
        event.CompanyID, "INVOICE_ISSUED", "alimtalk",
        result.RecipientPhone, "INVOICE_ISSUED",
        map[string]string{
            "#{승인번호}": result.NTSConfirmNum,
            "#{공급가액}": formatAmount(event.SupplyAmount),
        })

    return nil
}
```

---

## 4. WebSocket 실시간 알림

### 4.1 WebSocket Hub

```go
// internal/infrastructure/websocket/hub.go
package websocket

import (
    "sync"

    "github.com/google/uuid"
)

type Hub struct {
    mu         sync.RWMutex
    clients    map[*Client]bool
    companies  map[uuid.UUID]map[*Client]bool
    users      map[uuid.UUID]map[*Client]bool
    broadcast  chan *Message
    register   chan *Client
    unregister chan *Client
}

type Message struct {
    Type      string      `json:"type"`
    CompanyID uuid.UUID   `json:"company_id,omitempty"`
    UserID    uuid.UUID   `json:"user_id,omitempty"`
    Payload   interface{} `json:"payload"`
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*Client]bool),
        companies:  make(map[uuid.UUID]map[*Client]bool),
        users:      make(map[uuid.UUID]map[*Client]bool),
        broadcast:  make(chan *Message, 256),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.mu.Lock()
            h.clients[client] = true

            // Company별 등록
            if _, ok := h.companies[client.CompanyID]; !ok {
                h.companies[client.CompanyID] = make(map[*Client]bool)
            }
            h.companies[client.CompanyID][client] = true

            // User별 등록
            if _, ok := h.users[client.UserID]; !ok {
                h.users[client.UserID] = make(map[*Client]bool)
            }
            h.users[client.UserID][client] = true
            h.mu.Unlock()

        case client := <-h.unregister:
            h.mu.Lock()
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                delete(h.companies[client.CompanyID], client)
                delete(h.users[client.UserID], client)
                close(client.send)
            }
            h.mu.Unlock()

        case message := <-h.broadcast:
            h.handleBroadcast(message)
        }
    }
}

func (h *Hub) handleBroadcast(message *Message) {
    h.mu.RLock()
    defer h.mu.RUnlock()

    var clients map[*Client]bool

    // 특정 사용자에게만 전송
    if message.UserID != uuid.Nil {
        clients = h.users[message.UserID]
    // 특정 회사에게 전송
    } else if message.CompanyID != uuid.Nil {
        clients = h.companies[message.CompanyID]
    // 전체 브로드캐스트 (관리자용)
    } else {
        clients = h.clients
    }

    for client := range clients {
        select {
        case client.send <- message:
        default:
            close(client.send)
            delete(h.clients, client)
        }
    }
}

// 회사별 메시지 전송
func (h *Hub) SendToCompany(companyID uuid.UUID, msgType string, payload interface{}) {
    h.broadcast <- &Message{
        Type:      msgType,
        CompanyID: companyID,
        Payload:   payload,
    }
}

// 사용자별 메시지 전송
func (h *Hub) SendToUser(userID uuid.UUID, msgType string, payload interface{}) {
    h.broadcast <- &Message{
        Type:   msgType,
        UserID: userID,
        Payload: payload,
    }
}
```

### 4.2 WebSocket Client

```go
// internal/infrastructure/websocket/client.go
package websocket

import (
    "encoding/json"
    "time"

    "github.com/google/uuid"
    "github.com/gorilla/websocket"
    "github.com/rs/zerolog/log"
)

const (
    writeWait      = 10 * time.Second
    pongWait       = 60 * time.Second
    pingPeriod     = (pongWait * 9) / 10
    maxMessageSize = 512
)

type Client struct {
    hub       *Hub
    conn      *websocket.Conn
    send      chan *Message
    CompanyID uuid.UUID
    UserID    uuid.UUID
}

func NewClient(hub *Hub, conn *websocket.Conn, companyID, userID uuid.UUID) *Client {
    return &Client{
        hub:       hub,
        conn:      conn,
        send:      make(chan *Message, 256),
        CompanyID: companyID,
        UserID:    userID,
    }
}

func (c *Client) ReadPump() {
    defer func() {
        c.hub.unregister <- c
        c.conn.Close()
    }()

    c.conn.SetReadLimit(maxMessageSize)
    c.conn.SetReadDeadline(time.Now().Add(pongWait))
    c.conn.SetPongHandler(func(string) error {
        c.conn.SetReadDeadline(time.Now().Add(pongWait))
        return nil
    })

    for {
        _, _, err := c.conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err,
                websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                log.Error().Err(err).Msg("WebSocket read error")
            }
            break
        }
    }
}

func (c *Client) WritePump() {
    ticker := time.NewTicker(pingPeriod)
    defer func() {
        ticker.Stop()
        c.conn.Close()
    }()

    for {
        select {
        case message, ok := <-c.send:
            c.conn.SetWriteDeadline(time.Now().Add(writeWait))
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }

            w, err := c.conn.NextWriter(websocket.TextMessage)
            if err != nil {
                return
            }

            data, _ := json.Marshal(message)
            w.Write(data)

            if err := w.Close(); err != nil {
                return
            }

        case <-ticker.C:
            c.conn.SetWriteDeadline(time.Now().Add(writeWait))
            if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                return
            }
        }
    }
}
```

### 4.3 WebSocket Handler

```go
// internal/handler/websocket_handler.go
package handler

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "github.com/gorilla/websocket"
    "github.com/kerp/internal/infrastructure/websocket"
    "github.com/kerp/internal/middleware"
)

var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
    CheckOrigin: func(r *http.Request) bool {
        // Production에서는 Origin 검증 필요
        return true
    },
}

type WebSocketHandler struct {
    hub *websocket.Hub
}

func NewWebSocketHandler(hub *websocket.Hub) *WebSocketHandler {
    return &WebSocketHandler{hub: hub}
}

func (h *WebSocketHandler) ServeWS(c *gin.Context) {
    // JWT에서 사용자 정보 추출
    claims := middleware.GetClaims(c)
    if claims == nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
        return
    }

    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        return
    }

    client := websocket.NewClient(h.hub, conn, claims.CompanyID, claims.UserID)
    h.hub.register <- client

    go client.WritePump()
    go client.ReadPump()
}
```

---

## 5. 비동기 작업 처리

### 5.1 Worker 구현

```go
// cmd/worker/main.go
package main

import (
    "context"
    "os"
    "os/signal"
    "syscall"

    "github.com/kerp/internal/config"
    "github.com/kerp/internal/infrastructure/nats"
    "github.com/kerp/internal/worker"
    "github.com/rs/zerolog/log"
)

func main() {
    cfg := config.Load()

    // NATS 연결
    natsClient, err := nats.NewClient(cfg.NATS.URL)
    if err != nil {
        log.Fatal().Err(err).Msg("Failed to connect to NATS")
    }
    defer natsClient.Close()

    // Stream 초기화
    if err := natsClient.SetupStreams(context.Background()); err != nil {
        log.Fatal().Err(err).Msg("Failed to setup streams")
    }

    // Worker 시작
    w := worker.New(cfg, natsClient)
    if err := w.Start(); err != nil {
        log.Fatal().Err(err).Msg("Failed to start worker")
    }

    // Graceful shutdown
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    log.Info().Msg("Shutting down worker...")
    w.Shutdown(context.Background())
}
```

```go
// internal/worker/worker.go
package worker

import (
    "context"
    "sync"

    "github.com/kerp/internal/config"
    "github.com/kerp/internal/infrastructure/nats"
    "github.com/kerp/internal/worker/handlers"
    "github.com/nats-io/nats.go"
    "github.com/rs/zerolog/log"
)

type Worker struct {
    cfg          *config.Config
    natsClient   *nats.Client
    subscriptions []*nats.Subscription
    wg           sync.WaitGroup
}

func New(cfg *config.Config, natsClient *nats.Client) *Worker {
    return &Worker{
        cfg:        cfg,
        natsClient: natsClient,
    }
}

func (w *Worker) Start() error {
    log.Info().Msg("Starting worker...")

    // 핸들러 초기화
    invoiceHandler := handlers.NewInvoiceHandler(/* dependencies */)
    insuranceHandler := handlers.NewInsuranceHandler(/* dependencies */)
    notificationHandler := handlers.NewNotificationHandler(/* dependencies */)

    // Consumer 등록
    consumers := []struct {
        name    string
        handler func(*nats.Msg) error
    }{
        {"invoice-issuer", invoiceHandler.HandleIssueRequested},
        {"invoice-scraper", invoiceHandler.HandleScrapeRequested},
        {"insurance-reporter", insuranceHandler.HandleReportRequested},
        {"notification-sender", notificationHandler.HandleSendRequested},
    }

    for _, consumer := range consumers {
        sub, err := w.natsClient.Subscribe(consumer.name, consumer.handler)
        if err != nil {
            return err
        }
        w.subscriptions = append(w.subscriptions, sub)
        log.Info().Str("consumer", consumer.name).Msg("Consumer started")
    }

    return nil
}

func (w *Worker) Shutdown(ctx context.Context) error {
    log.Info().Msg("Stopping consumers...")

    for _, sub := range w.subscriptions {
        sub.Drain()
    }

    w.wg.Wait()
    return nil
}
```

### 5.2 작업 스케줄러

```go
// internal/worker/scheduler/scheduler.go
package scheduler

import (
    "context"
    "time"

    "github.com/robfig/cron/v3"
    "github.com/rs/zerolog/log"
)

type Scheduler struct {
    cron *cron.Cron
    jobs map[string]cron.EntryID
}

func New() *Scheduler {
    return &Scheduler{
        cron: cron.New(cron.WithSeconds()),
        jobs: make(map[string]cron.EntryID),
    }
}

func (s *Scheduler) Start() {
    s.cron.Start()
    log.Info().Msg("Scheduler started")
}

func (s *Scheduler) Stop() context.Context {
    return s.cron.Stop()
}

func (s *Scheduler) AddJob(name, spec string, job func()) error {
    id, err := s.cron.AddFunc(spec, func() {
        log.Info().Str("job", name).Msg("Running scheduled job")
        start := time.Now()
        job()
        log.Info().
            Str("job", name).
            Dur("duration", time.Since(start)).
            Msg("Scheduled job completed")
    })
    if err != nil {
        return err
    }

    s.jobs[name] = id
    log.Info().Str("job", name).Str("spec", spec).Msg("Job scheduled")
    return nil
}

// 예약된 작업들
func SetupJobs(s *Scheduler, services *Services) {
    // 매일 오전 6시: 세금계산서 자동 수집
    s.AddJob("invoice-auto-scrape", "0 0 6 * * *", func() {
        services.InvoiceScraper.RunAutoScrape(context.Background())
    })

    // 매월 10일 오전 9시: 4대보험 신고
    s.AddJob("insurance-monthly-report", "0 0 9 10 * *", func() {
        services.InsuranceReporter.RunMonthlyReport(context.Background())
    })

    // 매시간: 만료 알림 체크
    s.AddJob("expiry-notification", "0 0 * * * *", func() {
        services.NotificationChecker.CheckExpiry(context.Background())
    })

    // 매일 자정: 통계 집계
    s.AddJob("daily-statistics", "0 0 0 * * *", func() {
        services.StatisticsAggregator.AggregateDaily(context.Background())
    })
}
```

---

**다음 문서**: [11_CI_CD_파이프라인.md](./11_CI_CD_파이프라인.md)
