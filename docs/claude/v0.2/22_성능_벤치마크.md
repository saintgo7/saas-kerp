# K-ERP 성능 벤치마크

## 목차

1. [개요](#1-개요)
2. [벤치마크 환경](#2-벤치마크-환경)
3. [API 성능 테스트](#3-api-성능-테스트)
4. [데이터베이스 성능](#4-데이터베이스-성능)
5. [gRPC 서비스 성능](#5-grpc-서비스-성능)
6. [부하 테스트](#6-부하-테스트)
7. [성능 최적화](#7-성능-최적화)
8. [벤치마크 자동화](#8-벤치마크-자동화)
9. [성능 기준선](#9-성능-기준선)
10. [모니터링 및 알림](#10-모니터링-및-알림)

---

## 1. 개요

### 1.1 성능 목표

| 지표 | 목표 | 측정 방법 |
|------|------|-----------|
| API 응답 시간 (P50) | < 50ms | Prometheus histogram |
| API 응답 시간 (P95) | < 200ms | Prometheus histogram |
| API 응답 시간 (P99) | < 500ms | Prometheus histogram |
| 처리량 (RPS) | > 1,000 | k6 load test |
| 동시 사용자 | > 500 | k6 load test |
| 가용성 | 99.9% | Uptime monitoring |
| 오류율 | < 0.1% | Error rate metrics |

### 1.2 벤치마크 유형

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Performance Testing Types                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌───────────────┐    ┌───────────────┐    ┌───────────────┐          │
│   │   Unit Test   │    │  Load Test    │    │  Stress Test  │          │
│   │               │    │               │    │               │          │
│   │  Single API   │    │  Expected     │    │  Beyond       │          │
│   │  endpoint     │    │  concurrent   │    │  capacity     │          │
│   │  performance  │    │  users        │    │  limits       │          │
│   └───────────────┘    └───────────────┘    └───────────────┘          │
│                                                                          │
│   ┌───────────────┐    ┌───────────────┐    ┌───────────────┐          │
│   │  Spike Test   │    │  Soak Test    │    │ Breakpoint    │          │
│   │               │    │               │    │    Test       │          │
│   │  Sudden       │    │  Extended     │    │               │          │
│   │  traffic      │    │  duration     │    │  Find max     │          │
│   │  increase     │    │  stability    │    │  capacity     │          │
│   └───────────────┘    └───────────────┘    └───────────────┘          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 벤치마크 환경

### 2.1 테스트 환경 구성

```yaml
# infrastructure/performance/environment.yaml

test_environments:
  development:
    api:
      replicas: 1
      cpu: "500m"
      memory: "512Mi"
    database:
      type: "postgresql"
      instance: "db.t3.small"
      connections: 20
    redis:
      type: "single"
      memory: "256Mi"

  staging:
    api:
      replicas: 2
      cpu: "1000m"
      memory: "1Gi"
    database:
      type: "postgresql"
      instance: "db.t3.medium"
      connections: 50
    redis:
      type: "cluster"
      memory: "1Gi"

  performance:
    api:
      replicas: 3
      cpu: "2000m"
      memory: "4Gi"
    database:
      type: "postgresql"
      instance: "db.r5.large"
      connections: 100
    redis:
      type: "cluster"
      memory: "4Gi"
    load_generator:
      type: "k6"
      vus: 500
      duration: "30m"
```

### 2.2 테스트 데이터 세트

```go
// internal/benchmark/testdata/generator.go

package testdata

import (
    "context"
    "fmt"
    "math/rand"
    "time"

    "github.com/google/uuid"
    "kerp/internal/domain"
)

type TestDataGenerator struct {
    db Database
}

type DataSize string

const (
    DataSizeSmall  DataSize = "small"   // 1K records per table
    DataSizeMedium DataSize = "medium"  // 10K records per table
    DataSizeLarge  DataSize = "large"   // 100K records per table
    DataSizeXLarge DataSize = "xlarge"  // 1M records per table
)

type DataConfig struct {
    Companies      int
    UsersPerCompany int
    PartnersPerCompany int
    AccountsPerCompany int
    VouchersPerMonth int
    MonthsOfData int
}

var DataConfigs = map[DataSize]DataConfig{
    DataSizeSmall: {
        Companies:          5,
        UsersPerCompany:    10,
        PartnersPerCompany: 50,
        AccountsPerCompany: 100,
        VouchersPerMonth:   100,
        MonthsOfData:       3,
    },
    DataSizeMedium: {
        Companies:          20,
        UsersPerCompany:    25,
        PartnersPerCompany: 200,
        AccountsPerCompany: 150,
        VouchersPerMonth:   500,
        MonthsOfData:       12,
    },
    DataSizeLarge: {
        Companies:          100,
        UsersPerCompany:    50,
        PartnersPerCompany: 500,
        AccountsPerCompany: 200,
        VouchersPerMonth:   2000,
        MonthsOfData:       24,
    },
    DataSizeXLarge: {
        Companies:          500,
        UsersPerCompany:    100,
        PartnersPerCompany: 1000,
        AccountsPerCompany: 300,
        VouchersPerMonth:   5000,
        MonthsOfData:       36,
    },
}

// GenerateTestData creates test data for performance testing
func (g *TestDataGenerator) GenerateTestData(ctx context.Context, size DataSize) error {
    config := DataConfigs[size]

    fmt.Printf("Generating test data: %s\n", size)
    fmt.Printf("  Companies: %d\n", config.Companies)

    for i := 0; i < config.Companies; i++ {
        company := g.generateCompany(i)
        if err := g.db.CreateCompany(ctx, company); err != nil {
            return fmt.Errorf("failed to create company %d: %w", i, err)
        }

        // Generate users
        for j := 0; j < config.UsersPerCompany; j++ {
            user := g.generateUser(company.ID, j)
            if err := g.db.CreateUser(ctx, user); err != nil {
                return err
            }
        }

        // Generate partners
        for j := 0; j < config.PartnersPerCompany; j++ {
            partner := g.generatePartner(company.ID, j)
            if err := g.db.CreatePartner(ctx, partner); err != nil {
                return err
            }
        }

        // Generate accounts
        accounts := g.generateChartOfAccounts(company.ID, config.AccountsPerCompany)
        for _, acc := range accounts {
            if err := g.db.CreateAccount(ctx, acc); err != nil {
                return err
            }
        }

        // Generate vouchers
        for month := 0; month < config.MonthsOfData; month++ {
            date := time.Now().AddDate(0, -month, 0)
            for v := 0; v < config.VouchersPerMonth; v++ {
                voucher := g.generateVoucher(company.ID, accounts, date)
                if err := g.db.CreateVoucher(ctx, voucher); err != nil {
                    return err
                }
            }
        }

        if (i+1)%10 == 0 {
            fmt.Printf("  Progress: %d/%d companies\n", i+1, config.Companies)
        }
    }

    return nil
}

func (g *TestDataGenerator) generateCompany(index int) *domain.Company {
    return &domain.Company{
        ID:             uuid.New(),
        Name:           fmt.Sprintf("Test Company %d", index),
        BusinessNumber: fmt.Sprintf("%03d-%02d-%05d", rand.Intn(999), rand.Intn(99), rand.Intn(99999)),
        Status:         domain.CompanyStatusActive,
        CreatedAt:      time.Now(),
    }
}

func (g *TestDataGenerator) generateUser(companyID uuid.UUID, index int) *domain.User {
    return &domain.User{
        ID:        uuid.New(),
        CompanyID: companyID,
        Email:     fmt.Sprintf("user%d@test.com", index),
        Name:      fmt.Sprintf("Test User %d", index),
        Role:      domain.RoleUser,
        Status:    domain.UserStatusActive,
        CreatedAt: time.Now(),
    }
}

func (g *TestDataGenerator) generatePartner(companyID uuid.UUID, index int) *domain.Partner {
    return &domain.Partner{
        ID:             uuid.New(),
        CompanyID:      companyID,
        Code:           fmt.Sprintf("P%05d", index),
        Name:           fmt.Sprintf("Partner %d", index),
        BusinessNumber: fmt.Sprintf("%03d-%02d-%05d", rand.Intn(999), rand.Intn(99), rand.Intn(99999)),
        PartnerType:    domain.PartnerType(rand.Intn(3)),
        IsActive:       true,
        CreatedAt:      time.Now(),
    }
}

func (g *TestDataGenerator) generateChartOfAccounts(companyID uuid.UUID, count int) []*domain.Account {
    // Generate standard K-IFRS chart of accounts
    // ...
    return nil
}

func (g *TestDataGenerator) generateVoucher(companyID uuid.UUID, accounts []*domain.Account, date time.Time) *domain.Voucher {
    amount := int64((rand.Intn(1000) + 1) * 10000) // 10,000 ~ 10,000,000

    // Random accounts for debit and credit
    debitIdx := rand.Intn(len(accounts))
    creditIdx := rand.Intn(len(accounts))
    for creditIdx == debitIdx {
        creditIdx = rand.Intn(len(accounts))
    }

    voucher := &domain.Voucher{
        ID:           uuid.New(),
        CompanyID:    companyID,
        VoucherDate:  date,
        VoucherType:  domain.VoucherTypeGeneral,
        Description:  fmt.Sprintf("Test voucher %s", date.Format("2006-01-02")),
        Status:       domain.VoucherStatusApproved,
        TotalDebit:   amount,
        TotalCredit:  amount,
        CreatedAt:    time.Now(),
        Lines: []domain.VoucherLine{
            {
                ID:          uuid.New(),
                AccountID:   accounts[debitIdx].ID,
                DebitAmount: amount,
                LineNumber:  1,
            },
            {
                ID:           uuid.New(),
                AccountID:    accounts[creditIdx].ID,
                CreditAmount: amount,
                LineNumber:   2,
            },
        },
    }

    return voucher
}
```

---

## 3. API 성능 테스트

### 3.1 Go HTTP 벤치마크

```go
// internal/benchmark/api_benchmark_test.go

package benchmark

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
    "kerp/internal/handler"
    "kerp/internal/service"
)

func BenchmarkVoucherCreate(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := setupTestRouter()

    payload := map[string]interface{}{
        "voucher_date":  "2025-01-15",
        "voucher_type":  "general",
        "description":   "Test voucher",
        "lines": []map[string]interface{}{
            {"account_id": "acc-001", "debit_amount": 100000},
            {"account_id": "acc-002", "credit_amount": 100000},
        },
    }
    body, _ := json.Marshal(payload)

    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            req := httptest.NewRequest("POST", "/api/v1/vouchers", bytes.NewReader(body))
            req.Header.Set("Content-Type", "application/json")
            req.Header.Set("Authorization", "Bearer test-token")

            w := httptest.NewRecorder()
            router.ServeHTTP(w, req)

            if w.Code != http.StatusCreated {
                b.Errorf("Expected status 201, got %d", w.Code)
            }
        }
    })
}

func BenchmarkVoucherList(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := setupTestRouter()

    scenarios := []struct {
        name   string
        params string
    }{
        {"NoFilter", ""},
        {"DateFilter", "?from_date=2025-01-01&to_date=2025-01-31"},
        {"Pagination", "?page=1&page_size=20"},
        {"FullFilter", "?from_date=2025-01-01&to_date=2025-01-31&status=approved&page=1&page_size=50"},
    }

    for _, sc := range scenarios {
        b.Run(sc.name, func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                req := httptest.NewRequest("GET", "/api/v1/vouchers"+sc.params, nil)
                req.Header.Set("Authorization", "Bearer test-token")

                w := httptest.NewRecorder()
                router.ServeHTTP(w, req)

                if w.Code != http.StatusOK {
                    b.Errorf("Expected status 200, got %d", w.Code)
                }
            }
        })
    }
}

func BenchmarkTrialBalance(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := setupTestRouter()

    dataSizes := []string{"small", "medium", "large"}

    for _, size := range dataSizes {
        b.Run(size, func(b *testing.B) {
            // Setup data for each size
            setupTestData(size)

            b.ResetTimer()
            for i := 0; i < b.N; i++ {
                req := httptest.NewRequest("GET", "/api/v1/reports/trial-balance?year=2025&month=1", nil)
                req.Header.Set("Authorization", "Bearer test-token")

                w := httptest.NewRecorder()
                router.ServeHTTP(w, req)

                if w.Code != http.StatusOK {
                    b.Errorf("Expected status 200, got %d", w.Code)
                }
            }
        })
    }
}

func BenchmarkConcurrentOperations(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := setupTestRouter()

    operations := []struct {
        method string
        path   string
        body   []byte
    }{
        {"GET", "/api/v1/vouchers", nil},
        {"GET", "/api/v1/partners", nil},
        {"GET", "/api/v1/accounts", nil},
        {"POST", "/api/v1/vouchers", createVoucherPayload()},
    }

    b.RunParallel(func(pb *testing.PB) {
        opIdx := 0
        for pb.Next() {
            op := operations[opIdx%len(operations)]
            opIdx++

            var body *bytes.Reader
            if op.body != nil {
                body = bytes.NewReader(op.body)
            }

            req := httptest.NewRequest(op.method, op.path, body)
            req.Header.Set("Content-Type", "application/json")
            req.Header.Set("Authorization", "Bearer test-token")

            w := httptest.NewRecorder()
            router.ServeHTTP(w, req)
        }
    })
}

// Memory allocation benchmark
func BenchmarkMemoryAllocation(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := setupTestRouter()

    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        req := httptest.NewRequest("GET", "/api/v1/vouchers?page=1&page_size=100", nil)
        req.Header.Set("Authorization", "Bearer test-token")

        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)
    }
}

func setupTestRouter() *gin.Engine {
    // Setup test router with mocked dependencies
    return gin.New()
}

func setupTestData(size string) {
    // Setup test data for specific size
}

func createVoucherPayload() []byte {
    payload := map[string]interface{}{
        "voucher_date": "2025-01-15",
        "voucher_type": "general",
        "description":  "Benchmark test",
        "lines": []map[string]interface{}{
            {"account_id": "acc-001", "debit_amount": 100000},
            {"account_id": "acc-002", "credit_amount": 100000},
        },
    }
    body, _ := json.Marshal(payload)
    return body
}
```

### 3.2 k6 부하 테스트 스크립트

```javascript
// tests/performance/k6/api_load_test.js

import http from 'k6/http';
import { check, sleep, group } from 'k6';
import { Rate, Trend } from 'k6/metrics';
import { randomItem, randomIntBetween } from 'https://jslib.k6.io/k6-utils/1.2.0/index.js';

// Custom metrics
const errorRate = new Rate('errors');
const voucherCreateDuration = new Trend('voucher_create_duration');
const voucherListDuration = new Trend('voucher_list_duration');
const reportGenerateDuration = new Trend('report_generate_duration');

// Test configuration
export const options = {
    scenarios: {
        // Constant load test
        constant_load: {
            executor: 'constant-vus',
            vus: 50,
            duration: '5m',
            tags: { scenario: 'constant' },
        },
        // Ramping load test
        ramping_load: {
            executor: 'ramping-vus',
            startVUs: 0,
            stages: [
                { duration: '2m', target: 100 },
                { duration: '5m', target: 100 },
                { duration: '2m', target: 200 },
                { duration: '5m', target: 200 },
                { duration: '2m', target: 0 },
            ],
            tags: { scenario: 'ramping' },
        },
        // Spike test
        spike_test: {
            executor: 'ramping-vus',
            startVUs: 0,
            stages: [
                { duration: '1m', target: 50 },
                { duration: '30s', target: 500 }, // Spike
                { duration: '1m', target: 500 },
                { duration: '30s', target: 50 },
                { duration: '1m', target: 50 },
            ],
            tags: { scenario: 'spike' },
        },
    },
    thresholds: {
        http_req_duration: ['p(95)<200', 'p(99)<500'],
        errors: ['rate<0.01'],
        voucher_create_duration: ['p(95)<300'],
        voucher_list_duration: ['p(95)<150'],
        report_generate_duration: ['p(95)<1000'],
    },
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:8080';
const API_TOKEN = __ENV.API_TOKEN || 'test-token';

const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${API_TOKEN}`,
};

// Test data
const accountIds = ['acc-1101', 'acc-1102', 'acc-2101', 'acc-4101', 'acc-5201'];
const partnerIds = ['p-001', 'p-002', 'p-003', 'p-004', 'p-005'];

export function setup() {
    // Verify API is accessible
    const res = http.get(`${BASE_URL}/health`, { headers });
    if (res.status !== 200) {
        throw new Error('API is not accessible');
    }
    return { startTime: new Date().toISOString() };
}

export default function() {
    group('Voucher Operations', function() {
        // List vouchers
        group('List Vouchers', function() {
            const startTime = Date.now();
            const res = http.get(`${BASE_URL}/api/v1/vouchers?page=1&page_size=20`, { headers });
            voucherListDuration.add(Date.now() - startTime);

            check(res, {
                'list vouchers status is 200': (r) => r.status === 200,
                'list vouchers has data': (r) => JSON.parse(r.body).data !== undefined,
            }) || errorRate.add(1);
        });

        // Create voucher
        group('Create Voucher', function() {
            const payload = JSON.stringify({
                voucher_date: new Date().toISOString().split('T')[0],
                voucher_type: 'general',
                description: `k6 load test - ${Date.now()}`,
                lines: [
                    {
                        account_id: randomItem(accountIds),
                        partner_id: randomItem(partnerIds),
                        debit_amount: randomIntBetween(10000, 1000000),
                        description: 'Debit entry',
                    },
                    {
                        account_id: randomItem(accountIds),
                        credit_amount: randomIntBetween(10000, 1000000),
                        description: 'Credit entry',
                    },
                ],
            });

            const startTime = Date.now();
            const res = http.post(`${BASE_URL}/api/v1/vouchers`, payload, { headers });
            voucherCreateDuration.add(Date.now() - startTime);

            check(res, {
                'create voucher status is 201': (r) => r.status === 201,
                'create voucher returns id': (r) => JSON.parse(r.body).data.id !== undefined,
            }) || errorRate.add(1);
        });
    });

    group('Partner Operations', function() {
        const res = http.get(`${BASE_URL}/api/v1/partners?page=1&page_size=50`, { headers });

        check(res, {
            'list partners status is 200': (r) => r.status === 200,
        }) || errorRate.add(1);
    });

    group('Report Generation', function() {
        const year = new Date().getFullYear();
        const month = new Date().getMonth() + 1;

        const startTime = Date.now();
        const res = http.get(
            `${BASE_URL}/api/v1/reports/trial-balance?year=${year}&month=${month}`,
            { headers }
        );
        reportGenerateDuration.add(Date.now() - startTime);

        check(res, {
            'trial balance status is 200': (r) => r.status === 200,
            'trial balance has accounts': (r) => {
                const body = JSON.parse(r.body);
                return body.data && body.data.accounts && body.data.accounts.length > 0;
            },
        }) || errorRate.add(1);
    });

    sleep(randomIntBetween(1, 3));
}

export function teardown(data) {
    console.log(`Test started at: ${data.startTime}`);
    console.log(`Test ended at: ${new Date().toISOString()}`);
}
```

---

## 4. 데이터베이스 성능

### 4.1 쿼리 성능 테스트

```go
// internal/benchmark/db_benchmark_test.go

package benchmark

import (
    "context"
    "testing"
    "time"

    "github.com/google/uuid"
)

func BenchmarkQueryTrialBalance(b *testing.B) {
    db := setupTestDB()
    companyID := uuid.MustParse("test-company-id")

    sizes := []struct {
        name        string
        voucherCount int
    }{
        {"1K_vouchers", 1000},
        {"10K_vouchers", 10000},
        {"100K_vouchers", 100000},
    }

    for _, size := range sizes {
        b.Run(size.name, func(b *testing.B) {
            seedVouchers(db, companyID, size.voucherCount)

            b.ResetTimer()
            for i := 0; i < b.N; i++ {
                query := `
                    SELECT
                        a.code,
                        a.name,
                        a.account_type,
                        COALESCE(SUM(vl.debit_amount), 0) as debit_total,
                        COALESCE(SUM(vl.credit_amount), 0) as credit_total
                    FROM accounts a
                    LEFT JOIN voucher_lines vl ON a.id = vl.account_id
                    LEFT JOIN vouchers v ON vl.voucher_id = v.id
                    WHERE a.company_id = $1
                      AND (v.voucher_date BETWEEN $2 AND $3 OR v.id IS NULL)
                      AND (v.status = 'approved' OR v.id IS NULL)
                    GROUP BY a.id, a.code, a.name, a.account_type
                    ORDER BY a.code
                `

                _, err := db.Query(context.Background(), query,
                    companyID,
                    time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC),
                    time.Date(2025, 12, 31, 23, 59, 59, 0, time.UTC),
                )
                if err != nil {
                    b.Fatal(err)
                }
            }
        })
    }
}

func BenchmarkQueryAccountLedger(b *testing.B) {
    db := setupTestDB()
    companyID := uuid.MustParse("test-company-id")
    accountID := uuid.MustParse("test-account-id")

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        query := `
            WITH running_balance AS (
                SELECT
                    v.voucher_date,
                    v.voucher_number,
                    v.description as voucher_description,
                    vl.description as line_description,
                    vl.debit_amount,
                    vl.credit_amount,
                    SUM(vl.debit_amount - vl.credit_amount) OVER (
                        ORDER BY v.voucher_date, v.created_at
                    ) as balance
                FROM voucher_lines vl
                JOIN vouchers v ON vl.voucher_id = v.id
                WHERE vl.account_id = $1
                  AND v.company_id = $2
                  AND v.status = 'approved'
                  AND v.voucher_date BETWEEN $3 AND $4
                ORDER BY v.voucher_date, v.created_at
            )
            SELECT * FROM running_balance
        `

        _, err := db.Query(context.Background(), query,
            accountID,
            companyID,
            time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC),
            time.Date(2025, 12, 31, 23, 59, 59, 0, time.UTC),
        )
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkInsertVoucher(b *testing.B) {
    db := setupTestDB()
    companyID := uuid.MustParse("test-company-id")

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        tx, _ := db.Begin(context.Background())

        voucherID := uuid.New()
        _, err := tx.Exec(context.Background(), `
            INSERT INTO vouchers (id, company_id, voucher_date, voucher_type, description, status, total_debit, total_credit, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `,
            voucherID, companyID, time.Now(), "general", "Benchmark test", "draft", 100000, 100000, time.Now(),
        )
        if err != nil {
            tx.Rollback(context.Background())
            b.Fatal(err)
        }

        // Insert lines
        _, err = tx.Exec(context.Background(), `
            INSERT INTO voucher_lines (id, voucher_id, account_id, debit_amount, credit_amount, line_number)
            VALUES ($1, $2, $3, $4, $5, $6), ($7, $8, $9, $10, $11, $12)
        `,
            uuid.New(), voucherID, uuid.MustParse("account-1"), 100000, 0, 1,
            uuid.New(), voucherID, uuid.MustParse("account-2"), 0, 100000, 2,
        )
        if err != nil {
            tx.Rollback(context.Background())
            b.Fatal(err)
        }

        tx.Commit(context.Background())
    }
}

func BenchmarkBulkInsert(b *testing.B) {
    db := setupTestDB()
    companyID := uuid.MustParse("test-company-id")

    batchSizes := []int{100, 500, 1000, 5000}

    for _, batchSize := range batchSizes {
        b.Run(fmt.Sprintf("batch_%d", batchSize), func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                tx, _ := db.Begin(context.Background())

                // Use COPY for bulk insert
                _, err := tx.CopyFrom(
                    context.Background(),
                    pgx.Identifier{"partners"},
                    []string{"id", "company_id", "code", "name", "is_active", "created_at"},
                    pgx.CopyFromSlice(batchSize, func(i int) ([]interface{}, error) {
                        return []interface{}{
                            uuid.New(),
                            companyID,
                            fmt.Sprintf("P%05d", i),
                            fmt.Sprintf("Partner %d", i),
                            true,
                            time.Now(),
                        }, nil
                    }),
                )
                if err != nil {
                    tx.Rollback(context.Background())
                    b.Fatal(err)
                }

                tx.Commit(context.Background())
            }
        })
    }
}
```

### 4.2 인덱스 성능 분석

```sql
-- scripts/benchmark/analyze_indexes.sql

-- Query execution plan analysis
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT
    a.code,
    a.name,
    COALESCE(SUM(vl.debit_amount), 0) as debit,
    COALESCE(SUM(vl.credit_amount), 0) as credit
FROM accounts a
LEFT JOIN voucher_lines vl ON a.id = vl.account_id
LEFT JOIN vouchers v ON vl.voucher_id = v.id
WHERE a.company_id = 'company-uuid'
  AND v.voucher_date BETWEEN '2025-01-01' AND '2025-12-31'
  AND v.status = 'approved'
GROUP BY a.id
ORDER BY a.code;

-- Index usage statistics
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan as index_scans,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- Unused indexes (candidates for removal)
SELECT
    schemaname || '.' || tablename as table,
    indexname,
    pg_size_pretty(pg_relation_size(i.indexrelid)) as size,
    idx_scan as scans
FROM pg_stat_user_indexes i
JOIN pg_index USING (indexrelid)
WHERE NOT indisunique
  AND idx_scan = 0
  AND schemaname NOT LIKE 'pg_%';

-- Missing indexes (tables with sequential scans)
SELECT
    relname as table_name,
    seq_scan as sequential_scans,
    seq_tup_read as tuples_read_seq,
    idx_scan as index_scans,
    idx_tup_fetch as tuples_fetched_idx,
    ROUND(100.0 * seq_scan / (seq_scan + idx_scan), 2) as seq_scan_pct
FROM pg_stat_user_tables
WHERE seq_scan + idx_scan > 0
  AND seq_scan > idx_scan
ORDER BY seq_tup_read DESC
LIMIT 20;

-- Table bloat estimation
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname || '.' || tablename)) as total_size,
    pg_size_pretty(pg_relation_size(schemaname || '.' || tablename)) as table_size,
    pg_size_pretty(pg_indexes_size(schemaname || '.' || tablename)) as index_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname || '.' || tablename) DESC;
```

---

## 5. gRPC 서비스 성능

### 5.1 Python gRPC 벤치마크

```python
# tests/performance/grpc_benchmark.py

import asyncio
import time
import statistics
from concurrent.futures import ThreadPoolExecutor
from typing import List, Dict, Any

import grpc
from google.protobuf import empty_pb2

from proto import tax_scraper_pb2, tax_scraper_pb2_grpc
from proto import insurance_edi_pb2, insurance_edi_pb2_grpc


class GRPCBenchmark:
    """gRPC service performance benchmarker."""

    def __init__(self, host: str = "localhost", port: int = 50051):
        self.host = host
        self.port = port
        self.results: Dict[str, List[float]] = {}

    async def benchmark_tax_scraper(
        self,
        iterations: int = 100,
        concurrent_requests: int = 10
    ) -> Dict[str, Any]:
        """Benchmark tax scraper gRPC service."""
        channel = grpc.aio.insecure_channel(f"{self.host}:{self.port}")
        stub = tax_scraper_pb2_grpc.TaxScraperServiceStub(channel)

        latencies: List[float] = []
        errors: int = 0

        async def make_request():
            nonlocal errors
            request = tax_scraper_pb2.ScrapeInvoicesRequest(
                business_number="123-45-67890",
                user_id="test-user",
                password="test-pass",
                cert_path="/path/to/cert",
                start_date="2025-01-01",
                end_date="2025-01-31"
            )

            start = time.perf_counter()
            try:
                response = await stub.ScrapeInvoices(request)
                latency = (time.perf_counter() - start) * 1000
                latencies.append(latency)
            except grpc.RpcError as e:
                errors += 1

        # Warmup
        for _ in range(10):
            await make_request()

        # Benchmark
        start_time = time.perf_counter()

        for batch in range(iterations // concurrent_requests):
            tasks = [make_request() for _ in range(concurrent_requests)]
            await asyncio.gather(*tasks)

        total_time = time.perf_counter() - start_time

        await channel.close()

        return {
            "service": "tax-scraper",
            "iterations": iterations,
            "concurrent_requests": concurrent_requests,
            "total_time_seconds": total_time,
            "throughput_rps": iterations / total_time,
            "latency_p50_ms": statistics.median(latencies),
            "latency_p95_ms": sorted(latencies)[int(len(latencies) * 0.95)],
            "latency_p99_ms": sorted(latencies)[int(len(latencies) * 0.99)],
            "latency_avg_ms": statistics.mean(latencies),
            "latency_stddev_ms": statistics.stdev(latencies) if len(latencies) > 1 else 0,
            "error_count": errors,
            "error_rate": errors / iterations,
        }

    async def benchmark_insurance_edi(
        self,
        iterations: int = 100,
        concurrent_requests: int = 10
    ) -> Dict[str, Any]:
        """Benchmark insurance EDI gRPC service."""
        channel = grpc.aio.insecure_channel(f"{self.host}:50052")
        stub = insurance_edi_pb2_grpc.InsuranceEDIServiceStub(channel)

        latencies: List[float] = []
        errors: int = 0

        async def make_request():
            nonlocal errors
            request = insurance_edi_pb2.SubmitReportRequest(
                company_id="company-uuid",
                report_type="NATIONAL_PENSION",
                report_month="2025-01",
                employees=[
                    insurance_edi_pb2.EmployeeData(
                        employee_id="emp-001",
                        name="Test Employee",
                        resident_number="900101-1234567",
                        monthly_salary=3000000
                    )
                ]
            )

            start = time.perf_counter()
            try:
                response = await stub.SubmitReport(request)
                latency = (time.perf_counter() - start) * 1000
                latencies.append(latency)
            except grpc.RpcError as e:
                errors += 1

        # Warmup
        for _ in range(10):
            await make_request()

        # Benchmark
        start_time = time.perf_counter()

        for batch in range(iterations // concurrent_requests):
            tasks = [make_request() for _ in range(concurrent_requests)]
            await asyncio.gather(*tasks)

        total_time = time.perf_counter() - start_time

        await channel.close()

        return {
            "service": "insurance-edi",
            "iterations": iterations,
            "concurrent_requests": concurrent_requests,
            "total_time_seconds": total_time,
            "throughput_rps": iterations / total_time,
            "latency_p50_ms": statistics.median(latencies),
            "latency_p95_ms": sorted(latencies)[int(len(latencies) * 0.95)],
            "latency_p99_ms": sorted(latencies)[int(len(latencies) * 0.99)],
            "latency_avg_ms": statistics.mean(latencies),
            "error_count": errors,
            "error_rate": errors / iterations,
        }

    async def run_all_benchmarks(self) -> List[Dict[str, Any]]:
        """Run all gRPC benchmarks."""
        results = []

        print("Running Tax Scraper benchmark...")
        results.append(await self.benchmark_tax_scraper())

        print("Running Insurance EDI benchmark...")
        results.append(await self.benchmark_insurance_edi())

        return results


def print_benchmark_results(results: List[Dict[str, Any]]):
    """Print benchmark results in a formatted table."""
    print("\n" + "=" * 80)
    print("gRPC Benchmark Results")
    print("=" * 80)

    for result in results:
        print(f"\n{result['service'].upper()}")
        print("-" * 40)
        print(f"  Iterations: {result['iterations']}")
        print(f"  Concurrent: {result['concurrent_requests']}")
        print(f"  Total Time: {result['total_time_seconds']:.2f}s")
        print(f"  Throughput: {result['throughput_rps']:.2f} RPS")
        print(f"  Latency P50: {result['latency_p50_ms']:.2f}ms")
        print(f"  Latency P95: {result['latency_p95_ms']:.2f}ms")
        print(f"  Latency P99: {result['latency_p99_ms']:.2f}ms")
        print(f"  Error Rate: {result['error_rate']*100:.2f}%")


if __name__ == "__main__":
    benchmark = GRPCBenchmark()
    results = asyncio.run(benchmark.run_all_benchmarks())
    print_benchmark_results(results)
```

---

## 6. 부하 테스트

### 6.1 시나리오 기반 부하 테스트

```javascript
// tests/performance/k6/scenarios/realistic_workload.js

import http from 'k6/http';
import { check, sleep, group } from 'k6';
import { SharedArray } from 'k6/data';
import { randomItem } from 'https://jslib.k6.io/k6-utils/1.2.0/index.js';

// Realistic user scenarios based on actual usage patterns
export const options = {
    scenarios: {
        // Morning peak (9-10 AM): High voucher entry
        morning_peak: {
            executor: 'ramping-arrival-rate',
            startTime: '0s',
            startRate: 10,
            timeUnit: '1s',
            preAllocatedVUs: 100,
            maxVUs: 300,
            stages: [
                { target: 50, duration: '2m' },  // Ramp up
                { target: 50, duration: '5m' },  // Sustain peak
                { target: 20, duration: '2m' },  // Ramp down
            ],
            exec: 'voucherEntry',
        },

        // Mid-day: Report generation
        midday_reports: {
            executor: 'constant-arrival-rate',
            startTime: '10m',
            rate: 10,
            timeUnit: '1m',
            duration: '10m',
            preAllocatedVUs: 20,
            exec: 'reportGeneration',
        },

        // End of day: Invoice processing
        eod_invoices: {
            executor: 'ramping-arrival-rate',
            startTime: '20m',
            startRate: 5,
            timeUnit: '1s',
            preAllocatedVUs: 50,
            maxVUs: 150,
            stages: [
                { target: 30, duration: '2m' },
                { target: 30, duration: '5m' },
                { target: 5, duration: '2m' },
            ],
            exec: 'invoiceProcessing',
        },

        // Background: Partner/master data queries
        background_queries: {
            executor: 'constant-vus',
            vus: 10,
            duration: '30m',
            exec: 'backgroundQueries',
        },
    },

    thresholds: {
        'http_req_duration{scenario:morning_peak}': ['p(95)<300'],
        'http_req_duration{scenario:midday_reports}': ['p(95)<2000'],
        'http_req_duration{scenario:eod_invoices}': ['p(95)<500'],
        'http_req_failed': ['rate<0.01'],
    },
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:8080';
const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${__ENV.API_TOKEN}`,
};

// Pre-loaded test data
const accounts = new SharedArray('accounts', function() {
    return JSON.parse(open('./data/accounts.json'));
});

const partners = new SharedArray('partners', function() {
    return JSON.parse(open('./data/partners.json'));
});

// Scenario: Voucher Entry (simulates accountant workflow)
export function voucherEntry() {
    group('Voucher Entry Workflow', function() {
        // 1. List recent vouchers to check duplicates
        let res = http.get(`${BASE_URL}/api/v1/vouchers?page=1&page_size=5`, { headers });
        check(res, { 'list vouchers ok': (r) => r.status === 200 });

        sleep(0.5);

        // 2. Search for partner
        const partner = randomItem(partners);
        res = http.get(`${BASE_URL}/api/v1/partners?q=${partner.name}`, { headers });
        check(res, { 'search partner ok': (r) => r.status === 200 });

        sleep(0.3);

        // 3. Create voucher
        const debitAccount = randomItem(accounts.filter(a => a.type === 'expense'));
        const creditAccount = randomItem(accounts.filter(a => a.type === 'liability'));
        const amount = Math.floor(Math.random() * 1000000) + 10000;

        const voucher = {
            voucher_date: new Date().toISOString().split('T')[0],
            voucher_type: 'general',
            description: `Purchase from ${partner.name}`,
            lines: [
                {
                    account_id: debitAccount.id,
                    partner_id: partner.id,
                    debit_amount: amount,
                },
                {
                    account_id: creditAccount.id,
                    credit_amount: amount,
                },
            ],
        };

        res = http.post(`${BASE_URL}/api/v1/vouchers`, JSON.stringify(voucher), { headers });
        check(res, {
            'create voucher ok': (r) => r.status === 201,
            'voucher has id': (r) => JSON.parse(r.body).data?.id !== undefined,
        });

        sleep(1);
    });
}

// Scenario: Report Generation (simulates manager workflow)
export function reportGeneration() {
    group('Report Generation Workflow', function() {
        const year = new Date().getFullYear();
        const month = new Date().getMonth() + 1;

        // Trial balance
        let res = http.get(
            `${BASE_URL}/api/v1/reports/trial-balance?year=${year}&month=${month}`,
            { headers, timeout: '30s' }
        );
        check(res, { 'trial balance ok': (r) => r.status === 200 });

        sleep(2);

        // Account ledger
        const account = randomItem(accounts);
        res = http.get(
            `${BASE_URL}/api/v1/reports/account-ledger?account_id=${account.id}&year=${year}`,
            { headers, timeout: '30s' }
        );
        check(res, { 'account ledger ok': (r) => r.status === 200 });

        sleep(2);

        // Income statement
        res = http.get(
            `${BASE_URL}/api/v1/reports/income-statement?year=${year}&month=${month}`,
            { headers, timeout: '30s' }
        );
        check(res, { 'income statement ok': (r) => r.status === 200 });

        sleep(3);
    });
}

// Scenario: Invoice Processing (simulates billing workflow)
export function invoiceProcessing() {
    group('Invoice Processing Workflow', function() {
        // 1. List pending invoices
        let res = http.get(`${BASE_URL}/api/v1/invoices?status=draft`, { headers });
        check(res, { 'list invoices ok': (r) => r.status === 200 });

        sleep(0.5);

        // 2. Create invoice
        const partner = randomItem(partners.filter(p => p.type === 'customer'));
        const amount = Math.floor(Math.random() * 10000000) + 100000;

        const invoice = {
            invoice_type: 'sales',
            partner_id: partner.id,
            invoice_date: new Date().toISOString().split('T')[0],
            supply_amount: amount,
            tax_amount: Math.floor(amount * 0.1),
            items: [
                {
                    description: 'Service fee',
                    quantity: 1,
                    unit_price: amount,
                },
            ],
        };

        res = http.post(`${BASE_URL}/api/v1/invoices`, JSON.stringify(invoice), { headers });
        check(res, { 'create invoice ok': (r) => r.status === 201 });

        if (res.status === 201) {
            const invoiceId = JSON.parse(res.body).data.id;

            sleep(0.5);

            // 3. Issue invoice (trigger tax invoice)
            res = http.post(`${BASE_URL}/api/v1/invoices/${invoiceId}/issue`, null, { headers });
            check(res, { 'issue invoice ok': (r) => r.status === 200 });
        }

        sleep(1);
    });
}

// Scenario: Background Queries (simulates ongoing lookups)
export function backgroundQueries() {
    const queries = [
        () => http.get(`${BASE_URL}/api/v1/accounts`, { headers }),
        () => http.get(`${BASE_URL}/api/v1/partners?page=1&page_size=100`, { headers }),
        () => http.get(`${BASE_URL}/api/v1/departments`, { headers }),
        () => http.get(`${BASE_URL}/api/v1/users`, { headers }),
    ];

    const query = randomItem(queries);
    const res = query();
    check(res, { 'background query ok': (r) => r.status === 200 });

    sleep(5);
}
```

---

## 7. 성능 최적화

### 7.1 쿼리 최적화

```go
// internal/repository/optimizations.go

package repository

import (
    "context"
    "time"

    "github.com/google/uuid"
    "github.com/jackc/pgx/v5"
    "github.com/jackc/pgx/v5/pgxpool"
)

type OptimizedVoucherRepository struct {
    pool *pgxpool.Pool
}

// GetTrialBalanceOptimized uses materialized view and parallel execution
func (r *OptimizedVoucherRepository) GetTrialBalanceOptimized(
    ctx context.Context,
    companyID uuid.UUID,
    year, month int,
) ([]TrialBalanceRow, error) {
    // Use materialized view for frequently accessed data
    query := `
        SELECT
            account_id,
            account_code,
            account_name,
            account_type,
            opening_debit,
            opening_credit,
            period_debit,
            period_credit,
            closing_debit,
            closing_credit
        FROM mv_trial_balance
        WHERE company_id = $1
          AND year = $2
          AND month = $3
        ORDER BY account_code
    `

    rows, err := r.pool.Query(ctx, query, companyID, year, month)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var result []TrialBalanceRow
    for rows.Next() {
        var row TrialBalanceRow
        if err := rows.Scan(
            &row.AccountID,
            &row.AccountCode,
            &row.AccountName,
            &row.AccountType,
            &row.OpeningDebit,
            &row.OpeningCredit,
            &row.PeriodDebit,
            &row.PeriodCredit,
            &row.ClosingDebit,
            &row.ClosingCredit,
        ); err != nil {
            return nil, err
        }
        result = append(result, row)
    }

    return result, rows.Err()
}

// BatchInsertVouchers uses COPY protocol for bulk inserts
func (r *OptimizedVoucherRepository) BatchInsertVouchers(
    ctx context.Context,
    vouchers []*Voucher,
) error {
    // Use transaction with COPY
    tx, err := r.pool.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback(ctx)

    // Prepare voucher data
    voucherRows := make([][]interface{}, len(vouchers))
    var allLines [][]interface{}

    for i, v := range vouchers {
        voucherRows[i] = []interface{}{
            v.ID,
            v.CompanyID,
            v.VoucherNumber,
            v.VoucherDate,
            v.VoucherType,
            v.Description,
            v.Status,
            v.TotalDebit,
            v.TotalCredit,
            v.CreatedAt,
            v.CreatedByID,
        }

        for _, line := range v.Lines {
            allLines = append(allLines, []interface{}{
                line.ID,
                v.ID,
                line.AccountID,
                line.PartnerID,
                line.DepartmentID,
                line.DebitAmount,
                line.CreditAmount,
                line.Description,
                line.LineNumber,
            })
        }
    }

    // COPY vouchers
    _, err = tx.CopyFrom(
        ctx,
        pgx.Identifier{"vouchers"},
        []string{"id", "company_id", "voucher_number", "voucher_date", "voucher_type",
            "description", "status", "total_debit", "total_credit", "created_at", "created_by_id"},
        pgx.CopyFromRows(voucherRows),
    )
    if err != nil {
        return err
    }

    // COPY voucher_lines
    _, err = tx.CopyFrom(
        ctx,
        pgx.Identifier{"voucher_lines"},
        []string{"id", "voucher_id", "account_id", "partner_id", "department_id",
            "debit_amount", "credit_amount", "description", "line_number"},
        pgx.CopyFromRows(allLines),
    )
    if err != nil {
        return err
    }

    return tx.Commit(ctx)
}

// RefreshMaterializedViewsConcurrently refreshes views without blocking reads
func (r *OptimizedVoucherRepository) RefreshMaterializedViewsConcurrently(ctx context.Context) error {
    views := []string{
        "mv_trial_balance",
        "mv_account_balances",
        "mv_partner_summaries",
    }

    for _, view := range views {
        _, err := r.pool.Exec(ctx, "REFRESH MATERIALIZED VIEW CONCURRENTLY "+view)
        if err != nil {
            return err
        }
    }

    return nil
}
```

### 7.2 캐싱 전략

```go
// internal/cache/strategies.go

package cache

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/google/uuid"
    "github.com/redis/go-redis/v9"
)

type CacheStrategy struct {
    redis *redis.Client
}

// Cache configuration per data type
var CacheConfig = map[string]CacheTTL{
    "account":       {TTL: 1 * time.Hour, Invalidation: "on_change"},
    "partner":       {TTL: 30 * time.Minute, Invalidation: "on_change"},
    "trial_balance": {TTL: 5 * time.Minute, Invalidation: "scheduled"},
    "user_session":  {TTL: 24 * time.Hour, Invalidation: "sliding"},
    "rate_limit":    {TTL: 1 * time.Minute, Invalidation: "fixed"},
}

type CacheTTL struct {
    TTL          time.Duration
    Invalidation string
}

// GetOrSet implements read-through caching
func (c *CacheStrategy) GetOrSet(
    ctx context.Context,
    key string,
    ttl time.Duration,
    fetchFn func() (interface{}, error),
) (interface{}, error) {
    // Try to get from cache
    cached, err := c.redis.Get(ctx, key).Result()
    if err == nil {
        var result interface{}
        if err := json.Unmarshal([]byte(cached), &result); err == nil {
            return result, nil
        }
    }

    // Fetch from source
    data, err := fetchFn()
    if err != nil {
        return nil, err
    }

    // Store in cache
    serialized, err := json.Marshal(data)
    if err == nil {
        c.redis.Set(ctx, key, serialized, ttl)
    }

    return data, nil
}

// InvalidatePattern removes all keys matching a pattern
func (c *CacheStrategy) InvalidatePattern(ctx context.Context, pattern string) error {
    iter := c.redis.Scan(ctx, 0, pattern, 0).Iterator()
    for iter.Next(ctx) {
        c.redis.Del(ctx, iter.Val())
    }
    return iter.Err()
}

// CacheKey builders
func AccountCacheKey(companyID uuid.UUID, accountID uuid.UUID) string {
    return fmt.Sprintf("account:%s:%s", companyID, accountID)
}

func TrialBalanceCacheKey(companyID uuid.UUID, year, month int) string {
    return fmt.Sprintf("trial_balance:%s:%d:%d", companyID, year, month)
}

func PartnerListCacheKey(companyID uuid.UUID, page, pageSize int) string {
    return fmt.Sprintf("partners:%s:list:%d:%d", companyID, page, pageSize)
}

// Distributed lock for cache stampede prevention
func (c *CacheStrategy) WithLock(
    ctx context.Context,
    key string,
    ttl time.Duration,
    fn func() error,
) error {
    lockKey := "lock:" + key

    // Try to acquire lock
    acquired, err := c.redis.SetNX(ctx, lockKey, "1", ttl).Result()
    if err != nil {
        return err
    }

    if !acquired {
        // Wait for lock to be released
        time.Sleep(100 * time.Millisecond)
        return c.WithLock(ctx, key, ttl, fn)
    }

    defer c.redis.Del(ctx, lockKey)

    return fn()
}
```

---

## 8. 벤치마크 자동화

### 8.1 CI/CD 파이프라인 통합

```yaml
# .github/workflows/performance.yml

name: Performance Tests

on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM
  workflow_dispatch:
    inputs:
      test_type:
        description: 'Test type to run'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - api
          - database
          - grpc

jobs:
  setup-environment:
    runs-on: ubuntu-latest
    outputs:
      test_env_url: ${{ steps.deploy.outputs.url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy test environment
        id: deploy
        run: |
          # Deploy ephemeral test environment
          ./scripts/deploy-perf-env.sh
          echo "url=$TEST_ENV_URL" >> $GITHUB_OUTPUT

  run-benchmarks:
    needs: setup-environment
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test: [api, database, grpc]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Setup k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Run API Benchmarks
        if: matrix.test == 'api'
        env:
          BASE_URL: ${{ needs.setup-environment.outputs.test_env_url }}
        run: |
          k6 run --out json=results/api_results.json tests/performance/k6/api_load_test.js

      - name: Run Database Benchmarks
        if: matrix.test == 'database'
        run: |
          go test -bench=. -benchtime=30s -benchmem ./internal/benchmark/... \
            -json > results/db_results.json

      - name: Run gRPC Benchmarks
        if: matrix.test == 'grpc'
        run: |
          cd tests/performance
          python grpc_benchmark.py --output results/grpc_results.json

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-${{ matrix.test }}
          path: results/

  analyze-results:
    needs: run-benchmarks
    runs-on: ubuntu-latest
    steps:
      - name: Download all results
        uses: actions/download-artifact@v4
        with:
          path: results/

      - name: Analyze and report
        run: |
          python scripts/analyze_benchmarks.py results/ --threshold-file configs/performance_thresholds.yaml

      - name: Post results to PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('results/summary.md', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });

      - name: Check thresholds
        run: |
          python scripts/check_thresholds.py results/ --fail-on-regression

  cleanup:
    needs: [run-benchmarks, analyze-results]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Destroy test environment
        run: |
          ./scripts/destroy-perf-env.sh
```

### 8.2 결과 분석 스크립트

```python
# scripts/analyze_benchmarks.py

import json
import sys
from pathlib import Path
from typing import Dict, List, Any
from dataclasses import dataclass
import yaml


@dataclass
class BenchmarkResult:
    name: str
    metric: str
    value: float
    unit: str
    threshold: float
    passed: bool


def load_thresholds(threshold_file: str) -> Dict[str, Any]:
    """Load performance thresholds from YAML file."""
    with open(threshold_file) as f:
        return yaml.safe_load(f)


def parse_k6_results(results_file: str) -> List[BenchmarkResult]:
    """Parse k6 JSON output."""
    results = []

    with open(results_file) as f:
        for line in f:
            try:
                data = json.loads(line)
                if data.get('type') == 'Point' and data.get('metric') == 'http_req_duration':
                    # Extract percentile metrics
                    pass
            except json.JSONDecodeError:
                continue

    return results


def parse_go_benchmark_results(results_file: str) -> List[BenchmarkResult]:
    """Parse Go benchmark JSON output."""
    results = []

    with open(results_file) as f:
        for line in f:
            try:
                data = json.loads(line)
                if data.get('Action') == 'output':
                    output = data.get('Output', '')
                    if 'ns/op' in output:
                        # Parse benchmark line
                        parts = output.split()
                        if len(parts) >= 4:
                            name = parts[0]
                            ns_per_op = float(parts[2])
                            results.append(BenchmarkResult(
                                name=name,
                                metric='latency',
                                value=ns_per_op / 1_000_000,  # Convert to ms
                                unit='ms',
                                threshold=0,  # Will be set from config
                                passed=True
                            ))
            except (json.JSONDecodeError, ValueError, IndexError):
                continue

    return results


def generate_summary(results: List[BenchmarkResult]) -> str:
    """Generate markdown summary of benchmark results."""
    passed = sum(1 for r in results if r.passed)
    failed = len(results) - passed

    summary = f"""# Performance Benchmark Results

## Summary
- Total Tests: {len(results)}
- Passed: {passed}
- Failed: {failed}
- Pass Rate: {passed/len(results)*100:.1f}%

## Detailed Results

| Test Name | Metric | Value | Threshold | Status |
|-----------|--------|-------|-----------|--------|
"""

    for r in results:
        status = "PASS" if r.passed else "FAIL"
        summary += f"| {r.name} | {r.metric} | {r.value:.2f}{r.unit} | {r.threshold:.2f}{r.unit} | {status} |\n"

    return summary


def main():
    if len(sys.argv) < 2:
        print("Usage: python analyze_benchmarks.py <results_dir> [--threshold-file <file>]")
        sys.exit(1)

    results_dir = Path(sys.argv[1])
    threshold_file = "configs/performance_thresholds.yaml"

    if "--threshold-file" in sys.argv:
        idx = sys.argv.index("--threshold-file")
        threshold_file = sys.argv[idx + 1]

    thresholds = load_thresholds(threshold_file)
    all_results: List[BenchmarkResult] = []

    # Parse all result files
    for result_file in results_dir.rglob("*.json"):
        if "api" in result_file.name:
            all_results.extend(parse_k6_results(str(result_file)))
        elif "db" in result_file.name:
            all_results.extend(parse_go_benchmark_results(str(result_file)))

    # Apply thresholds
    for result in all_results:
        if result.name in thresholds:
            result.threshold = thresholds[result.name]
            result.passed = result.value <= result.threshold

    # Generate summary
    summary = generate_summary(all_results)
    print(summary)

    # Save summary
    with open(results_dir / "summary.md", "w") as f:
        f.write(summary)


if __name__ == "__main__":
    main()
```

---

## 9. 성능 기준선

### 9.1 성능 기준선 정의

```yaml
# configs/performance_thresholds.yaml

# API Endpoints
api:
  vouchers:
    create:
      p95: 200  # ms
      p99: 500
    list:
      p95: 100
      p99: 200
    get:
      p95: 50
      p99: 100

  partners:
    list:
      p95: 100
      p99: 200
    search:
      p95: 150
      p99: 300

  reports:
    trial_balance:
      p95: 1000
      p99: 2000
    income_statement:
      p95: 1500
      p99: 3000
    account_ledger:
      p95: 500
      p99: 1000

# Database Queries
database:
  simple_select:
    p95: 10
    p99: 50
  join_query:
    p95: 50
    p99: 100
  aggregation:
    p95: 100
    p99: 500
  bulk_insert_1000:
    p95: 500
    p99: 1000

# gRPC Services
grpc:
  tax_scraper:
    scrape_invoices:
      p95: 5000  # External API dependent
      p99: 10000
  insurance_edi:
    submit_report:
      p95: 3000
      p99: 5000

# System Resources
resources:
  api_memory_mb: 512
  worker_memory_mb: 256
  cpu_utilization_pct: 70
```

---

## 10. 모니터링 및 알림

### 10.1 실시간 성능 대시보드

```yaml
# deployments/monitoring/grafana/performance-dashboard.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-performance-dashboard
data:
  performance.json: |
    {
      "title": "K-ERP Performance Dashboard",
      "panels": [
        {
          "title": "API Response Time (P95)",
          "type": "timeseries",
          "gridPos": {"x": 0, "y": 0, "w": 12, "h": 8},
          "targets": [
            {
              "expr": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{job=\"kerp-api\"}[5m])) by (le, handler))",
              "legendFormat": "{{handler}}"
            }
          ],
          "fieldConfig": {
            "defaults": {
              "unit": "s",
              "thresholds": {
                "steps": [
                  {"value": 0, "color": "green"},
                  {"value": 0.2, "color": "yellow"},
                  {"value": 0.5, "color": "red"}
                ]
              }
            }
          }
        },
        {
          "title": "Request Rate",
          "type": "timeseries",
          "gridPos": {"x": 12, "y": 0, "w": 12, "h": 8},
          "targets": [
            {
              "expr": "sum(rate(http_requests_total{job=\"kerp-api\"}[5m])) by (method)",
              "legendFormat": "{{method}}"
            }
          ]
        },
        {
          "title": "Database Query Latency",
          "type": "timeseries",
          "gridPos": {"x": 0, "y": 8, "w": 12, "h": 8},
          "targets": [
            {
              "expr": "histogram_quantile(0.95, sum(rate(db_query_duration_seconds_bucket{job=\"kerp-api\"}[5m])) by (le, query))",
              "legendFormat": "{{query}}"
            }
          ]
        },
        {
          "title": "gRPC Service Latency",
          "type": "timeseries",
          "gridPos": {"x": 12, "y": 8, "w": 12, "h": 8},
          "targets": [
            {
              "expr": "histogram_quantile(0.95, sum(rate(grpc_server_handling_seconds_bucket{job=~\"kerp-tax-scraper|kerp-insurance-edi\"}[5m])) by (le, grpc_service, grpc_method))",
              "legendFormat": "{{grpc_service}}/{{grpc_method}}"
            }
          ]
        }
      ]
    }
```

---

## 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 1.0 | 2025-01-xx | K-ERP Team | 최초 작성 |
