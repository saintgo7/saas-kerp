# K-ERP v0.2 - 외부연동 구현

**문서 버전**: 0.2.0
**작성일**: 2026-01-16
**상태**: 검토 대기

---

## 목차

1. [외부연동 아키텍처](#1-외부연동-아키텍처)
2. [Go 기반 연동 모듈](#2-go-기반-연동-모듈)
3. [Python 기반 연동 모듈](#3-python-기반-연동-모듈)
4. [Provider 패턴 구현](#4-provider-패턴-구현)
5. [에러 처리 및 재시도](#5-에러-처리-및-재시도)

---

## 1. 외부연동 아키텍처

### 1.1 연동 대상 분류

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        외부연동 아키텍처 개요                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     Go API Server                                    │   │
│  │  ┌──────────────────┬──────────────────┬───────────────────────┐   │   │
│  │  │ REST API 연동    │ Webhook 수신      │ gRPC Client          │   │   │
│  │  │ - Popbill API    │ - PG 결제 알림    │ - Python Services    │   │   │
│  │  │ - NTS OpenAPI    │ - 알림톡/문자     │   - tax-scraper      │   │   │
│  │  │ - 카카오 알림톡  │ - 배송 상태       │   - insurance-edi    │   │   │
│  │  │ - PG 결제        │                   │                       │   │   │
│  │  └──────────────────┴──────────────────┴───────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                      │
│                                      │ gRPC (HTTP/2)                        │
│                                      ▼                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                   Python Services                                    │   │
│  │  ┌──────────────────────────────┬──────────────────────────────┐   │   │
│  │  │ tax-scraper (:50051)         │ insurance-edi (:50052)       │   │   │
│  │  │ - 홈택스 웹 스크래핑         │ - 4대보험 EDI 생성           │   │   │
│  │  │ - SEED-CBC 암호화            │ - SEED/ARIA 암호화           │   │   │
│  │  │ - 공동인증서 처리            │ - 기관 웹 자동화             │   │   │
│  │  └──────────────────────────────┴──────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 연동 방식별 분류

| 연동 대상 | 방식 | 구현 언어 | 암호화 | 비고 |
|-----------|------|-----------|--------|------|
| Popbill API | REST | Go | 없음 | 세금계산서 발행 |
| NTS OpenAPI | REST | Go | 없음 | 사업자 진위확인 |
| 홈택스 | 스크래핑 | Python | SEED-CBC | 세금계산서 수집 |
| 국민연금 | EDI | Python | SEED-CBC | 취득/상실 신고 |
| 건강보험 | EDI | Python | ARIA-CBC | 자격취득 신고 |
| 고용/산재보험 | EDI | Python | SEED-CBC | 보험료 신고 |
| 카카오 알림톡 | REST | Go | 없음 | 알림 발송 |
| PG 결제 | REST + Webhook | Go | AES-256 | 결제 처리 |

### 1.3 비용 우선순위 전략

```
세금계산서 발행/조회:
┌────────────────────────────────────────────────────────────────┐
│  Priority 1: 홈택스 스크래핑 (Python) - 무료                    │
│      │                                                          │
│      │ 실패 시                                                  │
│      ▼                                                          │
│  Priority 2: NTS OpenAPI (Go) - 무료                           │
│      │                                                          │
│      │ 실패 시                                                  │
│      ▼                                                          │
│  Priority 3: Popbill ASP API (Go) - 유료                       │
└────────────────────────────────────────────────────────────────┘
```

---

## 2. Go 기반 연동 모듈

### 2.1 HTTP Client 설정

```go
// pkg/httpclient/client.go
package httpclient

import (
    "context"
    "net/http"
    "time"

    "github.com/hashicorp/go-retryablehttp"
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

type Config struct {
    Timeout        time.Duration
    MaxRetries     int
    RetryWaitMin   time.Duration
    RetryWaitMax   time.Duration
    EnableTracing  bool
}

func DefaultConfig() Config {
    return Config{
        Timeout:       30 * time.Second,
        MaxRetries:    3,
        RetryWaitMin:  1 * time.Second,
        RetryWaitMax:  30 * time.Second,
        EnableTracing: true,
    }
}

func NewClient(cfg Config) *http.Client {
    retryClient := retryablehttp.NewClient()
    retryClient.RetryMax = cfg.MaxRetries
    retryClient.RetryWaitMin = cfg.RetryWaitMin
    retryClient.RetryWaitMax = cfg.RetryWaitMax

    client := retryClient.StandardClient()
    client.Timeout = cfg.Timeout

    if cfg.EnableTracing {
        client.Transport = otelhttp.NewTransport(client.Transport)
    }

    return client
}
```

### 2.2 Popbill API 클라이언트

```go
// internal/infrastructure/popbill/client.go
package popbill

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "time"

    "github.com/kerp/pkg/httpclient"
)

type Client struct {
    httpClient  *http.Client
    baseURL     string
    linkID      string
    secretKey   string
}

type Config struct {
    BaseURL   string
    LinkID    string
    SecretKey string
}

func NewClient(cfg Config) *Client {
    return &Client{
        httpClient: httpclient.NewClient(httpclient.DefaultConfig()),
        baseURL:    cfg.BaseURL,
        linkID:     cfg.LinkID,
        secretKey:  cfg.SecretKey,
    }
}

// 세금계산서 발행
func (c *Client) IssueInvoice(ctx context.Context, req *IssueRequest) (*IssueResponse, error) {
    token, err := c.getAccessToken(ctx, req.CorpNum)
    if err != nil {
        return nil, fmt.Errorf("failed to get access token: %w", err)
    }

    body, err := json.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal request: %w", err)
    }

    httpReq, err := http.NewRequestWithContext(ctx, "POST",
        fmt.Sprintf("%s/Taxinvoice", c.baseURL), bytes.NewReader(body))
    if err != nil {
        return nil, err
    }

    httpReq.Header.Set("Authorization", "Bearer "+token)
    httpReq.Header.Set("Content-Type", "application/json")
    httpReq.Header.Set("x-pb-userid", req.UserID)

    resp, err := c.httpClient.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("failed to send request: %w", err)
    }
    defer resp.Body.Close()

    var result IssueResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, fmt.Errorf("failed to decode response: %w", err)
    }

    if result.Code != 1 {
        return nil, &PopbillError{Code: result.Code, Message: result.Message}
    }

    return &result, nil
}

// 세금계산서 조회
func (c *Client) GetInvoice(ctx context.Context, corpNum, ntsConfirmNum string) (*Invoice, error) {
    token, err := c.getAccessToken(ctx, corpNum)
    if err != nil {
        return nil, err
    }

    url := fmt.Sprintf("%s/Taxinvoice/%s?TI_NTSConfirmNum=%s",
        c.baseURL, corpNum, ntsConfirmNum)

    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }

    req.Header.Set("Authorization", "Bearer "+token)

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var invoice Invoice
    if err := json.NewDecoder(resp.Body).Decode(&invoice); err != nil {
        return nil, err
    }

    return &invoice, nil
}

// 액세스 토큰 발급
func (c *Client) getAccessToken(ctx context.Context, corpNum string) (string, error) {
    // Token caching with Redis
    // Implementation details...
    return "", nil
}
```

### 2.3 NTS OpenAPI 클라이언트

```go
// internal/infrastructure/nts/client.go
package nts

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "net/url"

    "github.com/kerp/pkg/httpclient"
)

type Client struct {
    httpClient *http.Client
    baseURL    string
    serviceKey string
}

func NewClient(serviceKey string) *Client {
    return &Client{
        httpClient: httpclient.NewClient(httpclient.DefaultConfig()),
        baseURL:    "https://api.odcloud.kr/api/nts-businessman/v1",
        serviceKey: serviceKey,
    }
}

// 사업자등록번호 진위확인
func (c *Client) ValidateBusinessNumber(ctx context.Context, bizNo string) (*ValidationResult, error) {
    reqURL := fmt.Sprintf("%s/validate?serviceKey=%s",
        c.baseURL, url.QueryEscape(c.serviceKey))

    reqBody := map[string][]string{
        "b_no": {bizNo},
    }

    body, _ := json.Marshal(reqBody)

    req, err := http.NewRequestWithContext(ctx, "POST", reqURL,
        bytes.NewReader(body))
    if err != nil {
        return nil, err
    }

    req.Header.Set("Content-Type", "application/json")

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var result ValidationResult
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }

    return &result, nil
}

// 사업자 상태 조회
func (c *Client) GetBusinessStatus(ctx context.Context, bizNo string) (*BusinessStatus, error) {
    reqURL := fmt.Sprintf("%s/status?serviceKey=%s",
        c.baseURL, url.QueryEscape(c.serviceKey))

    reqBody := map[string][]string{
        "b_no": {bizNo},
    }

    body, _ := json.Marshal(reqBody)

    req, err := http.NewRequestWithContext(ctx, "POST", reqURL,
        bytes.NewReader(body))
    if err != nil {
        return nil, err
    }

    req.Header.Set("Content-Type", "application/json")

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var result BusinessStatus
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }

    return &result, nil
}
```

### 2.4 카카오 알림톡 클라이언트

```go
// internal/infrastructure/kakao/alimtalk.go
package kakao

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "time"

    "github.com/kerp/pkg/httpclient"
)

type AlimtalkClient struct {
    httpClient   *http.Client
    baseURL      string
    senderKey    string
    templateCode string
}

type SendRequest struct {
    RecipientList []Recipient `json:"recipientList"`
}

type Recipient struct {
    RecipientNo   string            `json:"recipientNo"`
    TemplateCode  string            `json:"templateCode"`
    Variables     map[string]string `json:"variables"`
    ResendContent string            `json:"resendContent,omitempty"`
    Buttons       []Button          `json:"buttons,omitempty"`
}

type Button struct {
    Type    string `json:"type"`
    Name    string `json:"name"`
    LinkMo  string `json:"linkMo,omitempty"`
    LinkPc  string `json:"linkPc,omitempty"`
}

func NewAlimtalkClient(senderKey string) *AlimtalkClient {
    return &AlimtalkClient{
        httpClient: httpclient.NewClient(httpclient.DefaultConfig()),
        baseURL:    "https://api-alimtalk.cloud.toast.com/alimtalk/v2.2/appkeys",
        senderKey:  senderKey,
    }
}

// 알림톡 발송
func (c *AlimtalkClient) Send(ctx context.Context, req *SendRequest) (*SendResponse, error) {
    body, err := json.Marshal(req)
    if err != nil {
        return nil, err
    }

    url := fmt.Sprintf("%s/%s/messages", c.baseURL, c.senderKey)

    httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
    if err != nil {
        return nil, err
    }

    httpReq.Header.Set("Content-Type", "application/json")

    resp, err := c.httpClient.Do(httpReq)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var result SendResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }

    return &result, nil
}

// 세금계산서 발행 알림 템플릿
func (c *AlimtalkClient) SendInvoiceNotification(ctx context.Context,
    phone string, invoiceInfo *InvoiceNotification) error {

    req := &SendRequest{
        RecipientList: []Recipient{
            {
                RecipientNo:  phone,
                TemplateCode: "INVOICE_ISSUED",
                Variables: map[string]string{
                    "#{고객명}":     invoiceInfo.CustomerName,
                    "#{공급가액}":   invoiceInfo.SupplyAmount,
                    "#{세액}":       invoiceInfo.TaxAmount,
                    "#{발행일}":     invoiceInfo.IssueDate,
                    "#{승인번호}":   invoiceInfo.NTSConfirmNum,
                },
                Buttons: []Button{
                    {
                        Type:   "WL",
                        Name:   "세금계산서 확인",
                        LinkMo: invoiceInfo.ViewURL,
                        LinkPc: invoiceInfo.ViewURL,
                    },
                },
            },
        },
    }

    _, err := c.Send(ctx, req)
    return err
}
```

### 2.5 PG 결제 연동

```go
// internal/infrastructure/pg/toss.go
package pg

import (
    "bytes"
    "context"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "net/http"

    "github.com/kerp/pkg/httpclient"
)

type TossPaymentClient struct {
    httpClient *http.Client
    baseURL    string
    secretKey  string
}

func NewTossPaymentClient(secretKey string) *TossPaymentClient {
    return &TossPaymentClient{
        httpClient: httpclient.NewClient(httpclient.DefaultConfig()),
        baseURL:    "https://api.tosspayments.com/v1",
        secretKey:  secretKey,
    }
}

// 결제 승인
func (c *TossPaymentClient) ConfirmPayment(ctx context.Context,
    paymentKey, orderId string, amount int64) (*Payment, error) {

    reqBody := map[string]interface{}{
        "paymentKey": paymentKey,
        "orderId":    orderId,
        "amount":     amount,
    }

    body, _ := json.Marshal(reqBody)

    req, err := http.NewRequestWithContext(ctx, "POST",
        c.baseURL+"/payments/confirm", bytes.NewReader(body))
    if err != nil {
        return nil, err
    }

    auth := base64.StdEncoding.EncodeToString([]byte(c.secretKey + ":"))
    req.Header.Set("Authorization", "Basic "+auth)
    req.Header.Set("Content-Type", "application/json")

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var payment Payment
    if err := json.NewDecoder(resp.Body).Decode(&payment); err != nil {
        return nil, err
    }

    return &payment, nil
}

// 결제 취소
func (c *TossPaymentClient) CancelPayment(ctx context.Context,
    paymentKey, cancelReason string, cancelAmount *int64) (*Payment, error) {

    reqBody := map[string]interface{}{
        "cancelReason": cancelReason,
    }
    if cancelAmount != nil {
        reqBody["cancelAmount"] = *cancelAmount
    }

    body, _ := json.Marshal(reqBody)

    req, err := http.NewRequestWithContext(ctx, "POST",
        fmt.Sprintf("%s/payments/%s/cancel", c.baseURL, paymentKey),
        bytes.NewReader(body))
    if err != nil {
        return nil, err
    }

    auth := base64.StdEncoding.EncodeToString([]byte(c.secretKey + ":"))
    req.Header.Set("Authorization", "Basic "+auth)
    req.Header.Set("Content-Type", "application/json")

    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var payment Payment
    if err := json.NewDecoder(resp.Body).Decode(&payment); err != nil {
        return nil, err
    }

    return &payment, nil
}

// Webhook 검증
func (c *TossPaymentClient) VerifyWebhook(signature string, body []byte) bool {
    // HMAC-SHA256 검증
    // Implementation...
    return true
}
```

---

## 3. Python 기반 연동 모듈

### 3.1 gRPC 클라이언트 (Go에서 Python 서비스 호출)

```go
// internal/infrastructure/grpc/scraper_client.go
package grpc

import (
    "context"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    "google.golang.org/grpc/keepalive"

    pb "github.com/kerp/api/proto/scraper"
)

type ScraperClient struct {
    conn   *grpc.ClientConn
    client pb.ScraperServiceClient
}

func NewScraperClient(addr string) (*ScraperClient, error) {
    conn, err := grpc.Dial(addr,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithKeepaliveParams(keepalive.ClientParameters{
            Time:                10 * time.Second,
            Timeout:             3 * time.Second,
            PermitWithoutStream: true,
        }),
    )
    if err != nil {
        return nil, err
    }

    return &ScraperClient{
        conn:   conn,
        client: pb.NewScraperServiceClient(conn),
    }, nil
}

func (c *ScraperClient) Close() error {
    return c.conn.Close()
}

// 세금계산서 수집
func (c *ScraperClient) ScrapeInvoices(ctx context.Context,
    certPath, certPassword string, startDate, endDate string,
    invoiceType pb.InvoiceType) ([]*pb.Invoice, error) {

    req := &pb.ScrapeRequest{
        CertPath:     certPath,
        CertPassword: certPassword,
        StartDate:    startDate,
        EndDate:      endDate,
        InvoiceType:  invoiceType,
    }

    resp, err := c.client.ScrapeInvoices(ctx, req)
    if err != nil {
        return nil, err
    }

    return resp.Invoices, nil
}

// 세금계산서 상세 조회
func (c *ScraperClient) GetInvoiceDetail(ctx context.Context,
    certPath, certPassword, ntsConfirmNum string) (*pb.InvoiceDetail, error) {

    req := &pb.DetailRequest{
        CertPath:      certPath,
        CertPassword:  certPassword,
        NtsConfirmNum: ntsConfirmNum,
    }

    return c.client.GetInvoiceDetail(ctx, req)
}
```

```go
// internal/infrastructure/grpc/insurance_client.go
package grpc

import (
    "context"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"

    pb "github.com/kerp/api/proto/insurance"
)

type InsuranceClient struct {
    conn   *grpc.ClientConn
    client pb.InsuranceEDIServiceClient
}

func NewInsuranceClient(addr string) (*InsuranceClient, error) {
    conn, err := grpc.Dial(addr,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
    )
    if err != nil {
        return nil, err
    }

    return &InsuranceClient{
        conn:   conn,
        client: pb.NewInsuranceEDIServiceClient(conn),
    }, nil
}

func (c *InsuranceClient) Close() error {
    return c.conn.Close()
}

// 4대보험 신고
func (c *InsuranceClient) SubmitReport(ctx context.Context,
    agencyType pb.AgencyType, reportType pb.ReportType,
    data *pb.ReportData) (*pb.SubmitResponse, error) {

    req := &pb.SubmitRequest{
        AgencyType: agencyType,
        ReportType: reportType,
        Data:       data,
    }

    return c.client.SubmitReport(ctx, req)
}

// 신고 결과 조회
func (c *InsuranceClient) GetReportStatus(ctx context.Context,
    receiptNumber string) (*pb.StatusResponse, error) {

    req := &pb.StatusRequest{
        ReceiptNumber: receiptNumber,
    }

    return c.client.GetReportStatus(ctx, req)
}
```

### 3.2 Python 서비스 호출 래퍼

```go
// internal/service/external/python_service.go
package external

import (
    "context"
    "fmt"

    "github.com/kerp/internal/infrastructure/grpc"
    pb "github.com/kerp/api/proto/scraper"
    pbins "github.com/kerp/api/proto/insurance"
)

type PythonServiceManager struct {
    scraperClient   *grpc.ScraperClient
    insuranceClient *grpc.InsuranceClient
}

func NewPythonServiceManager(scraperAddr, insuranceAddr string) (*PythonServiceManager, error) {
    scraperClient, err := grpc.NewScraperClient(scraperAddr)
    if err != nil {
        return nil, fmt.Errorf("failed to create scraper client: %w", err)
    }

    insuranceClient, err := grpc.NewInsuranceClient(insuranceAddr)
    if err != nil {
        scraperClient.Close()
        return nil, fmt.Errorf("failed to create insurance client: %w", err)
    }

    return &PythonServiceManager{
        scraperClient:   scraperClient,
        insuranceClient: insuranceClient,
    }, nil
}

func (m *PythonServiceManager) Close() error {
    var errs []error
    if err := m.scraperClient.Close(); err != nil {
        errs = append(errs, err)
    }
    if err := m.insuranceClient.Close(); err != nil {
        errs = append(errs, err)
    }
    if len(errs) > 0 {
        return fmt.Errorf("errors closing clients: %v", errs)
    }
    return nil
}

// 세금계산서 스크래핑 (Python tax-scraper 호출)
func (m *PythonServiceManager) ScrapeInvoices(ctx context.Context,
    certPath, certPassword, startDate, endDate string,
    isSales bool) ([]*pb.Invoice, error) {

    invoiceType := pb.InvoiceType_PURCHASE
    if isSales {
        invoiceType = pb.InvoiceType_SALES
    }

    return m.scraperClient.ScrapeInvoices(ctx, certPath, certPassword,
        startDate, endDate, invoiceType)
}

// 4대보험 취득신고 (Python insurance-edi 호출)
func (m *PythonServiceManager) SubmitAcquisitionReport(ctx context.Context,
    agency string, employeeData *pbins.EmployeeData) (*pbins.SubmitResponse, error) {

    agencyMap := map[string]pbins.AgencyType{
        "nps":  pbins.AgencyType_NPS,
        "nhis": pbins.AgencyType_NHIS,
        "ei":   pbins.AgencyType_EI,
        "wci":  pbins.AgencyType_WCI,
    }

    agencyType, ok := agencyMap[agency]
    if !ok {
        return nil, fmt.Errorf("unknown agency: %s", agency)
    }

    return m.insuranceClient.SubmitReport(ctx, agencyType,
        pbins.ReportType_ACQUISITION, &pbins.ReportData{
            Employee: employeeData,
        })
}
```

---

## 4. Provider 패턴 구현

### 4.1 세금계산서 Provider Chain

```go
// internal/service/invoice/provider_chain.go
package invoice

import (
    "context"
    "fmt"

    "github.com/kerp/internal/domain"
    "github.com/rs/zerolog/log"
)

type Provider interface {
    Name() string
    Priority() int
    IsFree() bool
    GetInvoices(ctx context.Context, req *GetInvoicesRequest) ([]*domain.Invoice, error)
    IssueInvoice(ctx context.Context, invoice *domain.Invoice) (*IssueResult, error)
    IsAvailable(ctx context.Context) bool
}

type ProviderChain struct {
    providers []Provider
}

func NewProviderChain(providers ...Provider) *ProviderChain {
    // Sort by priority (lower = higher priority)
    sort.Slice(providers, func(i, j int) bool {
        return providers[i].Priority() < providers[j].Priority()
    })

    return &ProviderChain{providers: providers}
}

// 세금계산서 조회 (Fallback 지원)
func (c *ProviderChain) GetInvoices(ctx context.Context,
    req *GetInvoicesRequest) ([]*domain.Invoice, error) {

    var lastErr error

    for _, provider := range c.providers {
        if !provider.IsAvailable(ctx) {
            log.Info().
                Str("provider", provider.Name()).
                Msg("Provider not available, skipping")
            continue
        }

        log.Info().
            Str("provider", provider.Name()).
            Bool("is_free", provider.IsFree()).
            Msg("Attempting to get invoices")

        invoices, err := provider.GetInvoices(ctx, req)
        if err != nil {
            lastErr = err
            log.Warn().
                Err(err).
                Str("provider", provider.Name()).
                Msg("Provider failed, trying next")
            continue
        }

        log.Info().
            Str("provider", provider.Name()).
            Int("count", len(invoices)).
            Msg("Successfully retrieved invoices")

        return invoices, nil
    }

    return nil, fmt.Errorf("all providers failed, last error: %w", lastErr)
}

// 세금계산서 발행 (Fallback 지원)
func (c *ProviderChain) IssueInvoice(ctx context.Context,
    invoice *domain.Invoice) (*IssueResult, error) {

    var lastErr error

    for _, provider := range c.providers {
        if !provider.IsAvailable(ctx) {
            continue
        }

        result, err := provider.IssueInvoice(ctx, invoice)
        if err != nil {
            lastErr = err
            log.Warn().
                Err(err).
                Str("provider", provider.Name()).
                Msg("Issue failed, trying next provider")
            continue
        }

        return result, nil
    }

    return nil, fmt.Errorf("all providers failed to issue invoice: %w", lastErr)
}
```

### 4.2 개별 Provider 구현

```go
// internal/service/invoice/provider_scraper.go
package invoice

import (
    "context"

    "github.com/kerp/internal/domain"
    "github.com/kerp/internal/infrastructure/grpc"
)

type ScraperProvider struct {
    client *grpc.ScraperClient
}

func NewScraperProvider(client *grpc.ScraperClient) *ScraperProvider {
    return &ScraperProvider{client: client}
}

func (p *ScraperProvider) Name() string     { return "scraper" }
func (p *ScraperProvider) Priority() int    { return 1 }  // Highest priority
func (p *ScraperProvider) IsFree() bool     { return true }

func (p *ScraperProvider) IsAvailable(ctx context.Context) bool {
    // Health check
    return true
}

func (p *ScraperProvider) GetInvoices(ctx context.Context,
    req *GetInvoicesRequest) ([]*domain.Invoice, error) {

    // Python tax-scraper 호출
    pbInvoices, err := p.client.ScrapeInvoices(ctx,
        req.CertPath, req.CertPassword,
        req.StartDate.Format("20060102"),
        req.EndDate.Format("20060102"),
        req.InvoiceType)
    if err != nil {
        return nil, err
    }

    // Convert to domain model
    invoices := make([]*domain.Invoice, len(pbInvoices))
    for i, pb := range pbInvoices {
        invoices[i] = convertPBToDomain(pb)
    }

    return invoices, nil
}

func (p *ScraperProvider) IssueInvoice(ctx context.Context,
    invoice *domain.Invoice) (*IssueResult, error) {
    // Scraper doesn't support issuing
    return nil, ErrNotSupported
}
```

```go
// internal/service/invoice/provider_popbill.go
package invoice

import (
    "context"

    "github.com/kerp/internal/domain"
    "github.com/kerp/internal/infrastructure/popbill"
)

type PopbillProvider struct {
    client *popbill.Client
}

func NewPopbillProvider(client *popbill.Client) *PopbillProvider {
    return &PopbillProvider{client: client}
}

func (p *PopbillProvider) Name() string     { return "popbill" }
func (p *PopbillProvider) Priority() int    { return 3 }  // Lowest priority (paid)
func (p *PopbillProvider) IsFree() bool     { return false }

func (p *PopbillProvider) IsAvailable(ctx context.Context) bool {
    return true
}

func (p *PopbillProvider) GetInvoices(ctx context.Context,
    req *GetInvoicesRequest) ([]*domain.Invoice, error) {

    // Popbill API 호출
    // Implementation...
    return nil, nil
}

func (p *PopbillProvider) IssueInvoice(ctx context.Context,
    invoice *domain.Invoice) (*IssueResult, error) {

    pbReq := convertDomainToPopbill(invoice)

    resp, err := p.client.IssueInvoice(ctx, pbReq)
    if err != nil {
        return nil, err
    }

    return &IssueResult{
        NTSConfirmNum: resp.NTSConfirmNum,
        IssueDate:     resp.IssueDate,
        Provider:      p.Name(),
    }, nil
}
```

---

## 5. 에러 처리 및 재시도

### 5.1 재시도 정책

```go
// pkg/retry/policy.go
package retry

import (
    "context"
    "math"
    "time"
)

type Policy struct {
    MaxRetries     int
    InitialBackoff time.Duration
    MaxBackoff     time.Duration
    Multiplier     float64
    Jitter         float64
}

func DefaultPolicy() Policy {
    return Policy{
        MaxRetries:     3,
        InitialBackoff: 100 * time.Millisecond,
        MaxBackoff:     10 * time.Second,
        Multiplier:     2.0,
        Jitter:         0.1,
    }
}

func (p Policy) Do(ctx context.Context, fn func() error) error {
    var lastErr error

    for attempt := 0; attempt <= p.MaxRetries; attempt++ {
        if attempt > 0 {
            backoff := p.calculateBackoff(attempt)
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-time.After(backoff):
            }
        }

        err := fn()
        if err == nil {
            return nil
        }

        if !isRetryable(err) {
            return err
        }

        lastErr = err
    }

    return lastErr
}

func (p Policy) calculateBackoff(attempt int) time.Duration {
    backoff := float64(p.InitialBackoff) * math.Pow(p.Multiplier, float64(attempt-1))

    if backoff > float64(p.MaxBackoff) {
        backoff = float64(p.MaxBackoff)
    }

    // Add jitter
    jitter := backoff * p.Jitter * (rand.Float64()*2 - 1)
    backoff += jitter

    return time.Duration(backoff)
}

func isRetryable(err error) bool {
    // Network errors, timeouts, 5xx errors are retryable
    // 4xx errors (except 429) are not retryable
    return true
}
```

### 5.2 Circuit Breaker

```go
// pkg/circuitbreaker/breaker.go
package circuitbreaker

import (
    "context"
    "sync"
    "time"
)

type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)

type CircuitBreaker struct {
    mu           sync.Mutex
    state        State
    failures     int
    successes    int
    lastFailure  time.Time

    maxFailures  int
    resetTimeout time.Duration
    halfOpenMax  int
}

func New(maxFailures int, resetTimeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:        StateClosed,
        maxFailures:  maxFailures,
        resetTimeout: resetTimeout,
        halfOpenMax:  3,
    }
}

func (cb *CircuitBreaker) Execute(ctx context.Context, fn func() error) error {
    cb.mu.Lock()

    switch cb.state {
    case StateOpen:
        if time.Since(cb.lastFailure) > cb.resetTimeout {
            cb.state = StateHalfOpen
            cb.successes = 0
        } else {
            cb.mu.Unlock()
            return ErrCircuitOpen
        }
    }

    cb.mu.Unlock()

    err := fn()

    cb.mu.Lock()
    defer cb.mu.Unlock()

    if err != nil {
        cb.failures++
        cb.lastFailure = time.Now()

        if cb.state == StateHalfOpen || cb.failures >= cb.maxFailures {
            cb.state = StateOpen
        }
        return err
    }

    if cb.state == StateHalfOpen {
        cb.successes++
        if cb.successes >= cb.halfOpenMax {
            cb.state = StateClosed
            cb.failures = 0
        }
    } else {
        cb.failures = 0
    }

    return nil
}
```

### 5.3 에러 타입 정의

```go
// pkg/errors/external.go
package errors

import (
    "fmt"
)

type ExternalError struct {
    Provider    string
    Operation   string
    StatusCode  int
    Message     string
    Retryable   bool
    Cause       error
}

func (e *ExternalError) Error() string {
    return fmt.Sprintf("[%s] %s failed: %s (code: %d, retryable: %t)",
        e.Provider, e.Operation, e.Message, e.StatusCode, e.Retryable)
}

func (e *ExternalError) Unwrap() error {
    return e.Cause
}

func NewExternalError(provider, operation string, statusCode int,
    message string, retryable bool, cause error) *ExternalError {
    return &ExternalError{
        Provider:   provider,
        Operation:  operation,
        StatusCode: statusCode,
        Message:    message,
        Retryable:  retryable,
        Cause:      cause,
    }
}

// Common external errors
var (
    ErrProviderUnavailable = NewExternalError("", "", 503, "provider unavailable", true, nil)
    ErrRateLimited         = NewExternalError("", "", 429, "rate limited", true, nil)
    ErrAuthFailed          = NewExternalError("", "", 401, "authentication failed", false, nil)
    ErrNotSupported        = NewExternalError("", "", 400, "operation not supported", false, nil)
)
```

---

**다음 문서**: [10_실시간처리_설계.md](./10_실시간처리_설계.md)
