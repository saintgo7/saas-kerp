# K-ERP v0.2 - 에러 핸들링 가이드

**문서 버전**: 0.2.0
**작성일**: 2026-01-16
**상태**: 검토 대기

---

## 목차

1. [에러 핸들링 원칙](#1-에러-핸들링-원칙)
2. [에러 타입 정의](#2-에러-타입-정의)
3. [Go 에러 처리](#3-go-에러-처리)
4. [Python 에러 처리](#4-python-에러-처리)
5. [API 에러 응답](#5-api-에러-응답)

---

## 1. 에러 핸들링 원칙

### 1.1 핵심 원칙

| 원칙 | 설명 |
|------|------|
| 명시적 에러 처리 | 모든 에러는 명시적으로 처리 |
| 에러 래핑 | 컨텍스트 추가하여 에러 래핑 |
| 적절한 추상화 | 계층별 적절한 에러 추상화 |
| 일관된 응답 | 클라이언트에 일관된 에러 형식 |
| 로깅 분리 | 내부 로그와 사용자 메시지 분리 |

### 1.2 에러 계층 구조

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Error Hierarchy                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  External (Client-facing)                                                   │
│  └── APIError                                                               │
│      ├── code: string (error code)                                          │
│      ├── message: string (user-friendly message)                            │
│      ├── status: int (HTTP status)                                          │
│      └── details: object (optional field-level errors)                      │
│                                                                             │
│  Internal (Service-level)                                                   │
│  └── AppError                                                               │
│      ├── code: string                                                       │
│      ├── message: string                                                    │
│      ├── cause: error (wrapped error)                                       │
│      └── context: map[string]interface{} (debugging info)                   │
│                                                                             │
│  Infrastructure (Low-level)                                                 │
│  └── Standard errors                                                        │
│      ├── database errors                                                    │
│      ├── network errors                                                     │
│      ├── file system errors                                                 │
│      └── gRPC errors                                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 에러 타입 정의

### 2.1 에러 코드 체계

```
Format: {DOMAIN}_{CATEGORY}_{SPECIFIC}

Domains:
- AUTH: 인증/인가
- VOUCHER: 전표
- INVOICE: 세금계산서
- PAYROLL: 급여
- INSURANCE: 4대보험
- EXTERNAL: 외부 연동
- SYSTEM: 시스템

Categories:
- VALIDATION: 입력값 검증
- NOT_FOUND: 리소스 없음
- CONFLICT: 충돌
- FORBIDDEN: 권한 없음
- FAILED: 처리 실패
```

### 2.2 에러 코드 목록

```go
// pkg/errors/codes.go
package errors

const (
    // Authentication
    AuthInvalidCredentials = "AUTH_INVALID_CREDENTIALS"
    AuthTokenExpired       = "AUTH_TOKEN_EXPIRED"
    AuthTokenInvalid       = "AUTH_TOKEN_INVALID"
    AuthMFARequired        = "AUTH_MFA_REQUIRED"
    AuthForbidden          = "AUTH_FORBIDDEN"

    // Validation
    ValidationRequired     = "VALIDATION_REQUIRED"
    ValidationFormat       = "VALIDATION_FORMAT"
    ValidationRange        = "VALIDATION_RANGE"

    // Voucher
    VoucherNotFound        = "VOUCHER_NOT_FOUND"
    VoucherUnbalanced      = "VOUCHER_UNBALANCED"
    VoucherAlreadyPosted   = "VOUCHER_ALREADY_POSTED"
    VoucherInvalidStatus   = "VOUCHER_INVALID_STATUS"

    // Invoice
    InvoiceNotFound        = "INVOICE_NOT_FOUND"
    InvoiceAlreadyIssued   = "INVOICE_ALREADY_ISSUED"
    InvoiceInvalidTax      = "INVOICE_INVALID_TAX"
    InvoiceIssueFailed     = "INVOICE_ISSUE_FAILED"
    InvoiceScrapeFailed    = "INVOICE_SCRAPE_FAILED"

    // Payroll
    PayrollNotFound        = "PAYROLL_NOT_FOUND"
    PayrollAlreadyConfirmed = "PAYROLL_ALREADY_CONFIRMED"
    PayrollCalculationFailed = "PAYROLL_CALCULATION_FAILED"

    // Insurance
    InsuranceReportFailed  = "INSURANCE_REPORT_FAILED"
    InsuranceInvalidFormat = "INSURANCE_INVALID_FORMAT"

    // External
    ExternalTimeout        = "EXTERNAL_TIMEOUT"
    ExternalUnavailable    = "EXTERNAL_UNAVAILABLE"
    ExternalRateLimited    = "EXTERNAL_RATE_LIMITED"

    // System
    SystemInternal         = "SYSTEM_INTERNAL"
    SystemDatabase         = "SYSTEM_DATABASE"
    SystemMaintenance      = "SYSTEM_MAINTENANCE"
)

// HTTP Status mapping
var StatusCodes = map[string]int{
    AuthInvalidCredentials:  401,
    AuthTokenExpired:        401,
    AuthTokenInvalid:        401,
    AuthMFARequired:         403,
    AuthForbidden:           403,

    ValidationRequired:      400,
    ValidationFormat:        400,
    ValidationRange:         400,

    VoucherNotFound:         404,
    VoucherUnbalanced:       400,
    VoucherAlreadyPosted:    409,
    VoucherInvalidStatus:    400,

    InvoiceNotFound:         404,
    InvoiceAlreadyIssued:    409,
    InvoiceInvalidTax:       400,
    InvoiceIssueFailed:      500,
    InvoiceScrapeFailed:     500,

    ExternalTimeout:         504,
    ExternalUnavailable:     503,
    ExternalRateLimited:     429,

    SystemInternal:          500,
    SystemDatabase:          500,
    SystemMaintenance:       503,
}
```

---

## 3. Go 에러 처리

### 3.1 커스텀 에러 타입

```go
// pkg/errors/app_error.go
package errors

import (
    "fmt"
)

type AppError struct {
    Code    string                 `json:"code"`
    Message string                 `json:"message"`
    Cause   error                  `json:"-"`
    Context map[string]interface{} `json:"-"`
}

func (e *AppError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("%s: %s (%v)", e.Code, e.Message, e.Cause)
    }
    return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

func (e *AppError) Unwrap() error {
    return e.Cause
}

func (e *AppError) WithContext(key string, value interface{}) *AppError {
    if e.Context == nil {
        e.Context = make(map[string]interface{})
    }
    e.Context[key] = value
    return e
}

// Constructor functions
func New(code, message string) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
    }
}

func Wrap(err error, code, message string) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
        Cause:   err,
    }
}

func Wrapf(err error, code, format string, args ...interface{}) *AppError {
    return &AppError{
        Code:    code,
        Message: fmt.Sprintf(format, args...),
        Cause:   err,
    }
}

// Predefined errors
func NotFound(resource string, id interface{}) *AppError {
    return &AppError{
        Code:    fmt.Sprintf("%s_NOT_FOUND", toUpperSnake(resource)),
        Message: fmt.Sprintf("%s을(를) 찾을 수 없습니다.", resource),
        Context: map[string]interface{}{"id": id},
    }
}

func ValidationFailed(field, reason string) *AppError {
    return &AppError{
        Code:    ValidationFormat,
        Message: fmt.Sprintf("%s: %s", field, reason),
        Context: map[string]interface{}{"field": field},
    }
}

func Forbidden(action string) *AppError {
    return &AppError{
        Code:    AuthForbidden,
        Message: fmt.Sprintf("%s 권한이 없습니다.", action),
    }
}
```

### 3.2 에러 처리 패턴

```go
// internal/service/voucher/service.go
package voucher

import (
    "context"
    "fmt"

    "github.com/kerp/internal/domain"
    "github.com/kerp/pkg/errors"
)

func (s *Service) CreateVoucher(ctx context.Context, input *CreateInput) (*domain.Voucher, error) {
    // 1. 입력값 검증
    if err := s.validateInput(input); err != nil {
        return nil, err  // Already an AppError
    }

    // 2. 차대변 검증
    if !s.isBalanced(input.Entries) {
        return nil, errors.New(errors.VoucherUnbalanced, "차변과 대변의 합계가 일치하지 않습니다.").
            WithContext("debit_total", s.sumDebit(input.Entries)).
            WithContext("credit_total", s.sumCredit(input.Entries))
    }

    // 3. 계정과목 존재 확인
    for _, entry := range input.Entries {
        account, err := s.accountRepo.FindByID(ctx, entry.AccountID)
        if err != nil {
            return nil, errors.Wrap(err, errors.SystemDatabase, "계정과목 조회 실패")
        }
        if account == nil {
            return nil, errors.NotFound("계정과목", entry.AccountID)
        }
    }

    // 4. 전표 생성
    voucher := s.toVoucher(input)
    if err := s.voucherRepo.Create(ctx, voucher); err != nil {
        return nil, errors.Wrap(err, errors.SystemDatabase, "전표 저장 실패")
    }

    return voucher, nil
}

func (s *Service) validateInput(input *CreateInput) error {
    if input.VoucherDate.IsZero() {
        return errors.ValidationFailed("voucher_date", "전표일자는 필수입니다.")
    }

    if len(input.Entries) == 0 {
        return errors.ValidationFailed("entries", "최소 하나의 전표 항목이 필요합니다.")
    }

    if len(input.Entries) < 2 {
        return errors.ValidationFailed("entries", "차변과 대변 각각 최소 하나의 항목이 필요합니다.")
    }

    return nil
}
```

### 3.3 미들웨어에서 에러 처리

```go
// internal/middleware/error_handler.go
package middleware

import (
    "errors"
    "net/http"

    "github.com/gin-gonic/gin"
    "github.com/rs/zerolog/log"

    apperrors "github.com/kerp/pkg/errors"
)

type ErrorResponse struct {
    Success bool                   `json:"success"`
    Error   ErrorDetail            `json:"error"`
    Meta    map[string]interface{} `json:"meta,omitempty"`
}

type ErrorDetail struct {
    Code        string                 `json:"code"`
    Message     string                 `json:"message"`
    Details     map[string]interface{} `json:"details,omitempty"`
    FieldErrors []FieldError           `json:"field_errors,omitempty"`
}

type FieldError struct {
    Field   string `json:"field"`
    Message string `json:"message"`
}

func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()

        // Check if there are any errors
        if len(c.Errors) == 0 {
            return
        }

        err := c.Errors.Last().Err
        requestID := c.GetString("request_id")

        var appErr *apperrors.AppError
        var status int
        var response ErrorResponse

        if errors.As(err, &appErr) {
            // Application error
            status = apperrors.GetStatusCode(appErr.Code)
            response = ErrorResponse{
                Success: false,
                Error: ErrorDetail{
                    Code:    appErr.Code,
                    Message: appErr.Message,
                    Details: appErr.Context,
                },
            }

            // Log with context
            log.Warn().
                Str("request_id", requestID).
                Str("error_code", appErr.Code).
                Err(appErr.Cause).
                Fields(appErr.Context).
                Msg(appErr.Message)
        } else {
            // Unknown error - log full details, return generic message
            status = http.StatusInternalServerError
            response = ErrorResponse{
                Success: false,
                Error: ErrorDetail{
                    Code:    apperrors.SystemInternal,
                    Message: "서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.",
                },
            }

            // Log full error for debugging
            log.Error().
                Str("request_id", requestID).
                Err(err).
                Msg("Unhandled error")
        }

        c.JSON(status, response)
    }
}
```

---

## 4. Python 에러 처리

### 4.1 커스텀 예외 클래스

```python
# python-services/shared/errors/exceptions.py
from typing import Optional, Dict, Any
from enum import Enum

class ErrorCode(str, Enum):
    # Scraping errors
    SCRAPE_AUTH_FAILED = "SCRAPE_AUTH_FAILED"
    SCRAPE_CERT_INVALID = "SCRAPE_CERT_INVALID"
    SCRAPE_SESSION_EXPIRED = "SCRAPE_SESSION_EXPIRED"
    SCRAPE_PARSE_FAILED = "SCRAPE_PARSE_FAILED"
    SCRAPE_TIMEOUT = "SCRAPE_TIMEOUT"

    # Encryption errors
    CRYPTO_INVALID_KEY = "CRYPTO_INVALID_KEY"
    CRYPTO_DECRYPT_FAILED = "CRYPTO_DECRYPT_FAILED"

    # EDI errors
    EDI_FORMAT_INVALID = "EDI_FORMAT_INVALID"
    EDI_SUBMIT_FAILED = "EDI_SUBMIT_FAILED"
    EDI_RESPONSE_INVALID = "EDI_RESPONSE_INVALID"

    # System errors
    SYSTEM_INTERNAL = "SYSTEM_INTERNAL"
    SYSTEM_TIMEOUT = "SYSTEM_TIMEOUT"


class AppException(Exception):
    """Base application exception."""

    def __init__(
        self,
        code: ErrorCode,
        message: str,
        cause: Optional[Exception] = None,
        context: Optional[Dict[str, Any]] = None
    ):
        self.code = code
        self.message = message
        self.cause = cause
        self.context = context or {}
        super().__init__(message)

    def __str__(self):
        base = f"[{self.code}] {self.message}"
        if self.cause:
            base += f" (caused by: {self.cause})"
        return base

    def to_dict(self) -> Dict[str, Any]:
        return {
            "code": self.code.value,
            "message": self.message,
            "context": self.context,
        }


class ScrapingException(AppException):
    """Exception for scraping errors."""
    pass


class CryptoException(AppException):
    """Exception for encryption/decryption errors."""
    pass


class EDIException(AppException):
    """Exception for EDI processing errors."""
    pass


# Convenience functions
def scrape_auth_failed(message: str = "인증에 실패했습니다.") -> ScrapingException:
    return ScrapingException(ErrorCode.SCRAPE_AUTH_FAILED, message)


def scrape_cert_invalid(message: str = "인증서가 유효하지 않습니다.") -> ScrapingException:
    return ScrapingException(ErrorCode.SCRAPE_CERT_INVALID, message)


def scrape_timeout(target: str) -> ScrapingException:
    return ScrapingException(
        ErrorCode.SCRAPE_TIMEOUT,
        f"{target} 접속 시간이 초과되었습니다.",
        context={"target": target}
    )


def edi_submit_failed(agency: str, reason: str) -> EDIException:
    return EDIException(
        ErrorCode.EDI_SUBMIT_FAILED,
        f"{agency} 신고 전송에 실패했습니다: {reason}",
        context={"agency": agency, "reason": reason}
    )
```

### 4.2 gRPC 에러 매핑

```python
# python-services/shared/errors/grpc_errors.py
import grpc
from typing import Optional
from .exceptions import AppException, ErrorCode

# Error code to gRPC status mapping
GRPC_STATUS_MAP = {
    ErrorCode.SCRAPE_AUTH_FAILED: grpc.StatusCode.UNAUTHENTICATED,
    ErrorCode.SCRAPE_CERT_INVALID: grpc.StatusCode.INVALID_ARGUMENT,
    ErrorCode.SCRAPE_SESSION_EXPIRED: grpc.StatusCode.UNAUTHENTICATED,
    ErrorCode.SCRAPE_PARSE_FAILED: grpc.StatusCode.INTERNAL,
    ErrorCode.SCRAPE_TIMEOUT: grpc.StatusCode.DEADLINE_EXCEEDED,
    ErrorCode.CRYPTO_INVALID_KEY: grpc.StatusCode.INVALID_ARGUMENT,
    ErrorCode.CRYPTO_DECRYPT_FAILED: grpc.StatusCode.INTERNAL,
    ErrorCode.EDI_FORMAT_INVALID: grpc.StatusCode.INVALID_ARGUMENT,
    ErrorCode.EDI_SUBMIT_FAILED: grpc.StatusCode.INTERNAL,
    ErrorCode.SYSTEM_INTERNAL: grpc.StatusCode.INTERNAL,
    ErrorCode.SYSTEM_TIMEOUT: grpc.StatusCode.DEADLINE_EXCEEDED,
}


def to_grpc_error(exc: AppException) -> grpc.RpcError:
    """Convert AppException to gRPC error."""
    status = GRPC_STATUS_MAP.get(exc.code, grpc.StatusCode.INTERNAL)

    # Include error details in metadata
    metadata = [
        ("error-code", exc.code.value),
        ("error-message", exc.message),
    ]

    for key, value in exc.context.items():
        metadata.append((f"error-context-{key}", str(value)))

    context = grpc.ServicerContext()
    context.abort(status, exc.message)


class GrpcErrorInterceptor(grpc.ServerInterceptor):
    """Interceptor to handle exceptions and convert to gRPC errors."""

    def intercept_service(self, continuation, handler_call_details):
        def wrapper(request, context):
            try:
                return continuation(handler_call_details)(request, context)
            except AppException as e:
                self._log_error(e, handler_call_details)
                context.abort(
                    GRPC_STATUS_MAP.get(e.code, grpc.StatusCode.INTERNAL),
                    e.message
                )
            except Exception as e:
                self._log_error(e, handler_call_details)
                context.abort(grpc.StatusCode.INTERNAL, "Internal server error")

        return grpc.unary_unary_rpc_method_handler(wrapper)

    def _log_error(self, error: Exception, handler_call_details):
        import structlog
        logger = structlog.get_logger()
        logger.error(
            "grpc_error",
            method=handler_call_details.method,
            error=str(error),
            error_type=type(error).__name__,
        )
```

### 4.3 에러 처리 패턴

```python
# python-services/tax-scraper/src/scraper/hometax.py
import structlog
from playwright.async_api import TimeoutError as PlaywrightTimeout
from shared.errors.exceptions import (
    ScrapingException, ErrorCode,
    scrape_auth_failed, scrape_timeout, scrape_cert_invalid
)

logger = structlog.get_logger()


class HometaxScraper:
    async def login(self, cert_path: str, cert_password: str) -> None:
        """홈택스 로그인"""
        try:
            await self.page.goto(self.LOGIN_URL, timeout=30000)

            # 인증서 선택
            await self._select_certificate(cert_path)

            # 비밀번호 입력
            await self._enter_password(cert_password)

            # 로그인 버튼 클릭
            await self.page.click("#loginBtn")

            # 로그인 성공 확인
            await self.page.wait_for_selector("#logoutBtn", timeout=10000)

        except PlaywrightTimeout as e:
            logger.error("login_timeout", cert_path=cert_path)
            raise scrape_timeout("홈택스") from e

        except Exception as e:
            # Check for specific error messages
            error_msg = await self._get_error_message()
            if "인증서" in error_msg:
                raise scrape_cert_invalid(error_msg) from e
            elif "비밀번호" in error_msg:
                raise scrape_auth_failed("인증서 비밀번호가 올바르지 않습니다.") from e
            else:
                raise ScrapingException(
                    ErrorCode.SCRAPE_AUTH_FAILED,
                    f"로그인 실패: {error_msg}",
                    cause=e
                )

    async def scrape_invoices(
        self,
        start_date: str,
        end_date: str,
        invoice_type: str
    ) -> list:
        """세금계산서 목록 수집"""
        try:
            # Navigate to invoice list
            await self._navigate_to_invoice_list(invoice_type)

            # Set date range
            await self._set_date_range(start_date, end_date)

            # Search
            await self.page.click("#searchBtn")
            await self.page.wait_for_load_state("networkidle")

            # Parse results
            html = await self.page.content()
            invoices = self.parser.parse_invoice_list(html)

            logger.info(
                "scrape_completed",
                count=len(invoices),
                start_date=start_date,
                end_date=end_date
            )

            return invoices

        except ScrapingException:
            raise  # Re-raise application exceptions

        except PlaywrightTimeout as e:
            raise scrape_timeout("세금계산서 조회") from e

        except Exception as e:
            logger.exception("scrape_failed", error=str(e))
            raise ScrapingException(
                ErrorCode.SCRAPE_PARSE_FAILED,
                "세금계산서 수집 중 오류가 발생했습니다.",
                cause=e,
                context={
                    "start_date": start_date,
                    "end_date": end_date,
                    "invoice_type": invoice_type,
                }
            )
```

---

## 5. API 에러 응답

### 5.1 표준 에러 응답 형식

```json
{
  "success": false,
  "error": {
    "code": "VOUCHER_UNBALANCED",
    "message": "차변과 대변의 합계가 일치하지 않습니다.",
    "details": {
      "debit_total": 1100000,
      "credit_total": 1000000,
      "difference": 100000
    },
    "field_errors": [
      {
        "field": "entries[2].credit_amount",
        "message": "금액이 부족합니다."
      }
    ]
  },
  "meta": {
    "request_id": "550e8400-e29b-41d4-a716-446655440000",
    "timestamp": "2026-01-15T10:30:00Z"
  }
}
```

### 5.2 HTTP 상태 코드 가이드

| 상태 코드 | 사용 상황 | 예시 |
|-----------|----------|------|
| 400 Bad Request | 입력값 오류 | 필수 필드 누락, 형식 오류 |
| 401 Unauthorized | 인증 실패 | 토큰 만료, 잘못된 자격증명 |
| 403 Forbidden | 권한 없음 | 다른 회사 데이터 접근 |
| 404 Not Found | 리소스 없음 | 존재하지 않는 전표 |
| 409 Conflict | 상태 충돌 | 이미 발행된 세금계산서 |
| 422 Unprocessable | 비즈니스 규칙 위반 | 차대변 불균형 |
| 429 Too Many Requests | 요청 제한 | Rate limit 초과 |
| 500 Internal Server Error | 서버 오류 | 예상치 못한 오류 |
| 502 Bad Gateway | 외부 서비스 오류 | Popbill API 오류 |
| 503 Service Unavailable | 서비스 이용 불가 | 점검 중 |
| 504 Gateway Timeout | 타임아웃 | 홈택스 응답 지연 |

### 5.3 사용자 친화적 메시지

```go
// pkg/errors/messages.go
package errors

var UserMessages = map[string]string{
    AuthInvalidCredentials: "이메일 또는 비밀번호가 올바르지 않습니다.",
    AuthTokenExpired:       "로그인이 만료되었습니다. 다시 로그인해주세요.",
    AuthForbidden:          "해당 기능에 대한 접근 권한이 없습니다.",

    VoucherNotFound:        "전표를 찾을 수 없습니다.",
    VoucherUnbalanced:      "차변과 대변의 합계가 일치하지 않습니다.",
    VoucherAlreadyPosted:   "이미 전기된 전표는 수정할 수 없습니다.",

    InvoiceNotFound:        "세금계산서를 찾을 수 없습니다.",
    InvoiceAlreadyIssued:   "이미 발행된 세금계산서입니다.",
    InvoiceIssueFailed:     "세금계산서 발행에 실패했습니다. 잠시 후 다시 시도해주세요.",
    InvoiceScrapeFailed:    "세금계산서 수집에 실패했습니다. 인증서 정보를 확인해주세요.",

    PayrollAlreadyConfirmed: "이미 확정된 급여입니다.",

    ExternalTimeout:        "외부 서비스 응답이 지연되고 있습니다. 잠시 후 다시 시도해주세요.",
    ExternalUnavailable:    "외부 서비스에 연결할 수 없습니다. 잠시 후 다시 시도해주세요.",
    ExternalRateLimited:    "요청이 너무 많습니다. 잠시 후 다시 시도해주세요.",

    SystemInternal:         "서버 오류가 발생했습니다. 문제가 지속되면 고객센터에 문의해주세요.",
    SystemMaintenance:      "시스템 점검 중입니다. 잠시 후 다시 시도해주세요.",
}

func GetUserMessage(code string) string {
    if msg, ok := UserMessages[code]; ok {
        return msg
    }
    return UserMessages[SystemInternal]
}
```

### 5.4 클라이언트 에러 처리

```typescript
// web/src/lib/api/error-handler.ts
import { toast } from '@/components/ui/toast';

interface APIError {
  code: string;
  message: string;
  details?: Record<string, any>;
  field_errors?: Array<{ field: string; message: string }>;
}

interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: APIError;
}

export async function handleAPIError(response: Response): Promise<never> {
  const body: APIResponse<unknown> = await response.json();

  if (!body.error) {
    throw new Error('Unknown error');
  }

  const { code, message, field_errors } = body.error;

  // Show toast for general errors
  if (!field_errors || field_errors.length === 0) {
    toast.error({
      title: getErrorTitle(code),
      description: message,
    });
  }

  // Throw for form handling
  throw new APIError(code, message, field_errors);
}

function getErrorTitle(code: string): string {
  const prefix = code.split('_')[0];

  switch (prefix) {
    case 'AUTH':
      return '인증 오류';
    case 'VALIDATION':
      return '입력 오류';
    case 'VOUCHER':
      return '전표 오류';
    case 'INVOICE':
      return '세금계산서 오류';
    case 'PAYROLL':
      return '급여 오류';
    case 'EXTERNAL':
      return '연동 오류';
    default:
      return '오류';
  }
}

export class APIError extends Error {
  constructor(
    public code: string,
    message: string,
    public fieldErrors?: Array<{ field: string; message: string }>
  ) {
    super(message);
    this.name = 'APIError';
  }
}
```

---

**다음 문서**: [19_배포_운영_가이드.md](./19_배포_운영_가이드.md)
