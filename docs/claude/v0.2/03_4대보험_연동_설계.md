# K-ERP v0.2 - 4대보험 연동 설계

**문서 버전**: 0.2.0
**작성일**: 2026-01-16
**상태**: 검토 대기

---

## 목차

1. [개요](#1-개요)
2. [기관별 연동 방식](#2-기관별-연동-방식)
3. [Python Insurance EDI 서비스](#3-python-insurance-edi-서비스)
4. [EDI 메시지 포맷](#4-edi-메시지-포맷)
5. [암호화 구현](#5-암호화-구현)
6. [Go 클라이언트 구현](#6-go-클라이언트-구현)

---

## 1. 개요

### 1.1 4대보험 개요

| 보험 | 관리기관 | 주요 기능 |
|------|----------|----------|
| 국민연금 | 국민연금공단 (NPS) | 취득/상실신고, 보수총액신고 |
| 건강보험 | 국민건강보험공단 (NHIS) | 취득/상실신고, 보수총액신고 |
| 고용보험 | 근로복지공단 (EI) | 취득/상실신고, 이직확인서 |
| 산재보험 | 근로복지공단 (WCI) | 취득/상실신고, 산재신청 |

### 1.2 연동 방식 비교

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   4대보험 연동 방식 비교                                │
├──────────┬────────────┬────────────┬───────────────┬───────────────────┤
│ 기관     │ 연동 방식  │ 암호화    │ 인코딩       │ 구현 언어         │
├──────────┼────────────┼────────────┼───────────────┼───────────────────┤
│ 국민연금 │ EDI + Web  │ SEED-CBC  │ EUC-KR       │ Python            │
│ 건강보험 │ EDI + API  │ ARIA-CBC  │ UTF-8        │ Python            │
│ 고용보험 │ EDI + Web  │ SEED-CBC  │ EUC-KR       │ Python            │
│ 산재보험 │ EDI + Web  │ SEED-CBC  │ EUC-KR       │ Python            │
└──────────┴────────────┴────────────┴───────────────┴───────────────────┘
```

### 1.3 Python 선택 이유

| 항목 | Go | Python | 결론 |
|------|-----|--------|------|
| SEED-CBC | 미지원 | pycryptodome | Python |
| ARIA-CBC | 미지원 | pycryptodome | Python |
| PKCS#7 서명 | 제한적 | cryptography | Python |
| EDI 파싱 | 수동 구현 | 라이브러리 존재 | Python |
| 웹 스크래핑 | colly (제한적) | Playwright | Python |

---

## 2. 기관별 연동 방식

### 2.1 국민연금공단 (NPS)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      국민연금 연동 흐름                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [K-ERP]                    [Python EDI]              [국민연금공단]    │
│                                                                         │
│  1. 취득신고 요청                                                       │
│     ──────────────────▶                                                 │
│     (gRPC)                  2. EDI 메시지 생성                          │
│                                - EUC-KR 인코딩                          │
│                                - SEED-CBC 암호화                        │
│                                - PKCS#7 서명                            │
│                                                                         │
│                             3. EDI 전송 ────────────────────▶           │
│                                (HTTPS POST)              4. 처리        │
│                                                                         │
│                             5. 응답 수신 ◀────────────────────          │
│                                - 복호화                                 │
│                                - 파싱                                   │
│                                                                         │
│  6. 결과 반환                                                           │
│     ◀──────────────────                                                 │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**지원 기능**:
- 자격취득신고 (EDI0101)
- 자격상실신고 (EDI0102)
- 내용변경신고 (EDI0103)
- 보수총액신고 (EDI0201)

### 2.2 건강보험공단 (NHIS)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      건강보험 연동 흐름                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  특이사항:                                                              │
│  - ARIA-CBC 암호화 사용 (SEED가 아님)                                   │
│  - UTF-8 인코딩                                                         │
│  - REST API 제공 (일부)                                                 │
│                                                                         │
│  [K-ERP]                    [Python EDI]              [건강보험공단]    │
│                                                                         │
│  취득신고 요청                                                          │
│     ──────────────────▶                                                 │
│     (gRPC)                  EDI 메시지 생성                             │
│                                - UTF-8 인코딩                           │
│                                - ARIA-CBC 암호화                        │
│                                                                         │
│                             EDI 전송 ────────────────────▶              │
│                                                                         │
│                             응답 수신 ◀────────────────────             │
│                                                                         │
│  결과 반환                                                              │
│     ◀──────────────────                                                 │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**지원 기능**:
- 자격취득신고
- 자격상실신고
- 보수총액신고
- 피부양자 신고

### 2.3 고용보험/산재보험 (EI/WCI)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   고용/산재보험 연동 흐름                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  특이사항:                                                              │
│  - 근로복지공단에서 통합 관리                                           │
│  - 토탈서비스(total.comwel.or.kr) 웹 포털                               │
│  - 웹 스크래핑 + EDI 혼합 방식                                          │
│                                                                         │
│  [K-ERP]                    [Python EDI]              [근로복지공단]    │
│                                                                         │
│  이직확인서 발급                                                        │
│     ──────────────────▶                                                 │
│     (gRPC)                  1. 웹 로그인                                │
│                                - 공인인증서                             │
│                                - SEED-CBC                               │
│                                                                         │
│                             2. 양식 작성                                │
│                                - Playwright                             │
│                                                                         │
│                             3. 전자서명 ────────────────────▶           │
│                                                                         │
│                             4. 결과 조회 ◀────────────────────          │
│                                                                         │
│  결과 반환                                                              │
│     ◀──────────────────                                                 │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**지원 기능 (고용보험)**:
- 피보험자격취득신고
- 피보험자격상실신고
- 이직확인서 발급
- 고용보험료 조회

**지원 기능 (산재보험)**:
- 근로자 산재신청
- 보험료 조회

---

## 3. Python Insurance EDI 서비스

### 3.1 gRPC Proto 정의

```protobuf
// api/proto/insurance.proto
syntax = "proto3";

package kerp.insurance.v1;

option go_package = "github.com/kerp/api/proto/insurance";

service InsuranceEDIService {
    // 취득신고
    rpc ReportAcquisition(AcquisitionRequest) returns (EDIResponse);

    // 상실신고
    rpc ReportLoss(LossRequest) returns (EDIResponse);

    // 이직확인서 발급
    rpc IssueSeparationCertificate(SeparationRequest) returns (SeparationResponse);

    // 보험료 조회
    rpc GetPremium(PremiumRequest) returns (PremiumResponse);

    // 보수총액 신고
    rpc ReportTotalSalary(TotalSalaryRequest) returns (EDIResponse);

    // 헬스 체크
    rpc HealthCheck(HealthRequest) returns (HealthResponse);
}

// 취득신고 요청
message AcquisitionRequest {
    string company_id = 1;
    CertificateInfo certificate = 2;

    // 대상 보험
    repeated InsuranceType insurance_types = 3;

    // 사업장 정보
    BusinessInfo business = 4;

    // 피보험자 정보
    EmployeeInfo employee = 5;

    // 취득 정보
    string acquisition_date = 6;  // YYYYMMDD
    int64 monthly_salary = 7;     // 월 보수액
    string acquisition_reason = 8; // 취득 사유 코드
}

// 보험 종류
enum InsuranceType {
    INSURANCE_UNKNOWN = 0;
    NATIONAL_PENSION = 1;    // 국민연금
    HEALTH_INSURANCE = 2;    // 건강보험
    EMPLOYMENT_INSURANCE = 3; // 고용보험
    INDUSTRIAL_ACCIDENT = 4;  // 산재보험
}

// 인증서 정보
message CertificateInfo {
    string cert_path = 1;
    string cert_password = 2;
    string business_number = 3;
}

// 사업장 정보
message BusinessInfo {
    string business_number = 1;   // 사업자등록번호
    string workplace_code = 2;    // 사업장관리번호
    string company_name = 3;
    string ceo_name = 4;
    string address = 5;
}

// 직원 정보
message EmployeeInfo {
    string resident_number = 1;   // 주민등록번호 (암호화 필수)
    string name = 2;
    string birth_date = 3;        // YYYYMMDD
    string gender = 4;            // M/F
    string nationality = 5;       // KR, etc
    string address = 6;
}

// 상실신고 요청
message LossRequest {
    string company_id = 1;
    CertificateInfo certificate = 2;
    repeated InsuranceType insurance_types = 3;
    BusinessInfo business = 4;
    EmployeeInfo employee = 5;
    string loss_date = 6;         // YYYYMMDD
    string loss_reason = 7;       // 상실 사유 코드
    int64 total_salary = 8;       // 보수총액
}

// 이직확인서 요청 (고용보험)
message SeparationRequest {
    string company_id = 1;
    CertificateInfo certificate = 2;
    BusinessInfo business = 3;
    EmployeeInfo employee = 4;

    string separation_date = 5;
    string separation_reason = 6;

    // 급여 내역 (최근 3개월)
    repeated SalaryRecord salary_records = 7;
}

// 급여 기록
message SalaryRecord {
    string year_month = 1;        // YYYYMM
    int64 total_salary = 2;       // 총 급여
    int32 working_days = 3;       // 근무일수
    int32 paid_days = 4;          // 유급일수
}

// 이직확인서 응답
message SeparationResponse {
    bool success = 1;
    string certificate_number = 2; // 확인서 번호
    string issued_at = 3;
    bytes pdf_content = 4;        // PDF 파일
    string error_code = 5;
    string error_message = 6;
}

// 보험료 조회 요청
message PremiumRequest {
    string company_id = 1;
    CertificateInfo certificate = 2;
    InsuranceType insurance_type = 3;
    BusinessInfo business = 4;
    string year_month = 5;        // YYYYMM
}

// 보험료 응답
message PremiumResponse {
    bool success = 1;
    InsuranceType insurance_type = 2;
    string year_month = 3;

    int64 company_premium = 4;    // 사업주 부담금
    int64 employee_premium = 5;   // 근로자 부담금
    int64 total_premium = 6;      // 합계

    string due_date = 7;          // 납부기한
    string error_code = 8;
    string error_message = 9;
}

// 보수총액 신고 요청
message TotalSalaryRequest {
    string company_id = 1;
    CertificateInfo certificate = 2;
    repeated InsuranceType insurance_types = 3;
    BusinessInfo business = 4;

    string report_year = 5;       // YYYY
    repeated EmployeeTotalSalary employees = 6;
}

// 직원별 보수총액
message EmployeeTotalSalary {
    EmployeeInfo employee = 1;
    int64 total_salary = 2;       // 연간 보수총액
    int32 working_months = 3;     // 근무 개월 수
}

// EDI 응답
message EDIResponse {
    bool success = 1;
    string transaction_id = 2;    // EDI 처리번호
    string processed_at = 3;
    string result_code = 4;
    string result_message = 5;
    string error_code = 6;
    string error_message = 7;
}

// 헬스 체크
message HealthRequest {}

message HealthResponse {
    HealthStatus status = 1;
    string message = 2;
}

enum HealthStatus {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
}
```

### 3.2 Python 서비스 구현

```python
# insurance-edi/src/server.py
"""4대보험 EDI gRPC 서버"""

import asyncio
import logging
from concurrent import futures

import grpc
from grpc_reflection.v1alpha import reflection

from .proto import insurance_pb2, insurance_pb2_grpc
from .agency.nps import NPSClient
from .agency.nhis import NHISClient
from .agency.ei import EIClient
from .agency.wci import WCIClient

logger = logging.getLogger(__name__)


class InsuranceEDIServicer(insurance_pb2_grpc.InsuranceEDIServiceServicer):
    """4대보험 EDI gRPC 서비스"""

    def __init__(self, config: dict):
        self.config = config
        self.nps_client = NPSClient(config)   # 국민연금
        self.nhis_client = NHISClient(config) # 건강보험
        self.ei_client = EIClient(config)     # 고용보험
        self.wci_client = WCIClient(config)   # 산재보험

    async def ReportAcquisition(
        self,
        request: insurance_pb2.AcquisitionRequest,
        context: grpc.aio.ServicerContext,
    ) -> insurance_pb2.EDIResponse:
        """취득신고"""
        logger.info(f"ReportAcquisition: company_id={request.company_id}")

        results = []

        for ins_type in request.insurance_types:
            try:
                if ins_type == insurance_pb2.NATIONAL_PENSION:
                    result = await self.nps_client.report_acquisition(request)
                elif ins_type == insurance_pb2.HEALTH_INSURANCE:
                    result = await self.nhis_client.report_acquisition(request)
                elif ins_type == insurance_pb2.EMPLOYMENT_INSURANCE:
                    result = await self.ei_client.report_acquisition(request)
                elif ins_type == insurance_pb2.INDUSTRIAL_ACCIDENT:
                    result = await self.wci_client.report_acquisition(request)
                else:
                    continue

                results.append(result)

            except Exception as e:
                logger.exception(f"Acquisition report failed for {ins_type}: {e}")
                return insurance_pb2.EDIResponse(
                    success=False,
                    error_code="REPORT_FAILED",
                    error_message=str(e),
                )

        # 모든 신고 성공
        return insurance_pb2.EDIResponse(
            success=True,
            transaction_id=results[0].get("transaction_id", ""),
            processed_at=results[0].get("processed_at", ""),
            result_code="0000",
            result_message="취득신고 완료",
        )

    async def ReportLoss(
        self,
        request: insurance_pb2.LossRequest,
        context: grpc.aio.ServicerContext,
    ) -> insurance_pb2.EDIResponse:
        """상실신고"""
        logger.info(f"ReportLoss: company_id={request.company_id}")

        results = []

        for ins_type in request.insurance_types:
            try:
                if ins_type == insurance_pb2.NATIONAL_PENSION:
                    result = await self.nps_client.report_loss(request)
                elif ins_type == insurance_pb2.HEALTH_INSURANCE:
                    result = await self.nhis_client.report_loss(request)
                elif ins_type == insurance_pb2.EMPLOYMENT_INSURANCE:
                    result = await self.ei_client.report_loss(request)
                elif ins_type == insurance_pb2.INDUSTRIAL_ACCIDENT:
                    result = await self.wci_client.report_loss(request)
                else:
                    continue

                results.append(result)

            except Exception as e:
                logger.exception(f"Loss report failed for {ins_type}: {e}")
                return insurance_pb2.EDIResponse(
                    success=False,
                    error_code="REPORT_FAILED",
                    error_message=str(e),
                )

        return insurance_pb2.EDIResponse(
            success=True,
            transaction_id=results[0].get("transaction_id", ""),
            processed_at=results[0].get("processed_at", ""),
            result_code="0000",
            result_message="상실신고 완료",
        )

    async def IssueSeparationCertificate(
        self,
        request: insurance_pb2.SeparationRequest,
        context: grpc.aio.ServicerContext,
    ) -> insurance_pb2.SeparationResponse:
        """이직확인서 발급 (고용보험)"""
        logger.info(f"IssueSeparationCertificate: company_id={request.company_id}")

        try:
            result = await self.ei_client.issue_separation_certificate(request)

            return insurance_pb2.SeparationResponse(
                success=True,
                certificate_number=result["certificate_number"],
                issued_at=result["issued_at"],
                pdf_content=result.get("pdf_content", b""),
            )

        except Exception as e:
            logger.exception(f"Separation certificate failed: {e}")
            return insurance_pb2.SeparationResponse(
                success=False,
                error_code="ISSUE_FAILED",
                error_message=str(e),
            )

    async def GetPremium(
        self,
        request: insurance_pb2.PremiumRequest,
        context: grpc.aio.ServicerContext,
    ) -> insurance_pb2.PremiumResponse:
        """보험료 조회"""
        logger.info(
            f"GetPremium: insurance_type={request.insurance_type}, "
            f"year_month={request.year_month}"
        )

        try:
            ins_type = request.insurance_type

            if ins_type == insurance_pb2.NATIONAL_PENSION:
                result = await self.nps_client.get_premium(request)
            elif ins_type == insurance_pb2.HEALTH_INSURANCE:
                result = await self.nhis_client.get_premium(request)
            elif ins_type == insurance_pb2.EMPLOYMENT_INSURANCE:
                result = await self.ei_client.get_premium(request)
            elif ins_type == insurance_pb2.INDUSTRIAL_ACCIDENT:
                result = await self.wci_client.get_premium(request)
            else:
                raise ValueError(f"Unknown insurance type: {ins_type}")

            return insurance_pb2.PremiumResponse(
                success=True,
                insurance_type=ins_type,
                year_month=request.year_month,
                company_premium=result["company_premium"],
                employee_premium=result["employee_premium"],
                total_premium=result["total_premium"],
                due_date=result.get("due_date", ""),
            )

        except Exception as e:
            logger.exception(f"Get premium failed: {e}")
            return insurance_pb2.PremiumResponse(
                success=False,
                error_code="QUERY_FAILED",
                error_message=str(e),
            )

    async def ReportTotalSalary(
        self,
        request: insurance_pb2.TotalSalaryRequest,
        context: grpc.aio.ServicerContext,
    ) -> insurance_pb2.EDIResponse:
        """보수총액 신고"""
        logger.info(f"ReportTotalSalary: year={request.report_year}")

        results = []

        for ins_type in request.insurance_types:
            try:
                if ins_type == insurance_pb2.NATIONAL_PENSION:
                    result = await self.nps_client.report_total_salary(request)
                elif ins_type == insurance_pb2.HEALTH_INSURANCE:
                    result = await self.nhis_client.report_total_salary(request)
                else:
                    continue

                results.append(result)

            except Exception as e:
                logger.exception(f"Total salary report failed: {e}")
                return insurance_pb2.EDIResponse(
                    success=False,
                    error_code="REPORT_FAILED",
                    error_message=str(e),
                )

        return insurance_pb2.EDIResponse(
            success=True,
            result_code="0000",
            result_message="보수총액 신고 완료",
        )

    async def HealthCheck(
        self,
        request: insurance_pb2.HealthRequest,
        context: grpc.aio.ServicerContext,
    ) -> insurance_pb2.HealthResponse:
        """헬스 체크"""
        return insurance_pb2.HealthResponse(
            status=insurance_pb2.HealthStatus.SERVING,
            message="Insurance EDI Service is running",
        )
```

---

## 4. EDI 메시지 포맷

### 4.1 국민연금 EDI 포맷

```python
# insurance-edi/src/edi/nps_format.py
"""국민연금 EDI 메시지 포맷"""

from dataclasses import dataclass
from typing import List
import struct


@dataclass
class NPSAcquisitionRecord:
    """국민연금 취득신고 레코드"""

    # 공통 헤더 (50 bytes)
    record_type: str          # 2 bytes - 레코드 구분 (01: 헤더, 02: 데이터, 99: 트레일러)
    transaction_code: str     # 4 bytes - 업무 코드 (0101: 취득)
    send_date: str            # 8 bytes - 전송일자 (YYYYMMDD)
    send_time: str            # 6 bytes - 전송시각 (HHMMSS)
    sender_code: str          # 10 bytes - 송신자 코드
    workplace_code: str       # 10 bytes - 사업장관리번호
    filler: str               # 10 bytes - 예비

    # 데이터 (200 bytes)
    resident_number: str      # 13 bytes - 주민등록번호
    name: str                 # 30 bytes - 성명 (EUC-KR)
    acquisition_date: str     # 8 bytes - 취득일자
    acquisition_reason: str   # 2 bytes - 취득사유코드
    monthly_salary: str       # 10 bytes - 월 소득액 (우측정렬, 0채움)
    job_code: str             # 4 bytes - 직종코드
    nationality: str          # 2 bytes - 국적코드
    address: str              # 100 bytes - 주소 (EUC-KR)
    data_filler: str          # 31 bytes - 예비


class NPSEDIGenerator:
    """국민연금 EDI 메시지 생성기"""

    ENCODING = "euc-kr"

    def generate_acquisition(
        self,
        workplace_code: str,
        employees: List[dict],
    ) -> bytes:
        """취득신고 EDI 메시지 생성"""
        lines = []

        # 헤더 레코드
        header = self._generate_header("0101", workplace_code, len(employees))
        lines.append(header)

        # 데이터 레코드
        for idx, emp in enumerate(employees, start=1):
            data = self._generate_acquisition_data(idx, emp)
            lines.append(data)

        # 트레일러 레코드
        trailer = self._generate_trailer(len(employees))
        lines.append(trailer)

        # 줄 연결 및 EUC-KR 인코딩
        message = "\r\n".join(lines)
        return message.encode(self.ENCODING)

    def _generate_header(
        self,
        transaction_code: str,
        workplace_code: str,
        record_count: int,
    ) -> str:
        """헤더 레코드 생성"""
        from datetime import datetime

        now = datetime.now()

        return "".join([
            "01",                              # 레코드 구분
            transaction_code,                  # 업무 코드
            now.strftime("%Y%m%d"),            # 전송일자
            now.strftime("%H%M%S"),            # 전송시각
            "KERPSAAS01".ljust(10),            # 송신자 코드
            workplace_code.ljust(10),          # 사업장관리번호
            str(record_count).zfill(6),        # 레코드 건수
            " " * 4,                           # 예비
        ])

    def _generate_acquisition_data(self, seq: int, emp: dict) -> str:
        """취득신고 데이터 레코드 생성"""
        name_encoded = emp["name"].encode(self.ENCODING)
        name_padded = name_encoded.ljust(30)[:30].decode(self.ENCODING, errors="replace")

        address_encoded = emp.get("address", "").encode(self.ENCODING)
        address_padded = address_encoded.ljust(100)[:100].decode(self.ENCODING, errors="replace")

        return "".join([
            "02",                                  # 레코드 구분
            str(seq).zfill(6),                    # 일련번호
            emp["resident_number"].replace("-", ""), # 주민등록번호 (13)
            name_padded,                          # 성명 (30)
            emp["acquisition_date"],              # 취득일자 (8)
            emp.get("acquisition_reason", "01"),  # 취득사유 (2)
            str(emp["monthly_salary"]).zfill(10), # 월소득액 (10)
            emp.get("job_code", "9999"),          # 직종코드 (4)
            emp.get("nationality", "KR"),         # 국적 (2)
            address_padded,                       # 주소 (100)
            " " * 25,                             # 예비
        ])

    def _generate_trailer(self, record_count: int) -> str:
        """트레일러 레코드 생성"""
        return "".join([
            "99",                              # 레코드 구분
            str(record_count).zfill(8),       # 총 레코드 수
            " " * 240,                        # 예비
        ])


class NPSEDIParser:
    """국민연금 EDI 응답 파서"""

    ENCODING = "euc-kr"

    def parse_response(self, data: bytes) -> dict:
        """EDI 응답 파싱"""
        text = data.decode(self.ENCODING)
        lines = text.split("\r\n")

        result = {
            "success": False,
            "records": [],
            "errors": [],
        }

        for line in lines:
            if not line:
                continue

            record_type = line[:2]

            if record_type == "01":
                # 헤더 파싱
                result["transaction_id"] = line[2:12].strip()
                result["processed_at"] = line[12:20]

            elif record_type == "02":
                # 데이터 레코드 파싱
                record = {
                    "seq": int(line[2:8]),
                    "result_code": line[8:12].strip(),
                    "result_message": line[12:112].strip(),
                }
                result["records"].append(record)

                if record["result_code"] != "0000":
                    result["errors"].append(record)

            elif record_type == "99":
                # 트레일러
                total_count = int(line[2:10])
                success_count = int(line[10:18])
                fail_count = int(line[18:26])

                result["total_count"] = total_count
                result["success_count"] = success_count
                result["fail_count"] = fail_count
                result["success"] = fail_count == 0

        return result
```

---

## 5. 암호화 구현

### 5.1 SEED-CBC 암호화

```python
# insurance-edi/src/crypto/seed.py
"""SEED-CBC 암호화 (국민연금, 고용보험, 산재보험)"""

from Crypto.Cipher import AES
from typing import Tuple
import os


class SEEDCipher:
    """
    SEED-CBC 암호화/복호화

    SEED는 한국 표준 블록 암호화 알고리즘
    128비트 키, 128비트 블록 크기
    """

    BLOCK_SIZE = 16

    def __init__(self, key: bytes, iv: bytes = None):
        """
        Args:
            key: 16바이트 암호화 키
            iv: 16바이트 초기화 벡터 (None이면 자동 생성)
        """
        if len(key) != 16:
            raise ValueError(f"Key must be 16 bytes, got {len(key)}")

        self.key = key
        self.iv = iv if iv else os.urandom(16)

    def encrypt(self, plaintext: bytes) -> Tuple[bytes, bytes]:
        """
        PKCS7 패딩 후 CBC 모드 암호화

        Returns:
            (암호문, IV) 튜플
        """
        # PKCS7 패딩
        padding_len = self.BLOCK_SIZE - (len(plaintext) % self.BLOCK_SIZE)
        padded = plaintext + bytes([padding_len] * padding_len)

        # SEED-CBC 암호화 (pycryptodome의 AES를 SEED로 대체)
        # 실제로는 KISA SEED 라이브러리 사용
        from kisa_seed import SEED

        cipher = SEED(self.key, mode=SEED.MODE_CBC, iv=self.iv)
        ciphertext = cipher.encrypt(padded)

        return ciphertext, self.iv

    def decrypt(self, ciphertext: bytes, iv: bytes = None) -> bytes:
        """
        CBC 모드 복호화 후 PKCS7 언패딩

        Args:
            ciphertext: 암호문
            iv: 초기화 벡터 (None이면 인스턴스 IV 사용)

        Returns:
            평문
        """
        iv = iv or self.iv

        from kisa_seed import SEED

        cipher = SEED(self.key, mode=SEED.MODE_CBC, iv=iv)
        plaintext = cipher.decrypt(ciphertext)

        # PKCS7 언패딩
        padding_len = plaintext[-1]
        return plaintext[:-padding_len]
```

### 5.2 ARIA-CBC 암호화

```python
# insurance-edi/src/crypto/aria.py
"""ARIA-CBC 암호화 (건강보험)"""

from Crypto.Cipher import AES
from typing import Tuple
import os


class ARIACipher:
    """
    ARIA-CBC 암호화/복호화

    ARIA는 한국 표준 암호화 알고리즘 (AES 대응)
    128/192/256비트 키 지원
    """

    BLOCK_SIZE = 16

    def __init__(self, key: bytes, iv: bytes = None):
        """
        Args:
            key: 16/24/32바이트 암호화 키
            iv: 16바이트 초기화 벡터
        """
        if len(key) not in (16, 24, 32):
            raise ValueError(f"Key must be 16, 24, or 32 bytes, got {len(key)}")

        self.key = key
        self.iv = iv if iv else os.urandom(16)

    def encrypt(self, plaintext: bytes) -> Tuple[bytes, bytes]:
        """ARIA-CBC 암호화"""
        # PKCS7 패딩
        padding_len = self.BLOCK_SIZE - (len(plaintext) % self.BLOCK_SIZE)
        padded = plaintext + bytes([padding_len] * padding_len)

        # ARIA 암호화
        from kisa_aria import ARIA

        cipher = ARIA(self.key, mode=ARIA.MODE_CBC, iv=self.iv)
        ciphertext = cipher.encrypt(padded)

        return ciphertext, self.iv

    def decrypt(self, ciphertext: bytes, iv: bytes = None) -> bytes:
        """ARIA-CBC 복호화"""
        iv = iv or self.iv

        from kisa_aria import ARIA

        cipher = ARIA(self.key, mode=ARIA.MODE_CBC, iv=iv)
        plaintext = cipher.decrypt(ciphertext)

        # PKCS7 언패딩
        padding_len = plaintext[-1]
        return plaintext[:-padding_len]
```

### 5.3 PKCS#7 전자서명

```python
# insurance-edi/src/crypto/signature.py
"""PKCS#7 전자서명 (공인인증서)"""

from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.serialization import pkcs7
import base64


class PKCSSignature:
    """PKCS#7 전자서명"""

    def __init__(self, cert_path: str, key_path: str, password: str):
        """
        Args:
            cert_path: 인증서 파일 경로
            key_path: 개인키 파일 경로
            password: 개인키 비밀번호
        """
        # 인증서 로드
        with open(cert_path, "rb") as f:
            cert_data = f.read()
        self.cert = x509.load_der_x509_certificate(cert_data, default_backend())

        # 개인키 로드 (SEED 암호화된 경우 복호화)
        with open(key_path, "rb") as f:
            key_data = f.read()

        # PKCS#8 또는 한국 공인인증서 포맷 처리
        self.private_key = self._load_private_key(key_data, password)

    def _load_private_key(self, key_data: bytes, password: str):
        """개인키 로드 (한국 공인인증서 포맷 지원)"""
        from .seed import SEEDCipher

        # 한국 공인인증서는 SEED로 암호화됨
        # 비밀번호에서 키 파생
        key = self._derive_key(password)
        iv = key_data[:16]
        encrypted_key = key_data[16:]

        cipher = SEEDCipher(key, iv)
        decrypted = cipher.decrypt(encrypted_key)

        return serialization.load_der_private_key(
            decrypted,
            password=None,
            backend=default_backend()
        )

    def _derive_key(self, password: str) -> bytes:
        """비밀번호에서 암호화 키 파생"""
        import hashlib
        # PBKDF2 또는 SHA256 기반 키 파생
        return hashlib.sha256(password.encode()).digest()[:16]

    def sign(self, data: bytes) -> bytes:
        """
        PKCS#7 서명 생성

        Args:
            data: 서명할 데이터

        Returns:
            PKCS#7 서명 (DER 인코딩)
        """
        from cryptography.hazmat.primitives.serialization import pkcs7

        # PKCS#7 서명 생성
        signature = pkcs7.PKCS7SignatureBuilder().set_data(
            data
        ).add_signer(
            self.cert,
            self.private_key,
            hashes.SHA256()
        ).sign(
            serialization.Encoding.DER,
            [pkcs7.PKCS7Options.DetachedSignature]
        )

        return signature

    def verify(self, data: bytes, signature: bytes, cert: x509.Certificate = None) -> bool:
        """
        PKCS#7 서명 검증

        Args:
            data: 원본 데이터
            signature: PKCS#7 서명
            cert: 검증에 사용할 인증서 (None이면 자체 인증서)

        Returns:
            검증 성공 여부
        """
        cert = cert or self.cert

        try:
            # 서명 검증
            pkcs7.load_der_pkcs7_signatures(signature)
            # 실제 검증 로직
            return True
        except Exception:
            return False
```

---

## 6. Go 클라이언트 구현

### 6.1 Insurance EDI 클라이언트

```go
// internal/grpc/insurance_client.go
package grpc

import (
    "context"
    "fmt"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    "google.golang.org/grpc/keepalive"

    pb "github.com/kerp/api/proto/insurance"
)

// InsuranceEDIClient gRPC 클라이언트
type InsuranceEDIClient struct {
    conn   *grpc.ClientConn
    client pb.InsuranceEDIServiceClient
    config *InsuranceConfig
}

// InsuranceConfig 설정
type InsuranceConfig struct {
    Address       string
    Timeout       time.Duration
    MaxRetries    int
    KeepAliveTime time.Duration
}

// NewInsuranceEDIClient 생성
func NewInsuranceEDIClient(cfg *InsuranceConfig) (*InsuranceEDIClient, error) {
    opts := []grpc.DialOption{
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithKeepaliveParams(keepalive.ClientParameters{
            Time:                cfg.KeepAliveTime,
            Timeout:             cfg.Timeout,
            PermitWithoutStream: true,
        }),
    }

    conn, err := grpc.Dial(cfg.Address, opts...)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to insurance EDI: %w", err)
    }

    return &InsuranceEDIClient{
        conn:   conn,
        client: pb.NewInsuranceEDIServiceClient(conn),
        config: cfg,
    }, nil
}

// ReportAcquisition 취득신고
func (c *InsuranceEDIClient) ReportAcquisition(
    ctx context.Context,
    req *pb.AcquisitionRequest,
) (*pb.EDIResponse, error) {
    ctx, cancel := context.WithTimeout(ctx, c.config.Timeout)
    defer cancel()

    return c.client.ReportAcquisition(ctx, req)
}

// ReportLoss 상실신고
func (c *InsuranceEDIClient) ReportLoss(
    ctx context.Context,
    req *pb.LossRequest,
) (*pb.EDIResponse, error) {
    ctx, cancel := context.WithTimeout(ctx, c.config.Timeout)
    defer cancel()

    return c.client.ReportLoss(ctx, req)
}

// IssueSeparationCertificate 이직확인서 발급
func (c *InsuranceEDIClient) IssueSeparationCertificate(
    ctx context.Context,
    req *pb.SeparationRequest,
) (*pb.SeparationResponse, error) {
    // 이직확인서는 웹 스크래핑이 포함되어 시간이 더 걸림
    ctx, cancel := context.WithTimeout(ctx, 5*time.Minute)
    defer cancel()

    return c.client.IssueSeparationCertificate(ctx, req)
}

// GetPremium 보험료 조회
func (c *InsuranceEDIClient) GetPremium(
    ctx context.Context,
    req *pb.PremiumRequest,
) (*pb.PremiumResponse, error) {
    ctx, cancel := context.WithTimeout(ctx, c.config.Timeout)
    defer cancel()

    return c.client.GetPremium(ctx, req)
}

// HealthCheck 헬스 체크
func (c *InsuranceEDIClient) HealthCheck(ctx context.Context) error {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    resp, err := c.client.HealthCheck(ctx, &pb.HealthRequest{})
    if err != nil {
        return err
    }

    if resp.Status != pb.HealthStatus_SERVING {
        return fmt.Errorf("insurance EDI not serving: %s", resp.Status)
    }

    return nil
}

// Close 연결 종료
func (c *InsuranceEDIClient) Close() error {
    return c.conn.Close()
}
```

### 6.2 Insurance 서비스 레이어

```go
// internal/service/insurance_service.go
package service

import (
    "context"
    "fmt"

    "github.com/google/uuid"
    "github.com/kerp/internal/domain"
    "github.com/kerp/internal/grpc"
    "github.com/kerp/internal/repository"
    pb "github.com/kerp/api/proto/insurance"
    "go.uber.org/zap"
)

// InsuranceService 4대보험 서비스
type InsuranceService struct {
    client    *grpc.InsuranceEDIClient
    repo      repository.InsuranceRepository
    certStore CertificateStore
    logger    *zap.Logger
}

// CertificateStore 인증서 저장소
type CertificateStore interface {
    GetCertificate(ctx context.Context, companyID string) (*Certificate, error)
}

// NewInsuranceService 생성
func NewInsuranceService(
    client *grpc.InsuranceEDIClient,
    repo repository.InsuranceRepository,
    certStore CertificateStore,
    logger *zap.Logger,
) *InsuranceService {
    return &InsuranceService{
        client:    client,
        repo:      repo,
        certStore: certStore,
        logger:    logger,
    }
}

// ReportAcquisition 취득신고
func (s *InsuranceService) ReportAcquisition(
    ctx context.Context,
    companyID uuid.UUID,
    insuranceTypes []domain.InsuranceType,
    employee *domain.Employee,
) (*domain.InsuranceReport, error) {
    // 인증서 조회
    cert, err := s.certStore.GetCertificate(ctx, companyID.String())
    if err != nil {
        return nil, fmt.Errorf("failed to get certificate: %w", err)
    }

    // gRPC 요청 생성
    req := &pb.AcquisitionRequest{
        CompanyId: companyID.String(),
        Certificate: &pb.CertificateInfo{
            CertPath:       cert.CertPath,
            CertPassword:   cert.CertPassword,
            BusinessNumber: cert.BusinessNum,
        },
        InsuranceTypes: s.toProtoInsuranceTypes(insuranceTypes),
        Employee: &pb.EmployeeInfo{
            ResidentNumber: employee.ResidentNumber,
            Name:           employee.Name,
            BirthDate:      employee.BirthDate.Format("20060102"),
        },
        AcquisitionDate: employee.JoinDate.Format("20060102"),
        MonthlySalary:   employee.MonthlySalary,
    }

    // EDI 호출
    resp, err := s.client.ReportAcquisition(ctx, req)
    if err != nil {
        return nil, fmt.Errorf("acquisition report failed: %w", err)
    }

    if !resp.Success {
        return nil, fmt.Errorf("EDI error: %s - %s", resp.ErrorCode, resp.ErrorMessage)
    }

    // 결과 저장
    report := &domain.InsuranceReport{
        ID:            uuid.New(),
        CompanyID:     companyID,
        EmployeeID:    employee.ID,
        ReportType:    domain.ReportTypeAcquisition,
        TransactionID: resp.TransactionId,
        Status:        domain.ReportStatusCompleted,
    }

    if err := s.repo.CreateReport(ctx, report); err != nil {
        s.logger.Warn("failed to save report", zap.Error(err))
    }

    return report, nil
}

func (s *InsuranceService) toProtoInsuranceTypes(
    types []domain.InsuranceType,
) []pb.InsuranceType {
    result := make([]pb.InsuranceType, len(types))
    for i, t := range types {
        switch t {
        case domain.InsuranceNationalPension:
            result[i] = pb.InsuranceType_NATIONAL_PENSION
        case domain.InsuranceHealthInsurance:
            result[i] = pb.InsuranceType_HEALTH_INSURANCE
        case domain.InsuranceEmployment:
            result[i] = pb.InsuranceType_EMPLOYMENT_INSURANCE
        case domain.InsuranceIndustrialAccident:
            result[i] = pb.InsuranceType_INDUSTRIAL_ACCIDENT
        }
    }
    return result
}
```

---

**다음 문서**: [04_gRPC_인터페이스_설계.md](./04_gRPC_인터페이스_설계.md)
