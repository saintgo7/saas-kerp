# K-ERP 고객 온보딩 가이드

## 목차

1. [개요](#1-개요)
2. [온보딩 프로세스](#2-온보딩-프로세스)
3. [테넌트 프로비저닝](#3-테넌트-프로비저닝)
4. [초기 설정 마법사](#4-초기-설정-마법사)
5. [데이터 임포트](#5-데이터-임포트)
6. [사용자 교육](#6-사용자-교육)
7. [정부기관 연동 설정](#7-정부기관-연동-설정)
8. [Go-Live 체크리스트](#8-go-live-체크리스트)
9. [온보딩 자동화](#9-온보딩-자동화)
10. [지원 및 에스컬레이션](#10-지원-및-에스컬레이션)

---

## 1. 개요

### 1.1 온보딩 목표

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Customer Onboarding Journey                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   계약 체결        테넌트 생성        초기 설정        데이터 이관      │
│      │                │                │                │                │
│      ▼                ▼                ▼                ▼                │
│   ┌─────┐         ┌─────┐         ┌─────┐         ┌─────┐              │
│   │ D-0 │─────────│ D+1 │─────────│ D+3 │─────────│ D+7 │              │
│   └─────┘         └─────┘         └─────┘         └─────┘              │
│                                                                          │
│      │                │                │                │                │
│      ▼                ▼                ▼                ▼                │
│   ┌─────┐         ┌─────┐         ┌─────┐         ┌─────┐              │
│   │D+14 │─────────│D+21 │─────────│D+28 │─────────│D+30 │              │
│   └─────┘         └─────┘         └─────┘         └─────┘              │
│                                                                          │
│   교육 완료       시험 운영        검증 완료       정식 운영            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 온보딩 타임라인

| 단계 | 기간 | 주요 활동 | 담당자 |
|------|------|-----------|--------|
| 계약/킥오프 | D+0 | 계약 체결, 킥오프 미팅 | 영업, CSM |
| 환경 구성 | D+1~3 | 테넌트 생성, 초기 설정 | 기술지원 |
| 데이터 이관 | D+4~7 | 기존 데이터 마이그레이션 | 기술지원 |
| 사용자 교육 | D+8~14 | 관리자/사용자 교육 | CSM |
| 시험 운영 | D+15~21 | 병행 운영, 검증 | 고객, CSM |
| 최종 검증 | D+22~28 | 최종 점검, 이슈 해결 | 기술지원 |
| Go-Live | D+30 | 정식 운영 전환 | 전체 |

### 1.3 요금제별 온보딩 범위

| 항목 | Basic | Standard | Enterprise |
|------|-------|----------|------------|
| 셀프 온보딩 | O | O | O |
| 온보딩 매니저 배정 | - | O | O |
| 전담 기술 지원 | - | - | O |
| 현장 방문 교육 | - | - | O |
| 데이터 마이그레이션 지원 | 가이드만 | 원격 지원 | 전담 수행 |
| 맞춤 설정 | - | 제한적 | 무제한 |
| SLA | 99% | 99.5% | 99.9% |

---

## 2. 온보딩 프로세스

### 2.1 온보딩 워크플로우

```go
// internal/service/onboarding_service.go

package service

import (
    "context"
    "fmt"
    "time"

    "github.com/google/uuid"
    "kerp/internal/domain"
    "kerp/internal/dto"
    "kerp/pkg/logger"
)

type OnboardingService struct {
    companyRepo    CompanyRepository
    userRepo       UserRepository
    subscriptionRepo SubscriptionRepository
    provisioningService ProvisioningService
    emailService   EmailService
    eventPublisher EventPublisher
    logger         *logger.Logger
}

// OnboardingStatus represents the current onboarding state
type OnboardingStatus string

const (
    OnboardingPending       OnboardingStatus = "pending"
    OnboardingProvisioning  OnboardingStatus = "provisioning"
    OnboardingSetup         OnboardingStatus = "setup"
    OnboardingDataImport    OnboardingStatus = "data_import"
    OnboardingTraining      OnboardingStatus = "training"
    OnboardingValidation    OnboardingStatus = "validation"
    OnboardingCompleted     OnboardingStatus = "completed"
)

// OnboardingProgress tracks the completion of each step
type OnboardingProgress struct {
    CompanyID       uuid.UUID         `json:"company_id"`
    Status          OnboardingStatus  `json:"status"`
    Steps           []OnboardingStep  `json:"steps"`
    StartedAt       time.Time         `json:"started_at"`
    CompletedAt     *time.Time        `json:"completed_at,omitempty"`
    EstimatedGoLive time.Time         `json:"estimated_go_live"`
}

type OnboardingStep struct {
    Name        string     `json:"name"`
    Description string     `json:"description"`
    Status      string     `json:"status"` // pending, in_progress, completed, skipped
    CompletedAt *time.Time `json:"completed_at,omitempty"`
    CompletedBy *uuid.UUID `json:"completed_by,omitempty"`
    Notes       string     `json:"notes,omitempty"`
}

// StartOnboarding initiates the onboarding process for a new customer
func (s *OnboardingService) StartOnboarding(ctx context.Context, req *dto.OnboardingRequest) (*OnboardingProgress, error) {
    s.logger.Info("Starting onboarding process", "company_name", req.CompanyName)

    // 1. Create company
    company := &domain.Company{
        ID:                 uuid.New(),
        Name:               req.CompanyName,
        BusinessNumber:     req.BusinessNumber,
        RepresentativeName: req.RepresentativeName,
        Email:              req.Email,
        Phone:              req.Phone,
        Address:            req.Address,
        PlanType:           req.PlanType,
        Status:             domain.CompanyStatusOnboarding,
        OnboardingStartedAt: time.Now(),
    }

    if err := s.companyRepo.Create(ctx, company); err != nil {
        return nil, fmt.Errorf("failed to create company: %w", err)
    }

    // 2. Create admin user
    adminUser := &domain.User{
        ID:        uuid.New(),
        CompanyID: company.ID,
        Email:     req.AdminEmail,
        Name:      req.AdminName,
        Role:      domain.RoleCompanyAdmin,
        Status:    domain.UserStatusPendingActivation,
    }

    if err := s.userRepo.Create(ctx, adminUser); err != nil {
        return nil, fmt.Errorf("failed to create admin user: %w", err)
    }

    // 3. Create subscription
    subscription := &domain.Subscription{
        ID:          uuid.New(),
        CompanyID:   company.ID,
        PlanType:    req.PlanType,
        Status:      domain.SubscriptionStatusTrial,
        TrialEndsAt: time.Now().AddDate(0, 0, 14), // 14-day trial
        CreatedAt:   time.Now(),
    }

    if err := s.subscriptionRepo.Create(ctx, subscription); err != nil {
        return nil, fmt.Errorf("failed to create subscription: %w", err)
    }

    // 4. Initialize onboarding progress
    progress := s.initializeProgress(company.ID, req.PlanType)

    // 5. Trigger provisioning asynchronously
    s.eventPublisher.Publish(ctx, "onboarding.started", map[string]interface{}{
        "company_id":   company.ID,
        "plan_type":    req.PlanType,
        "admin_user_id": adminUser.ID,
    })

    // 6. Send welcome email
    go s.emailService.SendWelcomeEmail(ctx, adminUser.Email, map[string]string{
        "company_name": company.Name,
        "admin_name":   adminUser.Name,
    })

    s.logger.Info("Onboarding initiated successfully", "company_id", company.ID)

    return progress, nil
}

func (s *OnboardingService) initializeProgress(companyID uuid.UUID, planType string) *OnboardingProgress {
    steps := []OnboardingStep{
        {Name: "company_setup", Description: "회사 기본 정보 설정", Status: "completed"},
        {Name: "admin_account", Description: "관리자 계정 생성", Status: "completed"},
        {Name: "organization", Description: "조직 구조 설정", Status: "pending"},
        {Name: "chart_of_accounts", Description: "계정과목 설정", Status: "pending"},
        {Name: "users_setup", Description: "사용자 등록", Status: "pending"},
        {Name: "data_import", Description: "기존 데이터 이관", Status: "pending"},
        {Name: "popbill_setup", Description: "세금계산서 연동 설정", Status: "pending"},
        {Name: "bank_setup", Description: "은행 연동 설정", Status: "pending"},
        {Name: "training", Description: "사용자 교육", Status: "pending"},
        {Name: "validation", Description: "시험 운영 및 검증", Status: "pending"},
    }

    // Add enterprise-specific steps
    if planType == "enterprise" {
        steps = append(steps,
            OnboardingStep{Name: "insurance_edi", Description: "4대보험 EDI 연동", Status: "pending"},
            OnboardingStep{Name: "custom_integration", Description: "맞춤 연동 설정", Status: "pending"},
        )
    }

    return &OnboardingProgress{
        CompanyID:       companyID,
        Status:          OnboardingProvisioning,
        Steps:           steps,
        StartedAt:       time.Now(),
        EstimatedGoLive: time.Now().AddDate(0, 0, 30),
    }
}

// CompleteStep marks an onboarding step as completed
func (s *OnboardingService) CompleteStep(ctx context.Context, companyID uuid.UUID, stepName string, completedBy uuid.UUID, notes string) error {
    progress, err := s.GetProgress(ctx, companyID)
    if err != nil {
        return err
    }

    now := time.Now()
    for i, step := range progress.Steps {
        if step.Name == stepName {
            progress.Steps[i].Status = "completed"
            progress.Steps[i].CompletedAt = &now
            progress.Steps[i].CompletedBy = &completedBy
            progress.Steps[i].Notes = notes
            break
        }
    }

    // Check if all steps are completed
    allCompleted := true
    for _, step := range progress.Steps {
        if step.Status != "completed" && step.Status != "skipped" {
            allCompleted = false
            break
        }
    }

    if allCompleted {
        progress.Status = OnboardingCompleted
        progress.CompletedAt = &now

        // Update company status
        if err := s.companyRepo.UpdateStatus(ctx, companyID, domain.CompanyStatusActive); err != nil {
            return fmt.Errorf("failed to activate company: %w", err)
        }

        // Publish completion event
        s.eventPublisher.Publish(ctx, "onboarding.completed", map[string]interface{}{
            "company_id":   companyID,
            "completed_at": now,
        })
    }

    return s.saveProgress(ctx, progress)
}

// GetProgress returns the current onboarding progress
func (s *OnboardingService) GetProgress(ctx context.Context, companyID uuid.UUID) (*OnboardingProgress, error) {
    // Implementation to fetch progress from database
    return nil, nil
}

func (s *OnboardingService) saveProgress(ctx context.Context, progress *OnboardingProgress) error {
    // Implementation to save progress to database
    return nil
}
```

### 2.2 온보딩 체크리스트 API

```go
// internal/handler/onboarding_handler.go

package handler

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
    "kerp/internal/dto"
    "kerp/internal/service"
)

type OnboardingHandler struct {
    onboardingService *service.OnboardingService
}

// GetOnboardingChecklist returns the onboarding checklist for the current company
func (h *OnboardingHandler) GetOnboardingChecklist(c *gin.Context) {
    companyID := c.MustGet("company_id").(uuid.UUID)

    progress, err := h.onboardingService.GetProgress(c.Request.Context(), companyID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    // Calculate completion percentage
    completed := 0
    for _, step := range progress.Steps {
        if step.Status == "completed" || step.Status == "skipped" {
            completed++
        }
    }
    completionPercentage := float64(completed) / float64(len(progress.Steps)) * 100

    response := dto.OnboardingChecklistResponse{
        Progress:             progress,
        CompletionPercentage: completionPercentage,
        NextSteps:            h.getNextSteps(progress),
        EstimatedDaysToGoLive: h.calculateDaysToGoLive(progress),
    }

    c.JSON(http.StatusOK, response)
}

// CompleteOnboardingStep marks a step as completed
func (h *OnboardingHandler) CompleteOnboardingStep(c *gin.Context) {
    companyID := c.MustGet("company_id").(uuid.UUID)
    userID := c.MustGet("user_id").(uuid.UUID)
    stepName := c.Param("step")

    var req dto.CompleteStepRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    if err := h.onboardingService.CompleteStep(c.Request.Context(), companyID, stepName, userID, req.Notes); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "Step completed successfully"})
}

func (h *OnboardingHandler) getNextSteps(progress *service.OnboardingProgress) []dto.NextStep {
    var nextSteps []dto.NextStep

    for _, step := range progress.Steps {
        if step.Status == "pending" || step.Status == "in_progress" {
            nextSteps = append(nextSteps, dto.NextStep{
                Name:        step.Name,
                Description: step.Description,
                HelpURL:     h.getHelpURL(step.Name),
            })
            if len(nextSteps) >= 3 {
                break
            }
        }
    }

    return nextSteps
}

func (h *OnboardingHandler) getHelpURL(stepName string) string {
    helpURLs := map[string]string{
        "organization":       "/help/setup/organization",
        "chart_of_accounts":  "/help/setup/chart-of-accounts",
        "users_setup":        "/help/setup/users",
        "data_import":        "/help/setup/data-import",
        "popbill_setup":      "/help/integrations/popbill",
        "bank_setup":         "/help/integrations/bank",
        "training":           "/help/training",
        "validation":         "/help/validation",
    }
    return helpURLs[stepName]
}

func (h *OnboardingHandler) calculateDaysToGoLive(progress *service.OnboardingProgress) int {
    // Implementation
    return 0
}
```

---

## 3. 테넌트 프로비저닝

### 3.1 자동 프로비저닝 시스템

```go
// internal/service/provisioning_service.go

package service

import (
    "context"
    "fmt"
    "time"

    "github.com/google/uuid"
    "kerp/internal/domain"
    "kerp/pkg/logger"
)

type ProvisioningService struct {
    db              Database
    cacheService    CacheService
    searchService   SearchService
    storageService  StorageService
    logger          *logger.Logger
}

type ProvisioningResult struct {
    CompanyID      uuid.UUID `json:"company_id"`
    TenantID       string    `json:"tenant_id"`
    DatabaseSchema string    `json:"database_schema"`
    StorageBucket  string    `json:"storage_bucket"`
    SearchIndex    string    `json:"search_index"`
    CacheNamespace string    `json:"cache_namespace"`
    ProvisionedAt  time.Time `json:"provisioned_at"`
}

// ProvisionTenant creates all necessary resources for a new tenant
func (s *ProvisioningService) ProvisionTenant(ctx context.Context, company *domain.Company) (*ProvisioningResult, error) {
    s.logger.Info("Starting tenant provisioning", "company_id", company.ID)

    tenantID := fmt.Sprintf("tenant_%s", company.ID.String()[:8])

    // 1. Initialize database schema and apply RLS
    if err := s.setupDatabaseTenant(ctx, company.ID, tenantID); err != nil {
        return nil, fmt.Errorf("database setup failed: %w", err)
    }

    // 2. Create storage bucket/folder
    storageBucket := fmt.Sprintf("kerp-files/%s", tenantID)
    if err := s.storageService.CreateBucket(ctx, storageBucket); err != nil {
        return nil, fmt.Errorf("storage setup failed: %w", err)
    }

    // 3. Initialize search index
    searchIndex := fmt.Sprintf("kerp_%s", tenantID)
    if err := s.searchService.CreateIndex(ctx, searchIndex); err != nil {
        return nil, fmt.Errorf("search index setup failed: %w", err)
    }

    // 4. Setup cache namespace
    cacheNamespace := fmt.Sprintf("kerp:%s", tenantID)
    if err := s.cacheService.InitNamespace(ctx, cacheNamespace); err != nil {
        return nil, fmt.Errorf("cache setup failed: %w", err)
    }

    // 5. Initialize default data
    if err := s.initializeDefaultData(ctx, company.ID); err != nil {
        return nil, fmt.Errorf("default data initialization failed: %w", err)
    }

    result := &ProvisioningResult{
        CompanyID:      company.ID,
        TenantID:       tenantID,
        DatabaseSchema: "public", // Using RLS, not separate schemas
        StorageBucket:  storageBucket,
        SearchIndex:    searchIndex,
        CacheNamespace: cacheNamespace,
        ProvisionedAt:  time.Now(),
    }

    s.logger.Info("Tenant provisioning completed", "result", result)

    return result, nil
}

// setupDatabaseTenant configures RLS policies for the new tenant
func (s *ProvisioningService) setupDatabaseTenant(ctx context.Context, companyID uuid.UUID, tenantID string) error {
    // Verify company row exists
    _, err := s.db.ExecContext(ctx, `
        UPDATE companies SET tenant_id = $1 WHERE id = $2
    `, tenantID, companyID)
    if err != nil {
        return fmt.Errorf("failed to set tenant_id: %w", err)
    }

    return nil
}

// initializeDefaultData creates default records for the new tenant
func (s *ProvisioningService) initializeDefaultData(ctx context.Context, companyID uuid.UUID) error {
    // Begin transaction
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. Default chart of accounts (K-IFRS standard)
    if err := s.createDefaultChartOfAccounts(ctx, tx, companyID); err != nil {
        return fmt.Errorf("chart of accounts creation failed: %w", err)
    }

    // 2. Default departments
    if err := s.createDefaultDepartments(ctx, tx, companyID); err != nil {
        return fmt.Errorf("departments creation failed: %w", err)
    }

    // 3. Default fiscal year
    if err := s.createDefaultFiscalYear(ctx, tx, companyID); err != nil {
        return fmt.Errorf("fiscal year creation failed: %w", err)
    }

    // 4. Default document number sequences
    if err := s.createDefaultSequences(ctx, tx, companyID); err != nil {
        return fmt.Errorf("sequences creation failed: %w", err)
    }

    // 5. Default system settings
    if err := s.createDefaultSettings(ctx, tx, companyID); err != nil {
        return fmt.Errorf("settings creation failed: %w", err)
    }

    return tx.Commit()
}

// createDefaultChartOfAccounts creates K-IFRS standard chart of accounts
func (s *ProvisioningService) createDefaultChartOfAccounts(ctx context.Context, tx Transaction, companyID uuid.UUID) error {
    accounts := []struct {
        Code        string
        Name        string
        AccountType string
        Category    string
    }{
        // Assets (자산)
        {"1000", "자산", "asset", "header"},
        {"1100", "유동자산", "asset", "header"},
        {"1101", "현금및현금성자산", "asset", "detail"},
        {"1102", "단기금융상품", "asset", "detail"},
        {"1110", "매출채권", "asset", "detail"},
        {"1111", "대손충당금(매출채권)", "asset", "contra"},
        {"1120", "미수금", "asset", "detail"},
        {"1130", "선급금", "asset", "detail"},
        {"1140", "선급비용", "asset", "detail"},
        {"1150", "재고자산", "asset", "detail"},
        {"1200", "비유동자산", "asset", "header"},
        {"1210", "유형자산", "asset", "detail"},
        {"1211", "토지", "asset", "detail"},
        {"1212", "건물", "asset", "detail"},
        {"1213", "감가상각누계액(건물)", "asset", "contra"},
        {"1214", "기계장치", "asset", "detail"},
        {"1215", "차량운반구", "asset", "detail"},
        {"1216", "비품", "asset", "detail"},
        {"1220", "무형자산", "asset", "detail"},

        // Liabilities (부채)
        {"2000", "부채", "liability", "header"},
        {"2100", "유동부채", "liability", "header"},
        {"2101", "매입채무", "liability", "detail"},
        {"2102", "미지급금", "liability", "detail"},
        {"2103", "미지급비용", "liability", "detail"},
        {"2104", "선수금", "liability", "detail"},
        {"2105", "예수금", "liability", "detail"},
        {"2106", "단기차입금", "liability", "detail"},
        {"2110", "부가세예수금", "liability", "detail"},
        {"2200", "비유동부채", "liability", "header"},
        {"2201", "장기차입금", "liability", "detail"},
        {"2202", "퇴직급여충당부채", "liability", "detail"},

        // Equity (자본)
        {"3000", "자본", "equity", "header"},
        {"3100", "자본금", "equity", "detail"},
        {"3200", "자본잉여금", "equity", "detail"},
        {"3300", "이익잉여금", "equity", "detail"},
        {"3301", "이익준비금", "equity", "detail"},
        {"3302", "미처분이익잉여금", "equity", "detail"},

        // Revenue (수익)
        {"4000", "수익", "revenue", "header"},
        {"4100", "매출액", "revenue", "detail"},
        {"4101", "상품매출", "revenue", "detail"},
        {"4102", "제품매출", "revenue", "detail"},
        {"4103", "서비스매출", "revenue", "detail"},
        {"4200", "영업외수익", "revenue", "detail"},
        {"4201", "이자수익", "revenue", "detail"},
        {"4202", "배당금수익", "revenue", "detail"},
        {"4203", "외환차익", "revenue", "detail"},
        {"4204", "유형자산처분이익", "revenue", "detail"},

        // Expenses (비용)
        {"5000", "비용", "expense", "header"},
        {"5100", "매출원가", "expense", "header"},
        {"5101", "상품매출원가", "expense", "detail"},
        {"5102", "제품매출원가", "expense", "detail"},
        {"5200", "판매비와관리비", "expense", "header"},
        {"5201", "급여", "expense", "detail"},
        {"5202", "퇴직급여", "expense", "detail"},
        {"5203", "복리후생비", "expense", "detail"},
        {"5204", "여비교통비", "expense", "detail"},
        {"5205", "접대비", "expense", "detail"},
        {"5206", "통신비", "expense", "detail"},
        {"5207", "수도광열비", "expense", "detail"},
        {"5208", "세금과공과", "expense", "detail"},
        {"5209", "감가상각비", "expense", "detail"},
        {"5210", "지급임차료", "expense", "detail"},
        {"5211", "보험료", "expense", "detail"},
        {"5212", "수선비", "expense", "detail"},
        {"5213", "차량유지비", "expense", "detail"},
        {"5214", "소모품비", "expense", "detail"},
        {"5215", "도서인쇄비", "expense", "detail"},
        {"5216", "광고선전비", "expense", "detail"},
        {"5217", "대손상각비", "expense", "detail"},
        {"5218", "지급수수료", "expense", "detail"},
        {"5219", "운반비", "expense", "detail"},
        {"5300", "영업외비용", "expense", "header"},
        {"5301", "이자비용", "expense", "detail"},
        {"5302", "외환차손", "expense", "detail"},
        {"5303", "유형자산처분손실", "expense", "detail"},
        {"5400", "법인세비용", "expense", "detail"},
    }

    stmt, err := tx.PrepareContext(ctx, `
        INSERT INTO accounts (id, company_id, code, name, account_type, category, is_system, created_at)
        VALUES ($1, $2, $3, $4, $5, $6, true, NOW())
    `)
    if err != nil {
        return err
    }
    defer stmt.Close()

    for _, acc := range accounts {
        _, err := stmt.ExecContext(ctx,
            uuid.New(),
            companyID,
            acc.Code,
            acc.Name,
            acc.AccountType,
            acc.Category,
        )
        if err != nil {
            return fmt.Errorf("failed to insert account %s: %w", acc.Code, err)
        }
    }

    return nil
}

// createDefaultDepartments creates a basic organizational structure
func (s *ProvisioningService) createDefaultDepartments(ctx context.Context, tx Transaction, companyID uuid.UUID) error {
    departments := []struct {
        Code string
        Name string
    }{
        {"10", "대표이사"},
        {"20", "경영관리부"},
        {"21", "인사팀"},
        {"22", "재무팀"},
        {"30", "영업부"},
        {"31", "영업1팀"},
        {"32", "영업2팀"},
        {"40", "생산부"},
        {"50", "연구개발부"},
    }

    for _, dept := range departments {
        _, err := tx.ExecContext(ctx, `
            INSERT INTO departments (id, company_id, code, name, is_active, created_at)
            VALUES ($1, $2, $3, $4, true, NOW())
        `, uuid.New(), companyID, dept.Code, dept.Name)
        if err != nil {
            return err
        }
    }

    return nil
}

// createDefaultFiscalYear creates the current fiscal year
func (s *ProvisioningService) createDefaultFiscalYear(ctx context.Context, tx Transaction, companyID uuid.UUID) error {
    now := time.Now()
    startDate := time.Date(now.Year(), 1, 1, 0, 0, 0, 0, time.Local)
    endDate := time.Date(now.Year(), 12, 31, 23, 59, 59, 0, time.Local)

    _, err := tx.ExecContext(ctx, `
        INSERT INTO fiscal_years (id, company_id, year, start_date, end_date, status, created_at)
        VALUES ($1, $2, $3, $4, $5, 'open', NOW())
    `, uuid.New(), companyID, now.Year(), startDate, endDate)

    return err
}

// createDefaultSequences creates document number sequences
func (s *ProvisioningService) createDefaultSequences(ctx context.Context, tx Transaction, companyID uuid.UUID) error {
    sequences := []struct {
        Type    string
        Prefix  string
        Digits  int
    }{
        {"voucher", "V", 6},
        {"invoice_sales", "SI", 8},
        {"invoice_purchase", "PI", 8},
        {"purchase_order", "PO", 6},
        {"sales_order", "SO", 6},
        {"payment", "PAY", 6},
        {"receipt", "REC", 6},
    }

    for _, seq := range sequences {
        _, err := tx.ExecContext(ctx, `
            INSERT INTO document_sequences (id, company_id, document_type, prefix, digit_count, current_number, created_at)
            VALUES ($1, $2, $3, $4, $5, 0, NOW())
        `, uuid.New(), companyID, seq.Type, seq.Prefix, seq.Digits)
        if err != nil {
            return err
        }
    }

    return nil
}

// createDefaultSettings creates default system settings
func (s *ProvisioningService) createDefaultSettings(ctx context.Context, tx Transaction, companyID uuid.UUID) error {
    settings := map[string]string{
        "timezone":              "Asia/Seoul",
        "date_format":           "YYYY-MM-DD",
        "currency":              "KRW",
        "decimal_places":        "0",
        "vat_rate":              "10",
        "auto_voucher_numbering": "true",
        "require_voucher_approval": "true",
        "allow_future_dates":    "false",
        "fiscal_year_start_month": "1",
    }

    for key, value := range settings {
        _, err := tx.ExecContext(ctx, `
            INSERT INTO company_settings (id, company_id, key, value, created_at)
            VALUES ($1, $2, $3, $4, NOW())
        `, uuid.New(), companyID, key, value)
        if err != nil {
            return err
        }
    }

    return nil
}
```

---

## 4. 초기 설정 마법사

### 4.1 설정 마법사 컴포넌트

```typescript
// web/src/features/onboarding/SetupWizard.tsx

import React, { useState, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { useMutation, useQuery } from '@tanstack/react-query';
import {
  Stepper,
  Step,
  StepLabel,
  StepContent,
  Button,
  Box,
  Typography,
  Alert,
  LinearProgress,
} from '@mui/material';
import { onboardingApi } from '@/api/onboarding';

// Step components
import { CompanyInfoStep } from './steps/CompanyInfoStep';
import { OrganizationStep } from './steps/OrganizationStep';
import { ChartOfAccountsStep } from './steps/ChartOfAccountsStep';
import { UsersSetupStep } from './steps/UsersSetupStep';
import { IntegrationSetupStep } from './steps/IntegrationSetupStep';
import { DataImportStep } from './steps/DataImportStep';
import { ReviewStep } from './steps/ReviewStep';

interface SetupWizardProps {
  companyId: string;
}

const SETUP_STEPS = [
  {
    key: 'company_info',
    label: '회사 정보',
    description: '기본 회사 정보를 설정합니다.',
    component: CompanyInfoStep,
  },
  {
    key: 'organization',
    label: '조직 구조',
    description: '부서 및 조직 구조를 설정합니다.',
    component: OrganizationStep,
  },
  {
    key: 'chart_of_accounts',
    label: '계정과목',
    description: '계정과목 체계를 설정합니다.',
    component: ChartOfAccountsStep,
  },
  {
    key: 'users',
    label: '사용자 설정',
    description: '사용자 및 권한을 설정합니다.',
    component: UsersSetupStep,
  },
  {
    key: 'integrations',
    label: '연동 설정',
    description: '외부 서비스 연동을 설정합니다.',
    component: IntegrationSetupStep,
  },
  {
    key: 'data_import',
    label: '데이터 가져오기',
    description: '기존 데이터를 가져옵니다.',
    component: DataImportStep,
    optional: true,
  },
  {
    key: 'review',
    label: '검토 및 완료',
    description: '설정 내용을 검토합니다.',
    component: ReviewStep,
  },
];

export const SetupWizard: React.FC<SetupWizardProps> = ({ companyId }) => {
  const navigate = useNavigate();
  const [activeStep, setActiveStep] = useState(0);
  const [stepData, setStepData] = useState<Record<string, any>>({});
  const [errors, setErrors] = useState<Record<string, string>>({});

  // Fetch current progress
  const { data: progress, isLoading } = useQuery({
    queryKey: ['onboarding-progress', companyId],
    queryFn: () => onboardingApi.getProgress(companyId),
  });

  // Complete step mutation
  const completeStepMutation = useMutation({
    mutationFn: (stepKey: string) =>
      onboardingApi.completeStep(companyId, stepKey, stepData[stepKey]),
    onSuccess: () => {
      handleNext();
    },
    onError: (error: any) => {
      setErrors((prev) => ({
        ...prev,
        [SETUP_STEPS[activeStep].key]: error.message,
      }));
    },
  });

  const handleNext = useCallback(() => {
    if (activeStep === SETUP_STEPS.length - 1) {
      // Complete wizard
      navigate('/dashboard');
    } else {
      setActiveStep((prev) => prev + 1);
    }
  }, [activeStep, navigate]);

  const handleBack = useCallback(() => {
    setActiveStep((prev) => prev - 1);
  }, []);

  const handleSkip = useCallback(() => {
    const currentStep = SETUP_STEPS[activeStep];
    if (currentStep.optional) {
      handleNext();
    }
  }, [activeStep, handleNext]);

  const handleStepDataChange = useCallback(
    (stepKey: string, data: any) => {
      setStepData((prev) => ({
        ...prev,
        [stepKey]: data,
      }));
      // Clear error when data changes
      setErrors((prev) => {
        const { [stepKey]: _, ...rest } = prev;
        return rest;
      });
    },
    []
  );

  const handleStepComplete = useCallback(
    (stepKey: string) => {
      completeStepMutation.mutate(stepKey);
    },
    [completeStepMutation]
  );

  if (isLoading) {
    return <LinearProgress />;
  }

  const completionPercentage = Math.round(
    ((activeStep + 1) / SETUP_STEPS.length) * 100
  );

  return (
    <Box sx={{ maxWidth: 900, mx: 'auto', p: 3 }}>
      <Typography variant="h4" gutterBottom>
        K-ERP 초기 설정
      </Typography>

      <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
        K-ERP를 사용하기 위한 기본 설정을 진행합니다.
        각 단계별로 필요한 정보를 입력해 주세요.
      </Typography>

      <Box sx={{ mb: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
          <Typography variant="body2">설정 진행률</Typography>
          <Typography variant="body2">{completionPercentage}%</Typography>
        </Box>
        <LinearProgress variant="determinate" value={completionPercentage} />
      </Box>

      <Stepper activeStep={activeStep} orientation="vertical">
        {SETUP_STEPS.map((step, index) => {
          const StepComponent = step.component;
          const isStepOptional = step.optional;
          const stepError = errors[step.key];

          return (
            <Step key={step.key}>
              <StepLabel
                optional={
                  isStepOptional ? (
                    <Typography variant="caption">선택사항</Typography>
                  ) : null
                }
                error={!!stepError}
              >
                {step.label}
              </StepLabel>
              <StepContent>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  {step.description}
                </Typography>

                {stepError && (
                  <Alert severity="error" sx={{ mb: 2 }}>
                    {stepError}
                  </Alert>
                )}

                <StepComponent
                  companyId={companyId}
                  data={stepData[step.key] || {}}
                  onChange={(data: any) => handleStepDataChange(step.key, data)}
                  onComplete={() => handleStepComplete(step.key)}
                />

                <Box sx={{ mt: 2 }}>
                  <Button
                    variant="contained"
                    onClick={() => handleStepComplete(step.key)}
                    disabled={completeStepMutation.isPending}
                    sx={{ mr: 1 }}
                  >
                    {index === SETUP_STEPS.length - 1 ? '완료' : '다음'}
                  </Button>
                  {index > 0 && (
                    <Button onClick={handleBack} sx={{ mr: 1 }}>
                      이전
                    </Button>
                  )}
                  {isStepOptional && (
                    <Button onClick={handleSkip}>건너뛰기</Button>
                  )}
                </Box>
              </StepContent>
            </Step>
          );
        })}
      </Stepper>
    </Box>
  );
};
```

### 4.2 회사 정보 설정 단계

```typescript
// web/src/features/onboarding/steps/CompanyInfoStep.tsx

import React from 'react';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import {
  Grid,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormHelperText,
} from '@mui/material';
import { BusinessNumberInput } from '@/components/inputs/BusinessNumberInput';

const companyInfoSchema = z.object({
  name: z.string().min(2, '회사명은 2자 이상이어야 합니다.'),
  businessNumber: z
    .string()
    .regex(/^\d{3}-\d{2}-\d{5}$/, '올바른 사업자등록번호 형식이 아닙니다.'),
  representativeName: z.string().min(2, '대표자명을 입력해 주세요.'),
  businessType: z.string().min(1, '업종을 선택해 주세요.'),
  businessCategory: z.string().min(1, '업태를 입력해 주세요.'),
  address: z.string().min(5, '주소를 입력해 주세요.'),
  phone: z
    .string()
    .regex(/^(\d{2,3})-(\d{3,4})-(\d{4})$/, '올바른 전화번호 형식이 아닙니다.'),
  email: z.string().email('올바른 이메일 형식이 아닙니다.'),
  fiscalYearStartMonth: z.number().min(1).max(12),
});

type CompanyInfoFormData = z.infer<typeof companyInfoSchema>;

interface CompanyInfoStepProps {
  companyId: string;
  data: Partial<CompanyInfoFormData>;
  onChange: (data: CompanyInfoFormData) => void;
  onComplete: () => void;
}

const BUSINESS_TYPES = [
  '제조업',
  '도소매업',
  '서비스업',
  '건설업',
  '운수업',
  '정보통신업',
  '금융업',
  '부동산업',
  '전문서비스업',
  '기타',
];

export const CompanyInfoStep: React.FC<CompanyInfoStepProps> = ({
  companyId,
  data,
  onChange,
  onComplete,
}) => {
  const {
    control,
    handleSubmit,
    formState: { errors },
    watch,
  } = useForm<CompanyInfoFormData>({
    resolver: zodResolver(companyInfoSchema),
    defaultValues: {
      name: '',
      businessNumber: '',
      representativeName: '',
      businessType: '',
      businessCategory: '',
      address: '',
      phone: '',
      email: '',
      fiscalYearStartMonth: 1,
      ...data,
    },
  });

  // Watch form values and propagate changes
  React.useEffect(() => {
    const subscription = watch((value) => {
      onChange(value as CompanyInfoFormData);
    });
    return () => subscription.unsubscribe();
  }, [watch, onChange]);

  return (
    <Grid container spacing={2}>
      <Grid item xs={12} md={6}>
        <Controller
          name="name"
          control={control}
          render={({ field }) => (
            <TextField
              {...field}
              label="회사명"
              fullWidth
              required
              error={!!errors.name}
              helperText={errors.name?.message}
            />
          )}
        />
      </Grid>

      <Grid item xs={12} md={6}>
        <Controller
          name="businessNumber"
          control={control}
          render={({ field }) => (
            <BusinessNumberInput
              {...field}
              label="사업자등록번호"
              fullWidth
              required
              error={!!errors.businessNumber}
              helperText={errors.businessNumber?.message}
            />
          )}
        />
      </Grid>

      <Grid item xs={12} md={6}>
        <Controller
          name="representativeName"
          control={control}
          render={({ field }) => (
            <TextField
              {...field}
              label="대표자명"
              fullWidth
              required
              error={!!errors.representativeName}
              helperText={errors.representativeName?.message}
            />
          )}
        />
      </Grid>

      <Grid item xs={12} md={6}>
        <Controller
          name="businessType"
          control={control}
          render={({ field }) => (
            <FormControl fullWidth required error={!!errors.businessType}>
              <InputLabel>업종</InputLabel>
              <Select {...field} label="업종">
                {BUSINESS_TYPES.map((type) => (
                  <MenuItem key={type} value={type}>
                    {type}
                  </MenuItem>
                ))}
              </Select>
              {errors.businessType && (
                <FormHelperText>{errors.businessType.message}</FormHelperText>
              )}
            </FormControl>
          )}
        />
      </Grid>

      <Grid item xs={12} md={6}>
        <Controller
          name="businessCategory"
          control={control}
          render={({ field }) => (
            <TextField
              {...field}
              label="업태"
              fullWidth
              required
              error={!!errors.businessCategory}
              helperText={errors.businessCategory?.message}
              placeholder="예: 소프트웨어 개발"
            />
          )}
        />
      </Grid>

      <Grid item xs={12} md={6}>
        <Controller
          name="fiscalYearStartMonth"
          control={control}
          render={({ field }) => (
            <FormControl fullWidth required>
              <InputLabel>회계연도 시작월</InputLabel>
              <Select
                {...field}
                label="회계연도 시작월"
                onChange={(e) => field.onChange(Number(e.target.value))}
              >
                {Array.from({ length: 12 }, (_, i) => i + 1).map((month) => (
                  <MenuItem key={month} value={month}>
                    {month}월
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          )}
        />
      </Grid>

      <Grid item xs={12}>
        <Controller
          name="address"
          control={control}
          render={({ field }) => (
            <TextField
              {...field}
              label="주소"
              fullWidth
              required
              multiline
              rows={2}
              error={!!errors.address}
              helperText={errors.address?.message}
            />
          )}
        />
      </Grid>

      <Grid item xs={12} md={6}>
        <Controller
          name="phone"
          control={control}
          render={({ field }) => (
            <TextField
              {...field}
              label="대표전화"
              fullWidth
              required
              placeholder="02-1234-5678"
              error={!!errors.phone}
              helperText={errors.phone?.message}
            />
          )}
        />
      </Grid>

      <Grid item xs={12} md={6}>
        <Controller
          name="email"
          control={control}
          render={({ field }) => (
            <TextField
              {...field}
              label="대표이메일"
              type="email"
              fullWidth
              required
              error={!!errors.email}
              helperText={errors.email?.message}
            />
          )}
        />
      </Grid>
    </Grid>
  );
};
```

---

## 5. 데이터 임포트

### 5.1 임포트 서비스

```go
// internal/service/import_service.go

package service

import (
    "context"
    "encoding/csv"
    "fmt"
    "io"
    "strconv"
    "strings"
    "time"

    "github.com/google/uuid"
    "github.com/xuri/excelize/v2"
    "kerp/internal/domain"
    "kerp/pkg/logger"
)

type ImportService struct {
    accountRepo    AccountRepository
    partnerRepo    PartnerRepository
    employeeRepo   EmployeeRepository
    voucherRepo    VoucherRepository
    eventPublisher EventPublisher
    logger         *logger.Logger
}

// ImportType defines the type of data being imported
type ImportType string

const (
    ImportTypeAccounts   ImportType = "accounts"
    ImportTypePartners   ImportType = "partners"
    ImportTypeEmployees  ImportType = "employees"
    ImportTypeOpeningBalances ImportType = "opening_balances"
    ImportTypeVouchers   ImportType = "vouchers"
)

// ImportJob represents an import job
type ImportJob struct {
    ID          uuid.UUID     `json:"id"`
    CompanyID   uuid.UUID     `json:"company_id"`
    Type        ImportType    `json:"type"`
    FileName    string        `json:"file_name"`
    Status      string        `json:"status"` // pending, processing, completed, failed
    TotalRows   int           `json:"total_rows"`
    ProcessedRows int         `json:"processed_rows"`
    SuccessRows int           `json:"success_rows"`
    FailedRows  int           `json:"failed_rows"`
    Errors      []ImportError `json:"errors,omitempty"`
    StartedAt   *time.Time    `json:"started_at,omitempty"`
    CompletedAt *time.Time    `json:"completed_at,omitempty"`
    CreatedAt   time.Time     `json:"created_at"`
}

type ImportError struct {
    Row     int    `json:"row"`
    Column  string `json:"column,omitempty"`
    Message string `json:"message"`
}

// ImportPartnersFromExcel imports partners from an Excel file
func (s *ImportService) ImportPartnersFromExcel(ctx context.Context, companyID uuid.UUID, reader io.Reader, fileName string) (*ImportJob, error) {
    job := &ImportJob{
        ID:        uuid.New(),
        CompanyID: companyID,
        Type:      ImportTypePartners,
        FileName:  fileName,
        Status:    "processing",
        CreatedAt: time.Now(),
    }

    now := time.Now()
    job.StartedAt = &now

    // Open Excel file
    f, err := excelize.OpenReader(reader)
    if err != nil {
        return nil, fmt.Errorf("failed to open Excel file: %w", err)
    }
    defer f.Close()

    // Get the first sheet
    sheetName := f.GetSheetName(0)
    rows, err := f.GetRows(sheetName)
    if err != nil {
        return nil, fmt.Errorf("failed to read rows: %w", err)
    }

    if len(rows) < 2 {
        return nil, fmt.Errorf("file must have at least a header row and one data row")
    }

    // Parse header
    header := rows[0]
    columnMap := s.mapColumns(header, partnerColumnMappings)

    job.TotalRows = len(rows) - 1 // Exclude header

    // Process rows
    for i, row := range rows[1:] {
        rowNum := i + 2 // 1-indexed, skip header

        partner, err := s.parsePartnerRow(row, columnMap)
        if err != nil {
            job.Errors = append(job.Errors, ImportError{
                Row:     rowNum,
                Message: err.Error(),
            })
            job.FailedRows++
            continue
        }

        partner.ID = uuid.New()
        partner.CompanyID = companyID

        // Validate
        if err := s.validatePartner(ctx, partner); err != nil {
            job.Errors = append(job.Errors, ImportError{
                Row:     rowNum,
                Message: fmt.Sprintf("validation failed: %s", err.Error()),
            })
            job.FailedRows++
            continue
        }

        // Save
        if err := s.partnerRepo.Create(ctx, partner); err != nil {
            job.Errors = append(job.Errors, ImportError{
                Row:     rowNum,
                Message: fmt.Sprintf("save failed: %s", err.Error()),
            })
            job.FailedRows++
            continue
        }

        job.SuccessRows++
        job.ProcessedRows++
    }

    completedAt := time.Now()
    job.CompletedAt = &completedAt

    if job.FailedRows > 0 {
        job.Status = "completed_with_errors"
    } else {
        job.Status = "completed"
    }

    return job, nil
}

var partnerColumnMappings = map[string][]string{
    "code":            {"거래처코드", "코드", "Code", "Partner Code"},
    "name":            {"거래처명", "상호", "Name", "Partner Name"},
    "business_number": {"사업자번호", "사업자등록번호", "Business Number"},
    "representative":  {"대표자", "대표자명", "Representative"},
    "business_type":   {"업종", "Business Type"},
    "business_category": {"업태", "Business Category"},
    "address":         {"주소", "Address"},
    "phone":           {"전화번호", "전화", "Phone"},
    "email":           {"이메일", "Email"},
    "contact_person":  {"담당자", "Contact Person"},
    "partner_type":    {"거래처유형", "유형", "Type"},
}

func (s *ImportService) mapColumns(header []string, mappings map[string][]string) map[string]int {
    result := make(map[string]int)

    for i, col := range header {
        col = strings.TrimSpace(col)
        for field, aliases := range mappings {
            for _, alias := range aliases {
                if strings.EqualFold(col, alias) {
                    result[field] = i
                    break
                }
            }
        }
    }

    return result
}

func (s *ImportService) parsePartnerRow(row []string, columnMap map[string]int) (*domain.Partner, error) {
    partner := &domain.Partner{
        IsActive:  true,
        CreatedAt: time.Now(),
    }

    getValue := func(field string) string {
        if idx, ok := columnMap[field]; ok && idx < len(row) {
            return strings.TrimSpace(row[idx])
        }
        return ""
    }

    // Required fields
    partner.Code = getValue("code")
    if partner.Code == "" {
        return nil, fmt.Errorf("partner code is required")
    }

    partner.Name = getValue("name")
    if partner.Name == "" {
        return nil, fmt.Errorf("partner name is required")
    }

    // Optional fields
    partner.BusinessNumber = getValue("business_number")
    partner.RepresentativeName = getValue("representative")
    partner.BusinessType = getValue("business_type")
    partner.BusinessCategory = getValue("business_category")
    partner.Address = getValue("address")
    partner.Phone = getValue("phone")
    partner.Email = getValue("email")
    partner.ContactPerson = getValue("contact_person")

    // Parse partner type
    partnerType := getValue("partner_type")
    switch strings.ToLower(partnerType) {
    case "매출처", "customer", "매출":
        partner.PartnerType = domain.PartnerTypeCustomer
    case "매입처", "supplier", "매입", "vendor":
        partner.PartnerType = domain.PartnerTypeSupplier
    case "혼합", "both":
        partner.PartnerType = domain.PartnerTypeBoth
    default:
        partner.PartnerType = domain.PartnerTypeBoth
    }

    return partner, nil
}

func (s *ImportService) validatePartner(ctx context.Context, partner *domain.Partner) error {
    // Check for duplicate code
    existing, err := s.partnerRepo.FindByCode(ctx, partner.CompanyID, partner.Code)
    if err == nil && existing != nil {
        return fmt.Errorf("partner code '%s' already exists", partner.Code)
    }

    // Validate business number format if provided
    if partner.BusinessNumber != "" {
        if !isValidBusinessNumber(partner.BusinessNumber) {
            return fmt.Errorf("invalid business number format")
        }
    }

    return nil
}

func isValidBusinessNumber(bn string) bool {
    // Remove hyphens
    bn = strings.ReplaceAll(bn, "-", "")

    if len(bn) != 10 {
        return false
    }

    // All characters must be digits
    for _, c := range bn {
        if c < '0' || c > '9' {
            return false
        }
    }

    // Validate checksum
    weights := []int{1, 3, 7, 1, 3, 7, 1, 3, 5}
    sum := 0

    for i := 0; i < 9; i++ {
        digit, _ := strconv.Atoi(string(bn[i]))
        sum += digit * weights[i]
    }

    // Add the special calculation for the 9th digit
    digit9, _ := strconv.Atoi(string(bn[8]))
    sum += (digit9 * 5) / 10

    lastDigit, _ := strconv.Atoi(string(bn[9]))
    checkDigit := (10 - (sum % 10)) % 10

    return lastDigit == checkDigit
}

// ImportOpeningBalances imports opening balances
func (s *ImportService) ImportOpeningBalances(ctx context.Context, companyID uuid.UUID, reader io.Reader, fiscalYear int) (*ImportJob, error) {
    job := &ImportJob{
        ID:        uuid.New(),
        CompanyID: companyID,
        Type:      ImportTypeOpeningBalances,
        Status:    "processing",
        CreatedAt: time.Now(),
    }

    now := time.Now()
    job.StartedAt = &now

    // Parse CSV
    csvReader := csv.NewReader(reader)
    records, err := csvReader.ReadAll()
    if err != nil {
        return nil, fmt.Errorf("failed to read CSV: %w", err)
    }

    if len(records) < 2 {
        return nil, fmt.Errorf("file must have at least a header row and one data row")
    }

    job.TotalRows = len(records) - 1

    // Create opening balance voucher
    voucher := &domain.Voucher{
        ID:          uuid.New(),
        CompanyID:   companyID,
        VoucherDate: time.Date(fiscalYear, 1, 1, 0, 0, 0, 0, time.Local),
        VoucherType: domain.VoucherTypeOpening,
        Description: fmt.Sprintf("%d년 기초잔액", fiscalYear),
        Status:      domain.VoucherStatusDraft,
        CreatedAt:   time.Now(),
    }

    var lines []domain.VoucherLine
    var totalDebit, totalCredit int64

    for i, record := range records[1:] {
        rowNum := i + 2

        if len(record) < 3 {
            job.Errors = append(job.Errors, ImportError{
                Row:     rowNum,
                Message: "insufficient columns (need: account_code, debit, credit)",
            })
            job.FailedRows++
            continue
        }

        accountCode := strings.TrimSpace(record[0])
        debitStr := strings.TrimSpace(record[1])
        creditStr := strings.TrimSpace(record[2])

        // Find account
        account, err := s.accountRepo.FindByCode(ctx, companyID, accountCode)
        if err != nil {
            job.Errors = append(job.Errors, ImportError{
                Row:     rowNum,
                Column:  "account_code",
                Message: fmt.Sprintf("account '%s' not found", accountCode),
            })
            job.FailedRows++
            continue
        }

        // Parse amounts
        var debit, credit int64
        if debitStr != "" && debitStr != "0" {
            debit, err = parseAmount(debitStr)
            if err != nil {
                job.Errors = append(job.Errors, ImportError{
                    Row:     rowNum,
                    Column:  "debit",
                    Message: fmt.Sprintf("invalid debit amount: %s", err.Error()),
                })
                job.FailedRows++
                continue
            }
        }

        if creditStr != "" && creditStr != "0" {
            credit, err = parseAmount(creditStr)
            if err != nil {
                job.Errors = append(job.Errors, ImportError{
                    Row:     rowNum,
                    Column:  "credit",
                    Message: fmt.Sprintf("invalid credit amount: %s", err.Error()),
                })
                job.FailedRows++
                continue
            }
        }

        if debit == 0 && credit == 0 {
            // Skip zero-balance rows
            job.ProcessedRows++
            continue
        }

        line := domain.VoucherLine{
            ID:          uuid.New(),
            VoucherID:   voucher.ID,
            AccountID:   account.ID,
            AccountCode: account.Code,
            AccountName: account.Name,
            DebitAmount: debit,
            CreditAmount: credit,
            LineNumber:  len(lines) + 1,
        }

        lines = append(lines, line)
        totalDebit += debit
        totalCredit += credit

        job.SuccessRows++
        job.ProcessedRows++
    }

    // Validate balance
    if totalDebit != totalCredit {
        return nil, fmt.Errorf("opening balance is unbalanced: debit=%d, credit=%d", totalDebit, totalCredit)
    }

    voucher.TotalDebit = totalDebit
    voucher.TotalCredit = totalCredit
    voucher.Lines = lines

    // Save voucher
    if err := s.voucherRepo.Create(ctx, voucher); err != nil {
        return nil, fmt.Errorf("failed to save opening balance voucher: %w", err)
    }

    completedAt := time.Now()
    job.CompletedAt = &completedAt
    job.Status = "completed"

    if job.FailedRows > 0 {
        job.Status = "completed_with_errors"
    }

    return job, nil
}

func parseAmount(s string) (int64, error) {
    // Remove commas and whitespace
    s = strings.ReplaceAll(s, ",", "")
    s = strings.TrimSpace(s)

    // Handle negative numbers in parentheses
    if strings.HasPrefix(s, "(") && strings.HasSuffix(s, ")") {
        s = "-" + s[1:len(s)-1]
    }

    // Parse as float first to handle decimal places
    f, err := strconv.ParseFloat(s, 64)
    if err != nil {
        return 0, err
    }

    // Convert to integer (assuming no decimal places for KRW)
    return int64(f), nil
}
```

### 5.2 임포트 템플릿 다운로드

```go
// internal/handler/import_handler.go

package handler

import (
    "bytes"
    "net/http"

    "github.com/gin-gonic/gin"
    "github.com/xuri/excelize/v2"
)

type ImportHandler struct {
    importService *service.ImportService
}

// DownloadTemplate returns an import template file
func (h *ImportHandler) DownloadTemplate(c *gin.Context) {
    templateType := c.Param("type")

    var fileName string
    var content []byte
    var err error

    switch templateType {
    case "partners":
        fileName = "거래처_임포트_템플릿.xlsx"
        content, err = h.createPartnerTemplate()
    case "accounts":
        fileName = "계정과목_임포트_템플릿.xlsx"
        content, err = h.createAccountTemplate()
    case "employees":
        fileName = "직원_임포트_템플릿.xlsx"
        content, err = h.createEmployeeTemplate()
    case "opening_balances":
        fileName = "기초잔액_임포트_템플릿.xlsx"
        content, err = h.createOpeningBalanceTemplate()
    default:
        c.JSON(http.StatusBadRequest, gin.H{"error": "unknown template type"})
        return
    }

    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.Header("Content-Description", "File Transfer")
    c.Header("Content-Disposition", "attachment; filename="+fileName)
    c.Header("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    c.Data(http.StatusOK, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", content)
}

func (h *ImportHandler) createPartnerTemplate() ([]byte, error) {
    f := excelize.NewFile()
    defer f.Close()

    sheetName := "거래처목록"
    f.SetSheetName("Sheet1", sheetName)

    // Headers
    headers := []string{
        "거래처코드*", "거래처명*", "사업자등록번호", "대표자명",
        "업종", "업태", "주소", "전화번호", "이메일",
        "담당자", "거래처유형(매출처/매입처/혼합)",
    }

    for i, header := range headers {
        cell, _ := excelize.CoordinatesToCellName(i+1, 1)
        f.SetCellValue(sheetName, cell, header)
    }

    // Sample data
    sampleData := [][]interface{}{
        {"P001", "(주)샘플거래처", "123-45-67890", "홍길동", "제조업", "전자제품", "서울시 강남구", "02-1234-5678", "sample@example.com", "김담당", "매출처"},
        {"P002", "(주)테스트상사", "234-56-78901", "김철수", "도소매업", "사무용품", "서울시 서초구", "02-2345-6789", "test@example.com", "이담당", "매입처"},
    }

    for i, row := range sampleData {
        for j, value := range row {
            cell, _ := excelize.CoordinatesToCellName(j+1, i+2)
            f.SetCellValue(sheetName, cell, value)
        }
    }

    // Style header
    headerStyle, _ := f.NewStyle(&excelize.Style{
        Fill: excelize.Fill{Type: "pattern", Color: []string{"#4472C4"}, Pattern: 1},
        Font: &excelize.Font{Bold: true, Color: "#FFFFFF"},
        Border: []excelize.Border{
            {Type: "bottom", Color: "#000000", Style: 1},
        },
    })
    f.SetRowStyle(sheetName, 1, 1, headerStyle)

    // Set column widths
    widths := []float64{15, 25, 18, 12, 12, 15, 40, 15, 25, 12, 20}
    for i, w := range widths {
        col, _ := excelize.ColumnNumberToName(i + 1)
        f.SetColWidth(sheetName, col, col, w)
    }

    // Add instructions sheet
    f.NewSheet("안내사항")
    instructions := []string{
        "거래처 임포트 안내사항",
        "",
        "1. * 표시된 항목은 필수 입력 항목입니다.",
        "2. 거래처코드는 중복될 수 없습니다.",
        "3. 사업자등록번호는 하이픈(-)을 포함하여 입력합니다. (예: 123-45-67890)",
        "4. 거래처유형은 '매출처', '매입처', '혼합' 중 하나를 입력합니다.",
        "5. 샘플 데이터 행은 삭제 후 실제 데이터를 입력하세요.",
    }

    for i, instruction := range instructions {
        cell, _ := excelize.CoordinatesToCellName(1, i+1)
        f.SetCellValue("안내사항", cell, instruction)
    }

    var buf bytes.Buffer
    if err := f.Write(&buf); err != nil {
        return nil, err
    }

    return buf.Bytes(), nil
}

func (h *ImportHandler) createOpeningBalanceTemplate() ([]byte, error) {
    f := excelize.NewFile()
    defer f.Close()

    sheetName := "기초잔액"
    f.SetSheetName("Sheet1", sheetName)

    // Headers
    headers := []string{"계정과목코드*", "차변금액", "대변금액", "비고"}

    for i, header := range headers {
        cell, _ := excelize.CoordinatesToCellName(i+1, 1)
        f.SetCellValue(sheetName, cell, header)
    }

    // Sample data with common opening balance items
    sampleData := [][]interface{}{
        {"1101", "50,000,000", "", "현금"},
        {"1102", "100,000,000", "", "보통예금"},
        {"1110", "30,000,000", "", "매출채권"},
        {"1150", "20,000,000", "", "재고자산"},
        {"1211", "200,000,000", "", "토지"},
        {"1212", "150,000,000", "", "건물"},
        {"2101", "", "25,000,000", "매입채무"},
        {"2106", "", "100,000,000", "단기차입금"},
        {"2201", "", "200,000,000", "장기차입금"},
        {"3100", "", "200,000,000", "자본금"},
        {"3302", "", "25,000,000", "이익잉여금"},
    }

    for i, row := range sampleData {
        for j, value := range row {
            cell, _ := excelize.CoordinatesToCellName(j+1, i+2)
            f.SetCellValue(sheetName, cell, value)
        }
    }

    // Style and widths
    headerStyle, _ := f.NewStyle(&excelize.Style{
        Fill: excelize.Fill{Type: "pattern", Color: []string{"#4472C4"}, Pattern: 1},
        Font: &excelize.Font{Bold: true, Color: "#FFFFFF"},
    })
    f.SetRowStyle(sheetName, 1, 1, headerStyle)

    widths := []float64{18, 18, 18, 30}
    for i, w := range widths {
        col, _ := excelize.ColumnNumberToName(i + 1)
        f.SetColWidth(sheetName, col, col, w)
    }

    var buf bytes.Buffer
    if err := f.Write(&buf); err != nil {
        return nil, err
    }

    return buf.Bytes(), nil
}
```

---

## 6. 사용자 교육

### 6.1 교육 과정 구성

| 과정 | 대상 | 시간 | 내용 |
|------|------|------|------|
| 관리자 기본 | 시스템 관리자 | 4시간 | 시스템 설정, 사용자 관리, 권한 설정 |
| 회계 기본 | 회계 담당자 | 8시간 | 전표 입력, 세금계산서, 결산 |
| 인사급여 기본 | HR 담당자 | 6시간 | 직원 관리, 급여 계산, 4대보험 |
| 영업 기본 | 영업 담당자 | 4시간 | 견적, 수주, 매출관리 |
| 구매 기본 | 구매 담당자 | 4시간 | 발주, 입고, 매입관리 |

### 6.2 교육 자료 관리

```typescript
// web/src/features/training/TrainingCenter.tsx

import React from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Grid,
  Chip,
  LinearProgress,
  Button,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
} from '@mui/material';
import {
  PlayCircle,
  Description,
  Quiz,
  CheckCircle,
  Lock,
} from '@mui/icons-material';

interface TrainingModule {
  id: string;
  title: string;
  description: string;
  duration: string;
  lessons: TrainingLesson[];
  progress: number;
  isLocked: boolean;
}

interface TrainingLesson {
  id: string;
  title: string;
  type: 'video' | 'document' | 'quiz';
  duration: string;
  completed: boolean;
}

const TRAINING_MODULES: TrainingModule[] = [
  {
    id: 'getting-started',
    title: '시작하기',
    description: 'K-ERP 기본 사용법을 배웁니다.',
    duration: '30분',
    progress: 100,
    isLocked: false,
    lessons: [
      { id: '1', title: '로그인 및 대시보드', type: 'video', duration: '5분', completed: true },
      { id: '2', title: '메뉴 구조 이해하기', type: 'video', duration: '10분', completed: true },
      { id: '3', title: '기본 조작법', type: 'document', duration: '10분', completed: true },
      { id: '4', title: '시작하기 퀴즈', type: 'quiz', duration: '5분', completed: true },
    ],
  },
  {
    id: 'accounting-basics',
    title: '회계 기초',
    description: '전표 입력과 장부 조회 방법을 배웁니다.',
    duration: '2시간',
    progress: 60,
    isLocked: false,
    lessons: [
      { id: '1', title: '복식부기 기초', type: 'video', duration: '15분', completed: true },
      { id: '2', title: '계정과목 이해', type: 'document', duration: '20분', completed: true },
      { id: '3', title: '전표 입력하기', type: 'video', duration: '25분', completed: true },
      { id: '4', title: '전표 실습', type: 'quiz', duration: '15분', completed: false },
      { id: '5', title: '장부 조회', type: 'video', duration: '20분', completed: false },
      { id: '6', title: '회계 기초 테스트', type: 'quiz', duration: '25분', completed: false },
    ],
  },
  {
    id: 'tax-invoice',
    title: '세금계산서 관리',
    description: '세금계산서 발행 및 관리 방법을 배웁니다.',
    duration: '1시간 30분',
    progress: 0,
    isLocked: false,
    lessons: [
      { id: '1', title: '세금계산서 기초', type: 'video', duration: '15분', completed: false },
      { id: '2', title: '매출 세금계산서 발행', type: 'video', duration: '20분', completed: false },
      { id: '3', title: '매입 세금계산서 수집', type: 'video', duration: '15분', completed: false },
      { id: '4', title: '전자세금계산서 연동', type: 'document', duration: '25분', completed: false },
      { id: '5', title: '세금계산서 실습', type: 'quiz', duration: '15분', completed: false },
    ],
  },
  {
    id: 'payroll',
    title: '급여 관리',
    description: '급여 계산 및 4대보험 처리 방법을 배웁니다.',
    duration: '2시간',
    progress: 0,
    isLocked: true,
    lessons: [],
  },
];

export const TrainingCenter: React.FC = () => {
  const getLessonIcon = (type: string, completed: boolean) => {
    if (completed) return <CheckCircle color="success" />;
    switch (type) {
      case 'video':
        return <PlayCircle />;
      case 'document':
        return <Description />;
      case 'quiz':
        return <Quiz />;
      default:
        return <Description />;
    }
  };

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        교육 센터
      </Typography>
      <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
        K-ERP를 효과적으로 사용하기 위한 교육 과정입니다.
      </Typography>

      <Grid container spacing={3}>
        {TRAINING_MODULES.map((module) => (
          <Grid item xs={12} md={6} key={module.id}>
            <Card
              sx={{
                height: '100%',
                opacity: module.isLocked ? 0.7 : 1,
              }}
            >
              <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                  <Typography variant="h6">
                    {module.isLocked && <Lock fontSize="small" sx={{ mr: 1, verticalAlign: 'middle' }} />}
                    {module.title}
                  </Typography>
                  <Chip label={module.duration} size="small" />
                </Box>

                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  {module.description}
                </Typography>

                <Box sx={{ mb: 2 }}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 0.5 }}>
                    <Typography variant="caption">진행률</Typography>
                    <Typography variant="caption">{module.progress}%</Typography>
                  </Box>
                  <LinearProgress
                    variant="determinate"
                    value={module.progress}
                    sx={{ height: 8, borderRadius: 4 }}
                  />
                </Box>

                {!module.isLocked && module.lessons.length > 0 && (
                  <List dense disablePadding>
                    {module.lessons.slice(0, 3).map((lesson) => (
                      <ListItem key={lesson.id} disableGutters>
                        <ListItemIcon sx={{ minWidth: 36 }}>
                          {getLessonIcon(lesson.type, lesson.completed)}
                        </ListItemIcon>
                        <ListItemText
                          primary={lesson.title}
                          secondary={lesson.duration}
                          primaryTypographyProps={{
                            variant: 'body2',
                            sx: {
                              textDecoration: lesson.completed ? 'line-through' : 'none',
                              color: lesson.completed ? 'text.secondary' : 'text.primary',
                            },
                          }}
                        />
                      </ListItem>
                    ))}
                    {module.lessons.length > 3 && (
                      <Typography variant="caption" color="text.secondary">
                        +{module.lessons.length - 3}개 더보기
                      </Typography>
                    )}
                  </List>
                )}

                <Box sx={{ mt: 2 }}>
                  <Button
                    variant={module.progress > 0 ? 'contained' : 'outlined'}
                    fullWidth
                    disabled={module.isLocked}
                  >
                    {module.progress === 0 && '시작하기'}
                    {module.progress > 0 && module.progress < 100 && '이어서 학습'}
                    {module.progress === 100 && '복습하기'}
                  </Button>
                </Box>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};
```

---

## 7. 정부기관 연동 설정

### 7.1 Popbill 연동 설정 가이드

```typescript
// web/src/features/onboarding/steps/IntegrationSetupStep.tsx

import React, { useState } from 'react';
import {
  Box,
  Typography,
  Stepper,
  Step,
  StepLabel,
  StepContent,
  TextField,
  Button,
  Alert,
  Link,
  Card,
  CardContent,
} from '@mui/material';
import { useMutation } from '@tanstack/react-query';
import { integrationApi } from '@/api/integration';

interface IntegrationSetupStepProps {
  companyId: string;
  data: any;
  onChange: (data: any) => void;
  onComplete: () => void;
}

const POPBILL_SETUP_STEPS = [
  {
    label: '팝빌 회원 가입',
    description: '팝빌 사이트에서 회원 가입을 진행합니다.',
  },
  {
    label: 'API 연동 신청',
    description: '개발자센터에서 API 연동을 신청합니다.',
  },
  {
    label: '인증 정보 입력',
    description: '발급받은 인증 정보를 입력합니다.',
  },
  {
    label: '연동 테스트',
    description: '연동이 정상적으로 되는지 확인합니다.',
  },
];

export const IntegrationSetupStep: React.FC<IntegrationSetupStepProps> = ({
  companyId,
  data,
  onChange,
  onComplete,
}) => {
  const [activeStep, setActiveStep] = useState(0);
  const [credentials, setCredentials] = useState({
    linkId: data.popbill?.linkId || '',
    secretKey: data.popbill?.secretKey || '',
    corporateNumber: data.popbill?.corporateNumber || '',
  });
  const [testResult, setTestResult] = useState<'success' | 'error' | null>(null);

  const testConnectionMutation = useMutation({
    mutationFn: () => integrationApi.testPopbillConnection(companyId, credentials),
    onSuccess: () => {
      setTestResult('success');
      setActiveStep(4);
    },
    onError: () => {
      setTestResult('error');
    },
  });

  const handleCredentialChange = (field: string, value: string) => {
    const newCredentials = { ...credentials, [field]: value };
    setCredentials(newCredentials);
    onChange({ ...data, popbill: newCredentials });
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        세금계산서 연동 설정 (팝빌)
      </Typography>

      <Alert severity="info" sx={{ mb: 3 }}>
        세금계산서 발행을 위해 팝빌 연동이 필요합니다.
        이미 팝빌 계정이 있다면 3단계부터 진행하세요.
      </Alert>

      <Stepper activeStep={activeStep} orientation="vertical">
        {/* Step 1: Sign up */}
        <Step>
          <StepLabel>{POPBILL_SETUP_STEPS[0].label}</StepLabel>
          <StepContent>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
              {POPBILL_SETUP_STEPS[0].description}
            </Typography>
            <Card variant="outlined" sx={{ mb: 2 }}>
              <CardContent>
                <Typography variant="subtitle2" gutterBottom>
                  팝빌 가입 안내
                </Typography>
                <ol style={{ paddingLeft: 20, margin: 0 }}>
                  <li>
                    <Link href="https://www.popbill.com" target="_blank" rel="noopener">
                      팝빌 홈페이지
                    </Link>
                    에 접속합니다.
                  </li>
                  <li>회원가입 버튼을 클릭합니다.</li>
                  <li>사업자 정보를 입력하고 가입을 완료합니다.</li>
                  <li>인증서 등록을 진행합니다 (전자세금계산서 발행용).</li>
                </ol>
              </CardContent>
            </Card>
            <Button variant="contained" onClick={() => setActiveStep(1)}>
              다음
            </Button>
            <Button onClick={() => setActiveStep(2)} sx={{ ml: 1 }}>
              이미 가입함
            </Button>
          </StepContent>
        </Step>

        {/* Step 2: API Application */}
        <Step>
          <StepLabel>{POPBILL_SETUP_STEPS[1].label}</StepLabel>
          <StepContent>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
              {POPBILL_SETUP_STEPS[1].description}
            </Typography>
            <Card variant="outlined" sx={{ mb: 2 }}>
              <CardContent>
                <Typography variant="subtitle2" gutterBottom>
                  API 연동 신청 방법
                </Typography>
                <ol style={{ paddingLeft: 20, margin: 0 }}>
                  <li>
                    <Link href="https://developers.popbill.com" target="_blank" rel="noopener">
                      팝빌 개발자센터
                    </Link>
                    에 로그인합니다.
                  </li>
                  <li>[연동신청] 메뉴에서 세금계산서 API를 신청합니다.</li>
                  <li>심사 완료 후 LinkID와 SecretKey를 발급받습니다.</li>
                  <li>발급받은 정보를 안전하게 보관합니다.</li>
                </ol>
              </CardContent>
            </Card>
            <Button variant="contained" onClick={() => setActiveStep(2)}>
              다음
            </Button>
            <Button onClick={() => setActiveStep(0)} sx={{ ml: 1 }}>
              이전
            </Button>
          </StepContent>
        </Step>

        {/* Step 3: Enter Credentials */}
        <Step>
          <StepLabel>{POPBILL_SETUP_STEPS[2].label}</StepLabel>
          <StepContent>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
              {POPBILL_SETUP_STEPS[2].description}
            </Typography>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mb: 2 }}>
              <TextField
                label="Link ID"
                value={credentials.linkId}
                onChange={(e) => handleCredentialChange('linkId', e.target.value)}
                fullWidth
                required
                helperText="팝빌에서 발급받은 Link ID를 입력하세요."
              />
              <TextField
                label="Secret Key"
                type="password"
                value={credentials.secretKey}
                onChange={(e) => handleCredentialChange('secretKey', e.target.value)}
                fullWidth
                required
                helperText="팝빌에서 발급받은 Secret Key를 입력하세요."
              />
              <TextField
                label="사업자등록번호"
                value={credentials.corporateNumber}
                onChange={(e) => handleCredentialChange('corporateNumber', e.target.value)}
                fullWidth
                required
                placeholder="000-00-00000"
                helperText="팝빌에 등록된 사업자등록번호를 입력하세요."
              />
            </Box>
            <Button
              variant="contained"
              onClick={() => setActiveStep(3)}
              disabled={!credentials.linkId || !credentials.secretKey || !credentials.corporateNumber}
            >
              다음
            </Button>
            <Button onClick={() => setActiveStep(1)} sx={{ ml: 1 }}>
              이전
            </Button>
          </StepContent>
        </Step>

        {/* Step 4: Test Connection */}
        <Step>
          <StepLabel>{POPBILL_SETUP_STEPS[3].label}</StepLabel>
          <StepContent>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
              {POPBILL_SETUP_STEPS[3].description}
            </Typography>

            {testResult === 'success' && (
              <Alert severity="success" sx={{ mb: 2 }}>
                연동 테스트가 성공했습니다! 세금계산서 발행이 가능합니다.
              </Alert>
            )}

            {testResult === 'error' && (
              <Alert severity="error" sx={{ mb: 2 }}>
                연동 테스트가 실패했습니다. 인증 정보를 확인해 주세요.
              </Alert>
            )}

            <Button
              variant="contained"
              onClick={() => testConnectionMutation.mutate()}
              disabled={testConnectionMutation.isPending}
            >
              {testConnectionMutation.isPending ? '테스트 중...' : '연동 테스트'}
            </Button>
            <Button onClick={() => setActiveStep(2)} sx={{ ml: 1 }}>
              이전
            </Button>
          </StepContent>
        </Step>
      </Stepper>

      {activeStep === 4 && (
        <Alert severity="success" sx={{ mt: 2 }}>
          팝빌 연동이 완료되었습니다!
        </Alert>
      )}
    </Box>
  );
};
```

---

## 8. Go-Live 체크리스트

### 8.1 Go-Live 전 점검 사항

```markdown
## K-ERP Go-Live 체크리스트

### 1. 시스템 설정 확인
- [ ] 회사 기본 정보 등록 완료
- [ ] 계정과목 체계 설정 완료
- [ ] 부서/조직 구조 설정 완료
- [ ] 사용자 계정 생성 및 권한 부여 완료
- [ ] 회계연도 설정 완료

### 2. 마스터 데이터
- [ ] 거래처 정보 등록/임포트 완료
- [ ] 품목 정보 등록/임포트 완료
- [ ] 직원 정보 등록/임포트 완료 (인사급여 사용시)
- [ ] 기초잔액 입력 및 검증 완료

### 3. 외부 연동
- [ ] 팝빌 세금계산서 연동 테스트 완료
- [ ] 은행 계좌 연동 설정 (해당시)
- [ ] 4대보험 EDI 연동 테스트 (해당시)
- [ ] 알림 서비스 설정 (이메일/카카오)

### 4. 사용자 교육
- [ ] 관리자 교육 완료
- [ ] 회계 담당자 교육 완료
- [ ] 영업/구매 담당자 교육 완료
- [ ] 사용자 매뉴얼 배포

### 5. 시험 운영
- [ ] 전표 입력 테스트 완료
- [ ] 세금계산서 발행 테스트 완료
- [ ] 리포트 출력 테스트 완료
- [ ] 백업/복구 테스트 완료

### 6. 최종 확인
- [ ] 성능 테스트 통과
- [ ] 보안 점검 완료
- [ ] 고객사 최종 승인
- [ ] 비상 연락망 확보
```

---

## 9. 온보딩 자동화

### 9.1 온보딩 이벤트 처리

```go
// internal/worker/onboarding_worker.go

package worker

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/google/uuid"
    "github.com/nats-io/nats.go/jetstream"
    "kerp/internal/service"
    "kerp/pkg/logger"
)

type OnboardingWorker struct {
    js                 jetstream.JetStream
    provisioningService *service.ProvisioningService
    emailService       *service.EmailService
    logger             *logger.Logger
}

func (w *OnboardingWorker) Start(ctx context.Context) error {
    consumer, err := w.js.CreateOrUpdateConsumer(ctx, "ONBOARDING", jetstream.ConsumerConfig{
        Durable:       "onboarding-processor",
        FilterSubject: "onboarding.>",
        AckPolicy:     jetstream.AckExplicitPolicy,
        MaxDeliver:    3,
    })
    if err != nil {
        return fmt.Errorf("failed to create consumer: %w", err)
    }

    msgs, err := consumer.Messages()
    if err != nil {
        return fmt.Errorf("failed to get messages: %w", err)
    }

    go func() {
        for {
            select {
            case <-ctx.Done():
                return
            default:
                msg, err := msgs.Next()
                if err != nil {
                    w.logger.Error("Error getting next message", "error", err)
                    continue
                }

                w.processMessage(ctx, msg)
            }
        }
    }()

    return nil
}

func (w *OnboardingWorker) processMessage(ctx context.Context, msg jetstream.Msg) {
    subject := msg.Subject()

    switch subject {
    case "onboarding.started":
        w.handleOnboardingStarted(ctx, msg)
    case "onboarding.step.completed":
        w.handleStepCompleted(ctx, msg)
    case "onboarding.completed":
        w.handleOnboardingCompleted(ctx, msg)
    default:
        w.logger.Warn("Unknown onboarding event", "subject", subject)
        msg.Ack()
    }
}

type OnboardingStartedEvent struct {
    CompanyID   uuid.UUID `json:"company_id"`
    PlanType    string    `json:"plan_type"`
    AdminUserID uuid.UUID `json:"admin_user_id"`
}

func (w *OnboardingWorker) handleOnboardingStarted(ctx context.Context, msg jetstream.Msg) {
    var event OnboardingStartedEvent
    if err := json.Unmarshal(msg.Data(), &event); err != nil {
        w.logger.Error("Failed to unmarshal event", "error", err)
        msg.Nak()
        return
    }

    w.logger.Info("Processing onboarding started event", "company_id", event.CompanyID)

    // 1. Provision tenant resources
    company, err := w.companyRepo.FindByID(ctx, event.CompanyID)
    if err != nil {
        w.logger.Error("Failed to find company", "error", err)
        msg.Nak()
        return
    }

    result, err := w.provisioningService.ProvisionTenant(ctx, company)
    if err != nil {
        w.logger.Error("Failed to provision tenant", "error", err)
        msg.Nak()
        return
    }

    w.logger.Info("Tenant provisioned successfully", "result", result)

    // 2. Send activation email to admin
    adminUser, err := w.userRepo.FindByID(ctx, event.AdminUserID)
    if err != nil {
        w.logger.Error("Failed to find admin user", "error", err)
        msg.Nak()
        return
    }

    if err := w.emailService.SendActivationEmail(ctx, adminUser.Email, map[string]string{
        "name":            adminUser.Name,
        "activation_link": fmt.Sprintf("https://app.kerp.io/activate?token=%s", adminUser.ActivationToken),
    }); err != nil {
        w.logger.Error("Failed to send activation email", "error", err)
        // Don't NAK - email failure shouldn't block provisioning
    }

    // 3. Schedule onboarding reminders
    w.scheduleOnboardingReminders(ctx, event.CompanyID, event.AdminUserID)

    msg.Ack()
}

type StepCompletedEvent struct {
    CompanyID uuid.UUID `json:"company_id"`
    StepName  string    `json:"step_name"`
    UserID    uuid.UUID `json:"user_id"`
}

func (w *OnboardingWorker) handleStepCompleted(ctx context.Context, msg jetstream.Msg) {
    var event StepCompletedEvent
    if err := json.Unmarshal(msg.Data(), &event); err != nil {
        w.logger.Error("Failed to unmarshal event", "error", err)
        msg.Nak()
        return
    }

    w.logger.Info("Onboarding step completed",
        "company_id", event.CompanyID,
        "step", event.StepName,
    )

    // Update analytics
    // Send progress notification to CSM if needed

    msg.Ack()
}

type OnboardingCompletedEvent struct {
    CompanyID   uuid.UUID `json:"company_id"`
    CompletedAt string    `json:"completed_at"`
}

func (w *OnboardingWorker) handleOnboardingCompleted(ctx context.Context, msg jetstream.Msg) {
    var event OnboardingCompletedEvent
    if err := json.Unmarshal(msg.Data(), &event); err != nil {
        w.logger.Error("Failed to unmarshal event", "error", err)
        msg.Nak()
        return
    }

    w.logger.Info("Onboarding completed", "company_id", event.CompanyID)

    // 1. Send congratulations email
    company, _ := w.companyRepo.FindByID(ctx, event.CompanyID)
    admins, _ := w.userRepo.FindAdminsByCompany(ctx, event.CompanyID)

    for _, admin := range admins {
        w.emailService.SendOnboardingCompletedEmail(ctx, admin.Email, map[string]string{
            "company_name": company.Name,
            "admin_name":   admin.Name,
        })
    }

    // 2. Notify CSM team
    w.notifyCSMTeam(ctx, event.CompanyID, "Onboarding completed")

    // 3. Start trial period if applicable
    w.subscriptionService.StartTrialPeriod(ctx, event.CompanyID)

    msg.Ack()
}

func (w *OnboardingWorker) scheduleOnboardingReminders(ctx context.Context, companyID, adminUserID uuid.UUID) {
    // Schedule D+3 reminder if setup not complete
    // Schedule D+7 reminder if data import not complete
    // Schedule D+14 reminder for trial ending
}

func (w *OnboardingWorker) notifyCSMTeam(ctx context.Context, companyID uuid.UUID, message string) {
    // Send Slack notification or internal alert
}
```

---

## 10. 지원 및 에스컬레이션

### 10.1 지원 채널

| 채널 | 대상 요금제 | 응답 시간 | 운영 시간 |
|------|-------------|-----------|-----------|
| 이메일 | 전체 | 24시간 이내 | 24/7 |
| 채팅 | Standard+ | 2시간 이내 | 평일 09-18 |
| 전화 | Enterprise | 30분 이내 | 평일 09-18 |
| 긴급 핫라인 | Enterprise | 15분 이내 | 24/7 |

### 10.2 에스컬레이션 매트릭스

| 단계 | 조건 | 담당자 | 대응 시간 |
|------|------|--------|-----------|
| L1 | 일반 문의 | 고객지원팀 | 4시간 |
| L2 | 기술 이슈 | 기술지원팀 | 2시간 |
| L3 | 긴급 장애 | 개발팀 | 1시간 |
| L4 | 비즈니스 임팩트 | 경영진 | 30분 |

---

## 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 1.0 | 2025-01-xx | K-ERP Team | 최초 작성 |
