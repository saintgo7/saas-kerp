# 26. 규정준수 가이드 (Compliance Guide)

## 목차
1. [개요](#1-개요)
2. [개인정보보호법 준수](#2-개인정보보호법-준수)
3. [전자금융거래법 준수](#3-전자금융거래법-준수)
4. [K-IFRS 회계기준 준수](#4-k-ifrs-회계기준-준수)
5. [세무 규정 준수](#5-세무-규정-준수)
6. [4대보험 규정 준수](#6-4대보험-규정-준수)
7. [감사 및 로깅](#7-감사-및-로깅)
8. [규정준수 체크리스트](#8-규정준수-체크리스트)

---

## 1. 개요

### 1.1 적용 규정

```yaml
applicable_regulations:
  privacy:
    name: "개인정보보호법"
    version: "2023년 개정"
    authority: "개인정보보호위원회"
    requirements:
      - "개인정보 수집/이용 동의"
      - "안전성 확보 조치"
      - "개인정보 처리방침 공개"
      - "정보주체 권리 보장"

  electronic_finance:
    name: "전자금융거래법"
    version: "2023년 개정"
    authority: "금융위원회"
    requirements:
      - "전자금융거래 안전성 확보"
      - "접근통제"
      - "암호화"
      - "재해복구"

  accounting:
    name: "K-IFRS"
    version: "2024년 기준"
    authority: "한국회계기준원"
    requirements:
      - "복식부기 원칙"
      - "재무제표 작성 기준"
      - "회계 데이터 보존"

  tax:
    name: "부가가치세법/법인세법"
    authority: "국세청"
    requirements:
      - "세금계산서 발행/수취"
      - "전자세금계산서 의무 발행"
      - "증빙 보존"

  social_insurance:
    name: "4대보험 관련 법률"
    authority: "각 관리공단"
    requirements:
      - "취득/상실 신고"
      - "보험료 산정/납부"
      - "EDI 연동"
```

### 1.2 규정준수 아키텍처

```
┌────────────────────────────────────────────────────────────────────┐
│                    K-ERP Compliance Architecture                    │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                     Application Layer                         │  │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐              │  │
│  │  │  Go API    │  │  Python    │  │  React     │              │  │
│  │  │  Server    │  │  Services  │  │  Frontend  │              │  │
│  │  └─────┬──────┘  └─────┬──────┘  └─────┬──────┘              │  │
│  └────────┼───────────────┼───────────────┼─────────────────────┘  │
│           │               │               │                         │
│  ┌────────┼───────────────┼───────────────┼─────────────────────┐  │
│  │        │     Compliance Controls       │                      │  │
│  │  ┌─────▼─────┐  ┌─────▼─────┐  ┌─────▼─────┐                │  │
│  │  │ Auth &    │  │ Encryption│  │ Audit     │                │  │
│  │  │ Access    │  │ Service   │  │ Logger    │                │  │
│  │  │ Control   │  │(SEED/ARIA)│  │           │                │  │
│  │  └───────────┘  └───────────┘  └───────────┘                │  │
│  │                                                               │  │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐                │  │
│  │  │ PII       │  │ Data      │  │ Consent   │                │  │
│  │  │ Masking   │  │ Retention │  │ Manager   │                │  │
│  │  └───────────┘  └───────────┘  └───────────┘                │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                      Data Layer                               │  │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐              │  │
│  │  │ PostgreSQL │  │  Redis     │  │  S3        │              │  │
│  │  │ (TDE)      │  │ (Encrypted)│  │ (SSE-KMS)  │              │  │
│  │  └────────────┘  └────────────┘  └────────────┘              │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

---

## 2. 개인정보보호법 준수

### 2.1 개인정보 분류

```go
// internal/compliance/pii/classifier.go
package pii

type SensitivityLevel int

const (
    LevelPublic      SensitivityLevel = 0 // 공개 가능
    LevelInternal    SensitivityLevel = 1 // 내부 사용
    LevelConfidential SensitivityLevel = 2 // 기밀
    LevelRestricted   SensitivityLevel = 3 // 제한적 접근
)

type PIICategory string

const (
    CategoryIdentification PIICategory = "identification" // 식별정보
    CategoryContact        PIICategory = "contact"        // 연락처
    CategoryFinancial      PIICategory = "financial"      // 금융정보
    CategoryHealth         PIICategory = "health"         // 건강정보
    CategoryBiometric      PIICategory = "biometric"      // 생체정보
)

// PIIField defines a PII field and its handling requirements
type PIIField struct {
    Name             string
    Category         PIICategory
    Sensitivity      SensitivityLevel
    RequiresConsent  bool
    RetentionDays    int
    EncryptAtRest    bool
    MaskInLogs       bool
    MaskPattern      string // e.g., "***-**-{{last4}}"
}

// PIIRegistry contains all PII field definitions
var PIIRegistry = map[string]PIIField{
    "resident_registration_number": {
        Name:            "주민등록번호",
        Category:        CategoryIdentification,
        Sensitivity:     LevelRestricted,
        RequiresConsent: true,
        RetentionDays:   365 * 5, // 5년 보관 후 파기
        EncryptAtRest:   true,
        MaskInLogs:      true,
        MaskPattern:     "******-*******",
    },
    "bank_account_number": {
        Name:            "계좌번호",
        Category:        CategoryFinancial,
        Sensitivity:     LevelConfidential,
        RequiresConsent: true,
        RetentionDays:   365 * 5,
        EncryptAtRest:   true,
        MaskInLogs:      true,
        MaskPattern:     "****-****-{{last4}}",
    },
    "email": {
        Name:            "이메일",
        Category:        CategoryContact,
        Sensitivity:     LevelInternal,
        RequiresConsent: true,
        RetentionDays:   365 * 3,
        EncryptAtRest:   false,
        MaskInLogs:      true,
        MaskPattern:     "{{first2}}***@***",
    },
    "phone_number": {
        Name:            "전화번호",
        Category:        CategoryContact,
        Sensitivity:     LevelInternal,
        RequiresConsent: true,
        RetentionDays:   365 * 3,
        EncryptAtRest:   false,
        MaskInLogs:      true,
        MaskPattern:     "010-****-{{last4}}",
    },
    "salary": {
        Name:            "급여",
        Category:        CategoryFinancial,
        Sensitivity:     LevelConfidential,
        RequiresConsent: true,
        RetentionDays:   365 * 5,
        EncryptAtRest:   true,
        MaskInLogs:      true,
        MaskPattern:     "***,***,***",
    },
}
```

### 2.2 동의 관리

```go
// internal/compliance/consent/manager.go
package consent

import (
    "context"
    "time"

    "github.com/google/uuid"
)

type ConsentType string

const (
    ConsentTypeCollection    ConsentType = "collection"     // 수집 동의
    ConsentTypeUse           ConsentType = "use"            // 이용 동의
    ConsentTypeProvision     ConsentType = "provision"      // 제3자 제공 동의
    ConsentTypeMarketing     ConsentType = "marketing"      // 마케팅 동의
    ConsentTypeOverseas      ConsentType = "overseas"       // 국외 이전 동의
)

type ConsentStatus string

const (
    ConsentStatusGranted   ConsentStatus = "granted"
    ConsentStatusRevoked   ConsentStatus = "revoked"
    ConsentStatusExpired   ConsentStatus = "expired"
)

type Consent struct {
    ID            uuid.UUID
    UserID        uuid.UUID
    CompanyID     uuid.UUID
    ConsentType   ConsentType
    Status        ConsentStatus
    Purpose       string
    Items         []string // 동의 항목
    GrantedAt     time.Time
    ExpiresAt     *time.Time
    RevokedAt     *time.Time
    IPAddress     string
    UserAgent     string
    Version       string // 개인정보처리방침 버전
}

type ConsentManager struct {
    repo   ConsentRepository
    logger *slog.Logger
}

// GrantConsent records user consent
func (m *ConsentManager) GrantConsent(ctx context.Context, req GrantConsentRequest) (*Consent, error) {
    consent := &Consent{
        ID:          uuid.New(),
        UserID:      req.UserID,
        CompanyID:   req.CompanyID,
        ConsentType: req.ConsentType,
        Status:      ConsentStatusGranted,
        Purpose:     req.Purpose,
        Items:       req.Items,
        GrantedAt:   time.Now(),
        ExpiresAt:   req.ExpiresAt,
        IPAddress:   req.IPAddress,
        UserAgent:   req.UserAgent,
        Version:     req.PolicyVersion,
    }

    if err := m.repo.Save(ctx, consent); err != nil {
        return nil, fmt.Errorf("failed to save consent: %w", err)
    }

    m.logger.Info("consent granted",
        slog.String("user_id", req.UserID.String()),
        slog.String("consent_type", string(req.ConsentType)),
    )

    return consent, nil
}

// RevokeConsent revokes user consent
func (m *ConsentManager) RevokeConsent(ctx context.Context, userID uuid.UUID, consentType ConsentType) error {
    consent, err := m.repo.FindByUserAndType(ctx, userID, consentType)
    if err != nil {
        return fmt.Errorf("consent not found: %w", err)
    }

    now := time.Now()
    consent.Status = ConsentStatusRevoked
    consent.RevokedAt = &now

    if err := m.repo.Save(ctx, consent); err != nil {
        return fmt.Errorf("failed to revoke consent: %w", err)
    }

    m.logger.Info("consent revoked",
        slog.String("user_id", userID.String()),
        slog.String("consent_type", string(consentType)),
    )

    return nil
}

// VerifyConsent checks if user has valid consent
func (m *ConsentManager) VerifyConsent(ctx context.Context, userID uuid.UUID, consentType ConsentType) (bool, error) {
    consent, err := m.repo.FindByUserAndType(ctx, userID, consentType)
    if err != nil {
        return false, nil
    }

    if consent.Status != ConsentStatusGranted {
        return false, nil
    }

    if consent.ExpiresAt != nil && consent.ExpiresAt.Before(time.Now()) {
        return false, nil
    }

    return true, nil
}

// GetConsentHistory returns consent history for a user
func (m *ConsentManager) GetConsentHistory(ctx context.Context, userID uuid.UUID) ([]Consent, error) {
    return m.repo.FindAllByUser(ctx, userID)
}
```

### 2.3 데이터 마스킹

```go
// internal/compliance/pii/masker.go
package pii

import (
    "regexp"
    "strings"
)

type Masker struct {
    registry map[string]PIIField
}

func NewMasker() *Masker {
    return &Masker{registry: PIIRegistry}
}

// MaskValue masks a PII value according to its pattern
func (m *Masker) MaskValue(fieldName string, value string) string {
    field, ok := m.registry[fieldName]
    if !ok || !field.MaskInLogs {
        return value
    }

    return m.applyPattern(value, field.MaskPattern)
}

func (m *Masker) applyPattern(value string, pattern string) string {
    if pattern == "" {
        return strings.Repeat("*", len(value))
    }

    // Handle special patterns
    result := pattern

    // {{last4}} - show last 4 characters
    if strings.Contains(result, "{{last4}}") {
        if len(value) >= 4 {
            result = strings.Replace(result, "{{last4}}", value[len(value)-4:], 1)
        }
    }

    // {{first2}} - show first 2 characters
    if strings.Contains(result, "{{first2}}") {
        if len(value) >= 2 {
            result = strings.Replace(result, "{{first2}}", value[:2], 1)
        }
    }

    return result
}

// MaskStruct masks PII fields in a struct
func (m *Masker) MaskStruct(v interface{}) interface{} {
    // Use reflection to identify and mask PII fields
    // Returns a copy with masked values
    return nil
}

// Example masks
func (m *Masker) MaskRRN(rrn string) string {
    // 주민등록번호: 900101-1234567 -> ******-*******
    if len(rrn) != 14 {
        return strings.Repeat("*", len(rrn))
    }
    return "******-*******"
}

func (m *Masker) MaskBankAccount(account string) string {
    // 계좌번호: 110-123-456789 -> ****-****-6789
    digits := regexp.MustCompile(`\d`).FindAllString(account, -1)
    if len(digits) < 4 {
        return strings.Repeat("*", len(account))
    }
    last4 := strings.Join(digits[len(digits)-4:], "")
    return "****-****-" + last4
}

func (m *Masker) MaskPhone(phone string) string {
    // 전화번호: 010-1234-5678 -> 010-****-5678
    if len(phone) < 4 {
        return strings.Repeat("*", len(phone))
    }
    return "010-****-" + phone[len(phone)-4:]
}

func (m *Masker) MaskEmail(email string) string {
    // 이메일: user@example.com -> us***@***
    parts := strings.Split(email, "@")
    if len(parts) != 2 {
        return strings.Repeat("*", len(email))
    }

    local := parts[0]
    if len(local) > 2 {
        local = local[:2] + "***"
    }

    return local + "@***"
}
```

### 2.4 데이터 보존 및 파기

```go
// internal/compliance/retention/policy.go
package retention

import (
    "context"
    "time"
)

type RetentionPolicy struct {
    Name           string
    DataType       string
    RetentionDays  int
    LegalBasis     string
    DestructMethod string
}

var RetentionPolicies = []RetentionPolicy{
    {
        Name:           "회계 증빙",
        DataType:       "vouchers",
        RetentionDays:  365 * 10, // 10년
        LegalBasis:     "상법 제33조, 법인세법 제116조",
        DestructMethod: "secure_delete",
    },
    {
        Name:           "세금계산서",
        DataType:       "tax_invoices",
        RetentionDays:  365 * 10, // 10년
        LegalBasis:     "부가가치세법 제71조",
        DestructMethod: "secure_delete",
    },
    {
        Name:           "급여대장",
        DataType:       "payrolls",
        RetentionDays:  365 * 5, // 5년
        LegalBasis:     "근로기준법 제42조",
        DestructMethod: "secure_delete",
    },
    {
        Name:           "개인정보",
        DataType:       "personal_info",
        RetentionDays:  365 * 3, // 3년 (서비스 종료 후)
        LegalBasis:     "개인정보보호법 제21조",
        DestructMethod: "anonymize_or_delete",
    },
    {
        Name:           "로그인 기록",
        DataType:       "login_history",
        RetentionDays:  365 * 3, // 3년
        LegalBasis:     "정보통신망법 제15조",
        DestructMethod: "delete",
    },
    {
        Name:           "접근 로그",
        DataType:       "access_logs",
        RetentionDays:  365 * 5, // 5년
        LegalBasis:     "전자금융거래법 제22조",
        DestructMethod: "archive_then_delete",
    },
}

type RetentionManager struct {
    policies []RetentionPolicy
    repo     DataRepository
    logger   *slog.Logger
}

// ProcessRetention processes data retention for all policies
func (m *RetentionManager) ProcessRetention(ctx context.Context) (*RetentionReport, error) {
    report := &RetentionReport{
        ProcessedAt: time.Now(),
        Policies:    make([]PolicyResult, 0),
    }

    for _, policy := range m.policies {
        result, err := m.processPolicy(ctx, policy)
        if err != nil {
            m.logger.Error("retention processing failed",
                slog.String("policy", policy.Name),
                slog.Any("error", err),
            )
            result.Error = err.Error()
        }
        report.Policies = append(report.Policies, result)
    }

    return report, nil
}

func (m *RetentionManager) processPolicy(ctx context.Context, policy RetentionPolicy) (PolicyResult, error) {
    result := PolicyResult{
        PolicyName: policy.Name,
        DataType:   policy.DataType,
    }

    // Find expired data
    cutoffDate := time.Now().AddDate(0, 0, -policy.RetentionDays)

    expiredRecords, err := m.repo.FindExpired(ctx, policy.DataType, cutoffDate)
    if err != nil {
        return result, fmt.Errorf("failed to find expired records: %w", err)
    }

    result.RecordsFound = len(expiredRecords)

    // Process based on destruction method
    switch policy.DestructMethod {
    case "secure_delete":
        count, err := m.secureDelete(ctx, policy.DataType, expiredRecords)
        result.RecordsProcessed = count
        if err != nil {
            return result, err
        }
    case "anonymize_or_delete":
        count, err := m.anonymize(ctx, policy.DataType, expiredRecords)
        result.RecordsProcessed = count
        if err != nil {
            return result, err
        }
    case "archive_then_delete":
        count, err := m.archiveAndDelete(ctx, policy.DataType, expiredRecords)
        result.RecordsProcessed = count
        if err != nil {
            return result, err
        }
    }

    return result, nil
}

func (m *RetentionManager) secureDelete(ctx context.Context, dataType string, records []Record) (int, error) {
    // Securely delete records with audit trail
    count := 0
    for _, record := range records {
        if err := m.repo.SecureDelete(ctx, dataType, record.ID); err != nil {
            m.logger.Error("secure delete failed",
                slog.String("data_type", dataType),
                slog.String("record_id", record.ID),
                slog.Any("error", err),
            )
            continue
        }
        count++

        // Log deletion for audit
        m.logger.Info("record deleted per retention policy",
            slog.String("data_type", dataType),
            slog.String("record_id", record.ID),
        )
    }
    return count, nil
}

func (m *RetentionManager) anonymize(ctx context.Context, dataType string, records []Record) (int, error) {
    // Anonymize PII while keeping statistical data
    count := 0
    for _, record := range records {
        if err := m.repo.Anonymize(ctx, dataType, record.ID); err != nil {
            continue
        }
        count++
    }
    return count, nil
}
```

---

## 3. 전자금융거래법 준수

### 3.1 접근통제

```go
// internal/compliance/access/controller.go
package access

import (
    "context"
    "net"
    "time"
)

type AccessLevel int

const (
    AccessLevelNone    AccessLevel = 0
    AccessLevelRead    AccessLevel = 1
    AccessLevelWrite   AccessLevel = 2
    AccessLevelAdmin   AccessLevel = 3
    AccessLevelSystem  AccessLevel = 4
)

type AccessRule struct {
    Resource      string
    RequiredLevel AccessLevel
    IPWhitelist   []string
    TimeRestrict  *TimeRestriction
    MFARequired   bool
    AuditLevel    string
}

type TimeRestriction struct {
    AllowedDays  []time.Weekday
    StartHour    int
    EndHour      int
    TimeZone     string
}

type AccessController struct {
    rules  map[string]AccessRule
    logger *slog.Logger
}

// FinancialAccessRules defines access rules for financial operations
var FinancialAccessRules = map[string]AccessRule{
    "voucher.create": {
        Resource:      "vouchers",
        RequiredLevel: AccessLevelWrite,
        MFARequired:   false,
        AuditLevel:    "info",
    },
    "voucher.post": {
        Resource:      "vouchers",
        RequiredLevel: AccessLevelWrite,
        MFARequired:   true, // MFA required for posting
        AuditLevel:    "warn",
    },
    "voucher.delete": {
        Resource:      "vouchers",
        RequiredLevel: AccessLevelAdmin,
        MFARequired:   true,
        AuditLevel:    "error",
    },
    "tax_invoice.issue": {
        Resource:      "tax_invoices",
        RequiredLevel: AccessLevelWrite,
        MFARequired:   true,
        AuditLevel:    "warn",
    },
    "payroll.process": {
        Resource:      "payrolls",
        RequiredLevel: AccessLevelAdmin,
        MFARequired:   true,
        TimeRestrict: &TimeRestriction{
            AllowedDays: []time.Weekday{time.Monday, time.Tuesday, time.Wednesday, time.Thursday, time.Friday},
            StartHour:   9,
            EndHour:     18,
            TimeZone:    "Asia/Seoul",
        },
        AuditLevel: "error",
    },
    "bank_transfer.execute": {
        Resource:      "bank_transfers",
        RequiredLevel: AccessLevelAdmin,
        IPWhitelist:   []string{"10.0.0.0/8", "172.16.0.0/12"},
        MFARequired:   true,
        AuditLevel:    "error",
    },
}

func (c *AccessController) CheckAccess(ctx context.Context, req AccessCheckRequest) (*AccessCheckResult, error) {
    rule, ok := c.rules[req.Action]
    if !ok {
        return &AccessCheckResult{Allowed: false, Reason: "unknown action"}, nil
    }

    result := &AccessCheckResult{}

    // Check access level
    if req.UserLevel < rule.RequiredLevel {
        result.Allowed = false
        result.Reason = "insufficient access level"
        return result, nil
    }

    // Check IP whitelist
    if len(rule.IPWhitelist) > 0 {
        if !c.isIPAllowed(req.IPAddress, rule.IPWhitelist) {
            result.Allowed = false
            result.Reason = "IP not in whitelist"
            return result, nil
        }
    }

    // Check time restriction
    if rule.TimeRestrict != nil {
        if !c.isTimeAllowed(rule.TimeRestrict) {
            result.Allowed = false
            result.Reason = "access not allowed at this time"
            return result, nil
        }
    }

    // Check MFA
    if rule.MFARequired && !req.MFAVerified {
        result.Allowed = false
        result.Reason = "MFA verification required"
        result.RequiresMFA = true
        return result, nil
    }

    result.Allowed = true
    return result, nil
}

func (c *AccessController) isIPAllowed(ip string, whitelist []string) bool {
    clientIP := net.ParseIP(ip)
    if clientIP == nil {
        return false
    }

    for _, cidr := range whitelist {
        _, network, err := net.ParseCIDR(cidr)
        if err != nil {
            continue
        }
        if network.Contains(clientIP) {
            return true
        }
    }
    return false
}

func (c *AccessController) isTimeAllowed(restrict *TimeRestriction) bool {
    loc, err := time.LoadLocation(restrict.TimeZone)
    if err != nil {
        return false
    }

    now := time.Now().In(loc)

    // Check day
    dayAllowed := false
    for _, day := range restrict.AllowedDays {
        if now.Weekday() == day {
            dayAllowed = true
            break
        }
    }
    if !dayAllowed {
        return false
    }

    // Check hour
    hour := now.Hour()
    return hour >= restrict.StartHour && hour < restrict.EndHour
}
```

### 3.2 암호화 정책

```go
// internal/compliance/encryption/policy.go
package encryption

type EncryptionRequirement struct {
    DataCategory    string
    AtRest          bool
    InTransit       bool
    Algorithm       string
    KeyRotationDays int
    MinKeyLength    int
}

var EncryptionRequirements = []EncryptionRequirement{
    {
        DataCategory:    "주민등록번호",
        AtRest:          true,
        InTransit:       true,
        Algorithm:       "AES-256",
        KeyRotationDays: 365,
        MinKeyLength:    256,
    },
    {
        DataCategory:    "계좌번호",
        AtRest:          true,
        InTransit:       true,
        Algorithm:       "AES-256",
        KeyRotationDays: 365,
        MinKeyLength:    256,
    },
    {
        DataCategory:    "비밀번호",
        AtRest:          true, // Hashed, not encrypted
        InTransit:       true,
        Algorithm:       "bcrypt",
        KeyRotationDays: 0, // N/A for hashing
        MinKeyLength:    0,
    },
    {
        DataCategory:    "금융거래정보",
        AtRest:          true,
        InTransit:       true,
        Algorithm:       "AES-256",
        KeyRotationDays: 180,
        MinKeyLength:    256,
    },
    {
        DataCategory:    "정부기관 통신",
        AtRest:          true,
        InTransit:       true,
        Algorithm:       "SEED-CBC/ARIA-CBC", // 한국 표준
        KeyRotationDays: 365,
        MinKeyLength:    128,
    },
}

// TLS Configuration for compliance
type TLSConfig struct {
    MinVersion     string
    CipherSuites   []string
    RequireClientCert bool
}

var ComplianceTLSConfig = TLSConfig{
    MinVersion: "TLS1.2",
    CipherSuites: []string{
        "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
        "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
        "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
    },
    RequireClientCert: false, // True for B2B connections
}
```

---

## 4. K-IFRS 회계기준 준수

### 4.1 복식부기 검증

```go
// internal/compliance/accounting/validator.go
package accounting

import (
    "context"
    "fmt"

    "github.com/shopspring/decimal"
)

type AccountingValidator struct {
    accountRepo AccountRepository
    logger      *slog.Logger
}

// ValidateDoubleEntry ensures debit equals credit
func (v *AccountingValidator) ValidateDoubleEntry(voucher *domain.Voucher) error {
    totalDebit := decimal.Zero
    totalCredit := decimal.Zero

    for _, line := range voucher.Lines {
        totalDebit = totalDebit.Add(line.DebitAmt)
        totalCredit = totalCredit.Add(line.CreditAmt)
    }

    if !totalDebit.Equal(totalCredit) {
        return fmt.Errorf("double entry validation failed: debit=%s, credit=%s",
            totalDebit.String(), totalCredit.String())
    }

    return nil
}

// ValidateAccountCode validates account code against chart of accounts
func (v *AccountingValidator) ValidateAccountCode(ctx context.Context, code string, companyID uuid.UUID) error {
    account, err := v.accountRepo.FindByCode(ctx, companyID, code)
    if err != nil {
        return fmt.Errorf("invalid account code: %s", code)
    }

    if !account.IsActive {
        return fmt.Errorf("account is inactive: %s", code)
    }

    if account.IsControlAccount {
        return fmt.Errorf("cannot post directly to control account: %s", code)
    }

    return nil
}

// ValidateFiscalPeriod ensures voucher date is within open fiscal period
func (v *AccountingValidator) ValidateFiscalPeriod(ctx context.Context, voucherDate time.Time, companyID uuid.UUID) error {
    period, err := v.periodRepo.FindByDate(ctx, companyID, voucherDate)
    if err != nil {
        return fmt.Errorf("no fiscal period found for date: %s", voucherDate.Format("2006-01-02"))
    }

    if period.Status == PeriodStatusClosed {
        return fmt.Errorf("fiscal period is closed: %s", period.Name)
    }

    if period.Status == PeriodStatusLocked {
        return fmt.Errorf("fiscal period is locked: %s", period.Name)
    }

    return nil
}

// AccountingEquation represents assets = liabilities + equity
type AccountingEquation struct {
    TotalAssets      decimal.Decimal
    TotalLiabilities decimal.Decimal
    TotalEquity      decimal.Decimal
    IsBalanced       bool
    Difference       decimal.Decimal
}

// ValidateAccountingEquation checks if accounting equation holds
func (v *AccountingValidator) ValidateAccountingEquation(ctx context.Context, companyID uuid.UUID, asOfDate time.Time) (*AccountingEquation, error) {
    // Get trial balance
    balances, err := v.getTrialBalance(ctx, companyID, asOfDate)
    if err != nil {
        return nil, err
    }

    equation := &AccountingEquation{}

    for _, balance := range balances {
        switch balance.AccountType {
        case AccountTypeAsset:
            equation.TotalAssets = equation.TotalAssets.Add(balance.Balance)
        case AccountTypeLiability:
            equation.TotalLiabilities = equation.TotalLiabilities.Add(balance.Balance)
        case AccountTypeEquity, AccountTypeRevenue, AccountTypeExpense:
            equation.TotalEquity = equation.TotalEquity.Add(balance.Balance)
        }
    }

    // Assets = Liabilities + Equity
    rightSide := equation.TotalLiabilities.Add(equation.TotalEquity)
    equation.Difference = equation.TotalAssets.Sub(rightSide)
    equation.IsBalanced = equation.Difference.IsZero()

    return equation, nil
}
```

### 4.2 재무제표 생성 규칙

```go
// internal/compliance/accounting/financial_statements.go
package accounting

import "github.com/shopspring/decimal"

// K-IFRS compliant financial statement structures

// BalanceSheet represents Statement of Financial Position
type BalanceSheet struct {
    AsOfDate time.Time
    Company  CompanyInfo

    // Assets
    CurrentAssets    []AccountBalance
    NonCurrentAssets []AccountBalance
    TotalAssets      decimal.Decimal

    // Liabilities
    CurrentLiabilities    []AccountBalance
    NonCurrentLiabilities []AccountBalance
    TotalLiabilities      decimal.Decimal

    // Equity
    ShareCapital     decimal.Decimal
    RetainedEarnings decimal.Decimal
    OtherEquity      decimal.Decimal
    TotalEquity      decimal.Decimal

    // Validation
    IsBalanced bool
}

// IncomeStatement represents Statement of Comprehensive Income
type IncomeStatement struct {
    PeriodStart time.Time
    PeriodEnd   time.Time
    Company     CompanyInfo

    // Revenue
    Revenue         []AccountBalance
    TotalRevenue    decimal.Decimal

    // Cost of Sales
    CostOfSales     []AccountBalance
    TotalCostOfSales decimal.Decimal

    GrossProfit decimal.Decimal

    // Operating Expenses
    SellingExpenses        decimal.Decimal
    AdministrativeExpenses decimal.Decimal
    TotalOperatingExpenses decimal.Decimal

    OperatingIncome decimal.Decimal

    // Non-operating
    FinanceIncome   decimal.Decimal
    FinanceCosts    decimal.Decimal
    OtherIncome     decimal.Decimal
    OtherExpenses   decimal.Decimal

    IncomeBeforeTax decimal.Decimal
    IncomeTaxExpense decimal.Decimal
    NetIncome       decimal.Decimal

    // Other Comprehensive Income (K-IFRS)
    OtherComprehensiveIncome decimal.Decimal
    TotalComprehensiveIncome decimal.Decimal
}

// CashFlowStatement represents Statement of Cash Flows
type CashFlowStatement struct {
    PeriodStart time.Time
    PeriodEnd   time.Time
    Company     CompanyInfo

    // Operating Activities (Indirect Method)
    NetIncome                decimal.Decimal
    DepreciationAmortization decimal.Decimal
    ChangesInWorkingCapital  decimal.Decimal
    OtherOperatingAdjustments decimal.Decimal
    CashFromOperating        decimal.Decimal

    // Investing Activities
    PropertyPurchases decimal.Decimal
    PropertySales     decimal.Decimal
    InvestmentChanges decimal.Decimal
    CashFromInvesting decimal.Decimal

    // Financing Activities
    DebtProceeds     decimal.Decimal
    DebtRepayments   decimal.Decimal
    DividendsPaid    decimal.Decimal
    ShareTransactions decimal.Decimal
    CashFromFinancing decimal.Decimal

    NetChangeInCash   decimal.Decimal
    BeginningCash     decimal.Decimal
    EndingCash        decimal.Decimal
}

// K-IFRS Account Classification
type KIFRSAccountCategory string

const (
    // Assets
    CategoryCurrentAssets              KIFRSAccountCategory = "1.1"  // 유동자산
    CategoryCashAndCashEquivalents     KIFRSAccountCategory = "1.1.1" // 현금및현금성자산
    CategoryTradeReceivables           KIFRSAccountCategory = "1.1.2" // 매출채권
    CategoryInventories                KIFRSAccountCategory = "1.1.3" // 재고자산
    CategoryNonCurrentAssets           KIFRSAccountCategory = "1.2"  // 비유동자산
    CategoryPropertyPlantEquipment     KIFRSAccountCategory = "1.2.1" // 유형자산
    CategoryIntangibleAssets           KIFRSAccountCategory = "1.2.2" // 무형자산

    // Liabilities
    CategoryCurrentLiabilities         KIFRSAccountCategory = "2.1"  // 유동부채
    CategoryTradePayables              KIFRSAccountCategory = "2.1.1" // 매입채무
    CategoryShortTermBorrowings        KIFRSAccountCategory = "2.1.2" // 단기차입금
    CategoryNonCurrentLiabilities      KIFRSAccountCategory = "2.2"  // 비유동부채
    CategoryLongTermBorrowings         KIFRSAccountCategory = "2.2.1" // 장기차입금

    // Equity
    CategoryShareCapital               KIFRSAccountCategory = "3.1"  // 자본금
    CategoryRetainedEarnings           KIFRSAccountCategory = "3.2"  // 이익잉여금

    // Revenue
    CategoryRevenue                    KIFRSAccountCategory = "4.1"  // 매출액

    // Expenses
    CategoryCostOfSales                KIFRSAccountCategory = "5.1"  // 매출원가
    CategorySellingExpenses            KIFRSAccountCategory = "5.2"  // 판매비
    CategoryAdministrativeExpenses     KIFRSAccountCategory = "5.3"  // 관리비
)
```

---

## 5. 세무 규정 준수

### 5.1 세금계산서 규정

```go
// internal/compliance/tax/invoice_validator.go
package tax

import (
    "time"
    "regexp"
)

type TaxInvoiceValidator struct{}

// TaxInvoice validation rules per VAT Act
type TaxInvoiceValidationRule struct {
    Field       string
    Required    bool
    Format      string
    MaxLength   int
    Description string
}

var TaxInvoiceRules = []TaxInvoiceValidationRule{
    {Field: "공급자 사업자등록번호", Required: true, Format: `^\d{10}$`, Description: "10자리 숫자"},
    {Field: "공급자 상호", Required: true, MaxLength: 200},
    {Field: "공급자 대표자", Required: true, MaxLength: 30},
    {Field: "공급자 사업장주소", Required: true, MaxLength: 300},
    {Field: "공급받는자 사업자등록번호", Required: true, Format: `^\d{10}$`},
    {Field: "공급받는자 상호", Required: true, MaxLength: 200},
    {Field: "작성일자", Required: true, Description: "공급시기가 속하는 달의 다음달 10일까지"},
    {Field: "공급가액", Required: true, Description: "양수"},
    {Field: "세액", Required: true, Description: "공급가액 x 세율"},
    {Field: "비고", Required: false, MaxLength: 150},
}

func (v *TaxInvoiceValidator) Validate(invoice *TaxInvoice) []ValidationError {
    var errors []ValidationError

    // Validate BRN format
    if !v.validateBRN(invoice.SupplierBRN) {
        errors = append(errors, ValidationError{
            Field:   "supplier_brn",
            Message: "유효하지 않은 사업자등록번호 형식",
        })
    }

    if !v.validateBRN(invoice.BuyerBRN) {
        errors = append(errors, ValidationError{
            Field:   "buyer_brn",
            Message: "유효하지 않은 사업자등록번호 형식",
        })
    }

    // Validate issue date
    if err := v.validateIssueDate(invoice.IssueDate, invoice.SupplyDate); err != nil {
        errors = append(errors, *err)
    }

    // Validate tax calculation
    expectedTax := invoice.SupplyAmount.Mul(decimal.NewFromFloat(0.1))
    if !invoice.TaxAmount.Equal(expectedTax) {
        // Allow for rounding difference of 1 won
        diff := invoice.TaxAmount.Sub(expectedTax).Abs()
        if diff.GreaterThan(decimal.NewFromInt(1)) {
            errors = append(errors, ValidationError{
                Field:   "tax_amount",
                Message: fmt.Sprintf("세액이 맞지 않음: 예상 %s, 실제 %s", expectedTax.String(), invoice.TaxAmount.String()),
            })
        }
    }

    // Validate total
    expectedTotal := invoice.SupplyAmount.Add(invoice.TaxAmount)
    if !invoice.TotalAmount.Equal(expectedTotal) {
        errors = append(errors, ValidationError{
            Field:   "total_amount",
            Message: "합계금액 불일치",
        })
    }

    return errors
}

func (v *TaxInvoiceValidator) validateBRN(brn string) bool {
    // Business Registration Number validation
    // Format: XXX-XX-XXXXX (10 digits)
    cleaned := regexp.MustCompile(`[^0-9]`).ReplaceAllString(brn, "")
    if len(cleaned) != 10 {
        return false
    }

    // Checksum validation
    weights := []int{1, 3, 7, 1, 3, 7, 1, 3, 5}
    sum := 0
    for i := 0; i < 9; i++ {
        digit := int(cleaned[i] - '0')
        sum += digit * weights[i]
    }
    sum += int(cleaned[8]-'0') * 5 / 10

    checkDigit := (10 - (sum % 10)) % 10
    lastDigit := int(cleaned[9] - '0')

    return checkDigit == lastDigit
}

func (v *TaxInvoiceValidator) validateIssueDate(issueDate, supplyDate time.Time) *ValidationError {
    // Issue date must be within supply month + 10 days of next month
    supplyMonth := time.Date(supplyDate.Year(), supplyDate.Month(), 1, 0, 0, 0, 0, supplyDate.Location())
    deadline := supplyMonth.AddDate(0, 1, 10) // Next month 10th

    if issueDate.After(deadline) {
        return &ValidationError{
            Field:   "issue_date",
            Message: fmt.Sprintf("작성일자가 법정기한(%s)을 초과", deadline.Format("2006-01-02")),
        }
    }

    return nil
}
```

### 5.2 증빙 보존

```go
// internal/compliance/tax/evidence_storage.go
package tax

import (
    "context"
    "crypto/sha256"
    "encoding/hex"
    "time"
)

type EvidenceType string

const (
    EvidenceTypeTaxInvoice      EvidenceType = "tax_invoice"       // 세금계산서
    EvidenceTypeCashReceipt     EvidenceType = "cash_receipt"      // 현금영수증
    EvidenceTypeCreditCard      EvidenceType = "credit_card"       // 신용카드
    EvidenceTypeBankStatement   EvidenceType = "bank_statement"    // 통장사본
    EvidenceTypeContract        EvidenceType = "contract"          // 계약서
    EvidenceTypeDeliveryNote    EvidenceType = "delivery_note"     // 납품서
)

type Evidence struct {
    ID           uuid.UUID
    CompanyID    uuid.UUID
    VoucherID    *uuid.UUID
    Type         EvidenceType
    DocumentNo   string
    IssueDate    time.Time
    Amount       decimal.Decimal
    Description  string
    FilePath     string
    FileHash     string // SHA-256
    RetainUntil  time.Time
    Status       string
    CreatedAt    time.Time
    CreatedBy    uuid.UUID
}

type EvidenceStorageService struct {
    repo      EvidenceRepository
    storage   FileStorage
    encryptor Encryptor
    logger    *slog.Logger
}

// StoreEvidence stores a document with compliance requirements
func (s *EvidenceStorageService) StoreEvidence(ctx context.Context, req StoreEvidenceRequest) (*Evidence, error) {
    // Calculate file hash for integrity
    hash := sha256.Sum256(req.FileContent)
    fileHash := hex.EncodeToString(hash[:])

    // Encrypt file content
    encryptedContent, err := s.encryptor.Encrypt(req.FileContent)
    if err != nil {
        return nil, fmt.Errorf("failed to encrypt evidence: %w", err)
    }

    // Generate storage path
    storagePath := s.generateStoragePath(req.CompanyID, req.Type, req.IssueDate)

    // Store encrypted file
    if err := s.storage.Store(ctx, storagePath, encryptedContent); err != nil {
        return nil, fmt.Errorf("failed to store evidence: %w", err)
    }

    // Calculate retention period based on type
    retainUntil := s.calculateRetention(req.Type, req.IssueDate)

    evidence := &Evidence{
        ID:          uuid.New(),
        CompanyID:   req.CompanyID,
        VoucherID:   req.VoucherID,
        Type:        req.Type,
        DocumentNo:  req.DocumentNo,
        IssueDate:   req.IssueDate,
        Amount:      req.Amount,
        Description: req.Description,
        FilePath:    storagePath,
        FileHash:    fileHash,
        RetainUntil: retainUntil,
        Status:      "active",
        CreatedAt:   time.Now(),
        CreatedBy:   req.UserID,
    }

    if err := s.repo.Save(ctx, evidence); err != nil {
        return nil, fmt.Errorf("failed to save evidence metadata: %w", err)
    }

    s.logger.Info("evidence stored",
        slog.String("id", evidence.ID.String()),
        slog.String("type", string(evidence.Type)),
        slog.String("retain_until", evidence.RetainUntil.Format("2006-01-02")),
    )

    return evidence, nil
}

func (s *EvidenceStorageService) calculateRetention(evidenceType EvidenceType, issueDate time.Time) time.Time {
    // Retention periods per tax regulations
    retentionYears := map[EvidenceType]int{
        EvidenceTypeTaxInvoice:    10, // 부가가치세법
        EvidenceTypeCashReceipt:   10,
        EvidenceTypeCreditCard:    10,
        EvidenceTypeBankStatement: 10,
        EvidenceTypeContract:      10,
        EvidenceTypeDeliveryNote:  5,
    }

    years := retentionYears[evidenceType]
    if years == 0 {
        years = 10 // Default
    }

    return issueDate.AddDate(years, 0, 0)
}

// VerifyIntegrity verifies stored evidence integrity
func (s *EvidenceStorageService) VerifyIntegrity(ctx context.Context, evidenceID uuid.UUID) (*IntegrityCheckResult, error) {
    evidence, err := s.repo.FindByID(ctx, evidenceID)
    if err != nil {
        return nil, err
    }

    // Retrieve and decrypt file
    encryptedContent, err := s.storage.Retrieve(ctx, evidence.FilePath)
    if err != nil {
        return &IntegrityCheckResult{
            Valid:  false,
            Error:  "file not found",
        }, nil
    }

    decryptedContent, err := s.encryptor.Decrypt(encryptedContent)
    if err != nil {
        return &IntegrityCheckResult{
            Valid: false,
            Error: "decryption failed",
        }, nil
    }

    // Verify hash
    currentHash := sha256.Sum256(decryptedContent)
    currentHashStr := hex.EncodeToString(currentHash[:])

    if currentHashStr != evidence.FileHash {
        return &IntegrityCheckResult{
            Valid:        false,
            Error:        "hash mismatch - file may have been tampered",
            ExpectedHash: evidence.FileHash,
            ActualHash:   currentHashStr,
        }, nil
    }

    return &IntegrityCheckResult{
        Valid:      true,
        VerifiedAt: time.Now(),
    }, nil
}
```

---

## 6. 4대보험 규정 준수

### 6.1 신고 규정

```go
// internal/compliance/insurance/reporter.go
package insurance

import "time"

type InsuranceType string

const (
    InsuranceTypeNationalPension InsuranceType = "national_pension"  // 국민연금
    InsuranceTypeHealthInsurance InsuranceType = "health_insurance"  // 건강보험
    InsuranceTypeEmployment      InsuranceType = "employment"        // 고용보험
    InsuranceTypeIndustrial      InsuranceType = "industrial"        // 산재보험
)

type ReportType string

const (
    ReportTypeAcquisition ReportType = "acquisition" // 취득
    ReportTypeLoss        ReportType = "loss"        // 상실
    ReportTypeChange      ReportType = "change"      // 변경
    ReportTypeMonthly     ReportType = "monthly"     // 월별 신고
)

// InsuranceReportDeadline defines reporting deadlines
type InsuranceReportDeadline struct {
    InsuranceType InsuranceType
    ReportType    ReportType
    Deadline      string // e.g., "14일 이내", "다음달 15일"
    Description   string
}

var InsuranceDeadlines = []InsuranceReportDeadline{
    // 국민연금
    {InsuranceTypeNationalPension, ReportTypeAcquisition, "14일 이내", "취득일로부터 14일"},
    {InsuranceTypeNationalPension, ReportTypeLoss, "14일 이내", "상실일로부터 14일"},
    {InsuranceTypeNationalPension, ReportTypeChange, "14일 이내", "변경일로부터 14일"},

    // 건강보험
    {InsuranceTypeHealthInsurance, ReportTypeAcquisition, "14일 이내", "취득일로부터 14일"},
    {InsuranceTypeHealthInsurance, ReportTypeLoss, "14일 이내", "상실일로부터 14일"},

    // 고용보험
    {InsuranceTypeEmployment, ReportTypeAcquisition, "다음달 15일", "취득월 다음달 15일"},
    {InsuranceTypeEmployment, ReportTypeLoss, "피보험자격상실일 다음달 15일", ""},

    // 산재보험
    {InsuranceTypeIndustrial, ReportTypeMonthly, "매월 10일", "전월분 보험료"},
}

type InsuranceReportChecker struct {
    employeeRepo EmployeeRepository
    reportRepo   InsuranceReportRepository
}

// CheckPendingReports checks for pending insurance reports
func (c *InsuranceReportChecker) CheckPendingReports(ctx context.Context, companyID uuid.UUID) ([]PendingReport, error) {
    var pending []PendingReport

    // Check for new hires needing acquisition report
    newHires, err := c.employeeRepo.FindNewHires(ctx, companyID, time.Now().AddDate(0, 0, -14))
    if err != nil {
        return nil, err
    }

    for _, emp := range newHires {
        // Check each insurance type
        for _, insType := range []InsuranceType{
            InsuranceTypeNationalPension,
            InsuranceTypeHealthInsurance,
            InsuranceTypeEmployment,
            InsuranceTypeIndustrial,
        } {
            reported, err := c.reportRepo.IsReported(ctx, emp.ID, insType, ReportTypeAcquisition)
            if err != nil {
                return nil, err
            }

            if !reported {
                deadline := c.calculateDeadline(insType, ReportTypeAcquisition, emp.HireDate)
                pending = append(pending, PendingReport{
                    EmployeeID:    emp.ID,
                    EmployeeName:  emp.Name,
                    InsuranceType: insType,
                    ReportType:    ReportTypeAcquisition,
                    EventDate:     emp.HireDate,
                    Deadline:      deadline,
                    IsOverdue:     time.Now().After(deadline),
                })
            }
        }
    }

    // Check for terminations needing loss report
    terminations, err := c.employeeRepo.FindTerminations(ctx, companyID, time.Now().AddDate(0, 0, -14))
    if err != nil {
        return nil, err
    }

    for _, emp := range terminations {
        for _, insType := range []InsuranceType{
            InsuranceTypeNationalPension,
            InsuranceTypeHealthInsurance,
            InsuranceTypeEmployment,
        } {
            reported, err := c.reportRepo.IsReported(ctx, emp.ID, insType, ReportTypeLoss)
            if err != nil {
                return nil, err
            }

            if !reported {
                deadline := c.calculateDeadline(insType, ReportTypeLoss, emp.TerminationDate)
                pending = append(pending, PendingReport{
                    EmployeeID:    emp.ID,
                    EmployeeName:  emp.Name,
                    InsuranceType: insType,
                    ReportType:    ReportTypeLoss,
                    EventDate:     emp.TerminationDate,
                    Deadline:      deadline,
                    IsOverdue:     time.Now().After(deadline),
                })
            }
        }
    }

    return pending, nil
}

func (c *InsuranceReportChecker) calculateDeadline(insType InsuranceType, reportType ReportType, eventDate time.Time) time.Time {
    switch insType {
    case InsuranceTypeNationalPension, InsuranceTypeHealthInsurance:
        return eventDate.AddDate(0, 0, 14)
    case InsuranceTypeEmployment:
        if reportType == ReportTypeAcquisition {
            // Next month 15th
            return time.Date(eventDate.Year(), eventDate.Month()+1, 15, 0, 0, 0, 0, eventDate.Location())
        }
        return time.Date(eventDate.Year(), eventDate.Month()+1, 15, 0, 0, 0, 0, eventDate.Location())
    case InsuranceTypeIndustrial:
        return time.Date(eventDate.Year(), eventDate.Month()+1, 10, 0, 0, 0, 0, eventDate.Location())
    }
    return eventDate.AddDate(0, 0, 14)
}
```

### 6.2 EDI 연동 검증

```python
# python/insurance_edi/validator.py

from dataclasses import dataclass
from datetime import date
from decimal import Decimal
from typing import List, Optional
import re

@dataclass
class EDIValidationError:
    field: str
    code: str
    message: str

class EDIValidator:
    """Validates EDI messages for 4 insurances."""

    def validate_acquisition_report(
        self,
        report: "AcquisitionReport"
    ) -> List[EDIValidationError]:
        errors = []

        # Validate employee ID (resident registration number)
        if not self._validate_rrn(report.resident_reg_no):
            errors.append(EDIValidationError(
                field="resident_reg_no",
                code="INVALID_RRN",
                message="주민등록번호 형식이 올바르지 않습니다"
            ))

        # Validate business registration number
        if not self._validate_brn(report.business_reg_no):
            errors.append(EDIValidationError(
                field="business_reg_no",
                code="INVALID_BRN",
                message="사업자등록번호 형식이 올바르지 않습니다"
            ))

        # Validate acquisition date
        if report.acquisition_date > date.today():
            errors.append(EDIValidationError(
                field="acquisition_date",
                code="FUTURE_DATE",
                message="취득일자가 미래 날짜입니다"
            ))

        # Validate salary
        if report.monthly_salary <= 0:
            errors.append(EDIValidationError(
                field="monthly_salary",
                code="INVALID_SALARY",
                message="월보수액은 0보다 커야 합니다"
            ))

        # Validate job type code
        if not self._validate_job_code(report.job_type_code):
            errors.append(EDIValidationError(
                field="job_type_code",
                code="INVALID_JOB_CODE",
                message="직종코드가 유효하지 않습니다"
            ))

        return errors

    def _validate_rrn(self, rrn: str) -> bool:
        """Validate resident registration number."""
        cleaned = re.sub(r"[^0-9]", "", rrn)
        if len(cleaned) != 13:
            return False

        # Checksum validation
        weights = [2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5]
        total = sum(int(cleaned[i]) * weights[i] for i in range(12))
        check = (11 - (total % 11)) % 10

        return check == int(cleaned[12])

    def _validate_brn(self, brn: str) -> bool:
        """Validate business registration number."""
        cleaned = re.sub(r"[^0-9]", "", brn)
        if len(cleaned) != 10:
            return False

        weights = [1, 3, 7, 1, 3, 7, 1, 3, 5]
        total = sum(int(cleaned[i]) * weights[i] for i in range(9))
        total += int(cleaned[8]) * 5 // 10
        check = (10 - (total % 10)) % 10

        return check == int(cleaned[9])

    def _validate_job_code(self, code: str) -> bool:
        """Validate job type code against standard codes."""
        # Standard job codes from Employment Insurance
        valid_codes = {"10", "11", "12", "20", "21", "22", "30", "40", "50"}
        return code in valid_codes


class EDIMessageBuilder:
    """Builds EDI messages in required format."""

    def build_acquisition_message(
        self,
        reports: List["AcquisitionReport"],
        sender_info: "SenderInfo"
    ) -> bytes:
        """Build EDI acquisition message in fixed-width format."""
        lines = []

        # Header record
        header = self._build_header(sender_info, len(reports))
        lines.append(header)

        # Data records
        for report in reports:
            data = self._build_data_record(report)
            lines.append(data)

        # Trailer record
        trailer = self._build_trailer(len(reports))
        lines.append(trailer)

        # Join with CRLF and encode as EUC-KR
        content = "\r\n".join(lines)
        return content.encode("euc-kr")

    def _build_header(self, sender: "SenderInfo", count: int) -> str:
        """Build header record."""
        # Fixed-width format: Record type (2) + Sender BRN (10) + ...
        return (
            f"HD"  # Record type
            f"{sender.business_reg_no:10}"
            f"{sender.workplace_code:7}"
            f"{date.today().strftime('%Y%m%d')}"
            f"{count:05d}"
            f"{' ' * 50}"  # Padding
        )

    def _build_data_record(self, report: "AcquisitionReport") -> str:
        """Build data record."""
        return (
            f"DA"
            f"{report.resident_reg_no.replace('-', ''):13}"
            f"{report.employee_name:30}"
            f"{report.acquisition_date.strftime('%Y%m%d')}"
            f"{int(report.monthly_salary):012d}"
            f"{report.job_type_code:2}"
            # ... more fields
        )

    def _build_trailer(self, count: int) -> str:
        """Build trailer record."""
        return f"TR{count:05d}{' ' * 70}"
```

---

## 7. 감사 및 로깅

### 7.1 감사 로그 구조

```go
// internal/compliance/audit/logger.go
package audit

import (
    "context"
    "time"

    "github.com/google/uuid"
)

type AuditEventType string

const (
    // Authentication events
    AuditEventLogin          AuditEventType = "AUTH_LOGIN"
    AuditEventLogout         AuditEventType = "AUTH_LOGOUT"
    AuditEventLoginFailed    AuditEventType = "AUTH_LOGIN_FAILED"
    AuditEventPasswordChange AuditEventType = "AUTH_PASSWORD_CHANGE"
    AuditEventMFASetup       AuditEventType = "AUTH_MFA_SETUP"

    // Data access events
    AuditEventDataRead   AuditEventType = "DATA_READ"
    AuditEventDataCreate AuditEventType = "DATA_CREATE"
    AuditEventDataUpdate AuditEventType = "DATA_UPDATE"
    AuditEventDataDelete AuditEventType = "DATA_DELETE"
    AuditEventDataExport AuditEventType = "DATA_EXPORT"

    // Financial events
    AuditEventVoucherPost   AuditEventType = "FIN_VOUCHER_POST"
    AuditEventVoucherCancel AuditEventType = "FIN_VOUCHER_CANCEL"
    AuditEventTaxInvoice    AuditEventType = "FIN_TAX_INVOICE"
    AuditEventPayroll       AuditEventType = "FIN_PAYROLL"
    AuditEventBankTransfer  AuditEventType = "FIN_BANK_TRANSFER"

    // System events
    AuditEventConfigChange  AuditEventType = "SYS_CONFIG_CHANGE"
    AuditEventPermissionChange AuditEventType = "SYS_PERMISSION_CHANGE"
    AuditEventBackupRestore AuditEventType = "SYS_BACKUP_RESTORE"
)

type AuditSeverity string

const (
    SeverityInfo    AuditSeverity = "INFO"
    SeverityWarning AuditSeverity = "WARNING"
    SeverityError   AuditSeverity = "ERROR"
    SeverityCritical AuditSeverity = "CRITICAL"
)

type AuditLog struct {
    ID           uuid.UUID              `json:"id"`
    Timestamp    time.Time              `json:"timestamp"`
    EventType    AuditEventType         `json:"event_type"`
    Severity     AuditSeverity          `json:"severity"`
    CompanyID    uuid.UUID              `json:"company_id"`
    UserID       uuid.UUID              `json:"user_id"`
    UserEmail    string                 `json:"user_email"`
    SessionID    string                 `json:"session_id"`
    IPAddress    string                 `json:"ip_address"`
    UserAgent    string                 `json:"user_agent"`
    Resource     string                 `json:"resource"`
    ResourceID   string                 `json:"resource_id,omitempty"`
    Action       string                 `json:"action"`
    Description  string                 `json:"description"`
    OldValue     map[string]interface{} `json:"old_value,omitempty"`
    NewValue     map[string]interface{} `json:"new_value,omitempty"`
    Result       string                 `json:"result"` // "success" or "failure"
    ErrorMessage string                 `json:"error_message,omitempty"`
    Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

type AuditLogger struct {
    repo    AuditLogRepository
    masker  *pii.Masker
    queue   MessageQueue
}

func (l *AuditLogger) Log(ctx context.Context, event *AuditLog) error {
    event.ID = uuid.New()
    event.Timestamp = time.Now()

    // Mask PII in old/new values
    if event.OldValue != nil {
        event.OldValue = l.maskSensitiveData(event.OldValue)
    }
    if event.NewValue != nil {
        event.NewValue = l.maskSensitiveData(event.NewValue)
    }

    // Save to database
    if err := l.repo.Save(ctx, event); err != nil {
        return fmt.Errorf("failed to save audit log: %w", err)
    }

    // Send to audit queue for real-time monitoring
    if event.Severity == SeverityCritical || event.Severity == SeverityError {
        l.queue.Publish("audit.alerts", event)
    }

    return nil
}

func (l *AuditLogger) maskSensitiveData(data map[string]interface{}) map[string]interface{} {
    masked := make(map[string]interface{})
    sensitiveFields := []string{"password", "token", "secret", "rrn", "account_number"}

    for key, value := range data {
        isSensitive := false
        for _, field := range sensitiveFields {
            if strings.Contains(strings.ToLower(key), field) {
                isSensitive = true
                break
            }
        }

        if isSensitive {
            masked[key] = "[REDACTED]"
        } else {
            masked[key] = value
        }
    }

    return masked
}

// LogFinancialOperation logs financial operations with required details
func (l *AuditLogger) LogFinancialOperation(ctx context.Context, op FinancialOperation) error {
    event := &AuditLog{
        EventType:   op.EventType,
        Severity:    SeverityWarning, // All financial ops are at least warning
        CompanyID:   op.CompanyID,
        UserID:      op.UserID,
        Resource:    op.Resource,
        ResourceID:  op.ResourceID,
        Action:      op.Action,
        Description: op.Description,
        OldValue:    op.OldValue,
        NewValue:    op.NewValue,
        Result:      op.Result,
        Metadata: map[string]interface{}{
            "amount":       op.Amount.String(),
            "currency":     "KRW",
            "approval_id":  op.ApprovalID,
            "related_docs": op.RelatedDocs,
        },
    }

    // Extract context info
    if info, ok := ctx.Value(contextKeyAuditInfo).(*AuditInfo); ok {
        event.UserEmail = info.UserEmail
        event.SessionID = info.SessionID
        event.IPAddress = info.IPAddress
        event.UserAgent = info.UserAgent
    }

    return l.Log(ctx, event)
}
```

### 7.2 감사 보고서

```go
// internal/compliance/audit/reporter.go
package audit

import (
    "context"
    "time"
)

type AuditReporter struct {
    repo AuditLogRepository
}

type AuditReport struct {
    GeneratedAt  time.Time
    ReportPeriod DateRange
    Company      CompanyInfo
    Summary      AuditSummary
    Details      []AuditDetail
}

type AuditSummary struct {
    TotalEvents       int
    EventsByType      map[AuditEventType]int
    EventsBySeverity  map[AuditSeverity]int
    UniqueUsers       int
    FailedOperations  int
    SuspiciousEvents  int
}

// GenerateComplianceReport generates audit report for compliance review
func (r *AuditReporter) GenerateComplianceReport(
    ctx context.Context,
    companyID uuid.UUID,
    startDate, endDate time.Time,
) (*AuditReport, error) {
    logs, err := r.repo.FindByDateRange(ctx, companyID, startDate, endDate)
    if err != nil {
        return nil, err
    }

    report := &AuditReport{
        GeneratedAt: time.Now(),
        ReportPeriod: DateRange{
            Start: startDate,
            End:   endDate,
        },
        Summary: AuditSummary{
            EventsByType:     make(map[AuditEventType]int),
            EventsBySeverity: make(map[AuditSeverity]int),
        },
    }

    uniqueUsers := make(map[uuid.UUID]bool)

    for _, log := range logs {
        report.Summary.TotalEvents++
        report.Summary.EventsByType[log.EventType]++
        report.Summary.EventsBySeverity[log.Severity]++
        uniqueUsers[log.UserID] = true

        if log.Result == "failure" {
            report.Summary.FailedOperations++
        }

        // Flag suspicious events
        if r.isSuspicious(log) {
            report.Summary.SuspiciousEvents++
        }

        report.Details = append(report.Details, AuditDetail{
            Timestamp:   log.Timestamp,
            EventType:   log.EventType,
            UserEmail:   log.UserEmail,
            Resource:    log.Resource,
            Action:      log.Action,
            Result:      log.Result,
            Description: log.Description,
        })
    }

    report.Summary.UniqueUsers = len(uniqueUsers)

    return report, nil
}

func (r *AuditReporter) isSuspicious(log *AuditLog) bool {
    // Define suspicious patterns
    suspiciousPatterns := []func(*AuditLog) bool{
        // Multiple failed logins
        func(l *AuditLog) bool {
            return l.EventType == AuditEventLoginFailed
        },
        // Off-hours access to financial data
        func(l *AuditLog) bool {
            hour := l.Timestamp.Hour()
            isOffHours := hour < 6 || hour > 22
            isFinancial := strings.HasPrefix(string(l.EventType), "FIN_")
            return isOffHours && isFinancial
        },
        // Bulk data export
        func(l *AuditLog) bool {
            return l.EventType == AuditEventDataExport
        },
        // Permission changes
        func(l *AuditLog) bool {
            return l.EventType == AuditEventPermissionChange
        },
    }

    for _, check := range suspiciousPatterns {
        if check(log) {
            return true
        }
    }

    return false
}
```

---

## 8. 규정준수 체크리스트

### 8.1 정기 점검 체크리스트

```yaml
# docs/compliance/checklist.yaml

compliance_checklist:
  daily:
    - id: "D001"
      category: "데이터 백업"
      description: "일일 데이터 백업 완료 확인"
      responsible: "DevOps"

    - id: "D002"
      category: "로그 모니터링"
      description: "보안 이벤트 로그 검토"
      responsible: "Security"

    - id: "D003"
      category: "시스템 가용성"
      description: "서비스 가용성 99.9% 이상 확인"
      responsible: "DevOps"

  weekly:
    - id: "W001"
      category: "접근권한"
      description: "비활성 계정 검토 및 비활성화"
      responsible: "Admin"

    - id: "W002"
      category: "보안 패치"
      description: "보안 취약점 스캔 및 패치"
      responsible: "Security"

    - id: "W003"
      category: "4대보험"
      description: "미신고 건 확인 및 처리"
      responsible: "HR"

  monthly:
    - id: "M001"
      category: "개인정보"
      description: "개인정보 처리 현황 점검"
      responsible: "Privacy Officer"

    - id: "M002"
      category: "세금계산서"
      description: "세금계산서 발행 현황 점검"
      responsible: "Finance"

    - id: "M003"
      category: "감사 로그"
      description: "감사 로그 검토 및 분석"
      responsible: "Compliance"

    - id: "M004"
      category: "데이터 보존"
      description: "보존기간 만료 데이터 파기"
      responsible: "Admin"

  quarterly:
    - id: "Q001"
      category: "취약점 진단"
      description: "인프라 취약점 진단 수행"
      responsible: "Security"

    - id: "Q002"
      category: "권한 검토"
      description: "전체 사용자 권한 검토"
      responsible: "Admin"

    - id: "Q003"
      category: "재해복구"
      description: "DR 테스트 수행"
      responsible: "DevOps"

    - id: "Q004"
      category: "개인정보 영향평가"
      description: "개인정보 영향평가 수행"
      responsible: "Privacy Officer"

  annually:
    - id: "A001"
      category: "정보보호"
      description: "정보보호 관리체계 인증 갱신"
      responsible: "CISO"

    - id: "A002"
      category: "감사"
      description: "외부 감사 대응"
      responsible: "Compliance"

    - id: "A003"
      category: "교육"
      description: "전 직원 보안 교육 실시"
      responsible: "HR"

    - id: "A004"
      category: "정책 검토"
      description: "개인정보처리방침 검토/갱신"
      responsible: "Legal"
```

### 8.2 규정준수 대시보드

```typescript
// web/src/app/compliance/dashboard/page.tsx
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';

interface ComplianceStatus {
  category: string;
  status: 'compliant' | 'warning' | 'non-compliant';
  score: number;
  lastChecked: string;
  issues: number;
}

const complianceData: ComplianceStatus[] = [
  {
    category: '개인정보보호법',
    status: 'compliant',
    score: 95,
    lastChecked: '2024-01-15',
    issues: 2,
  },
  {
    category: '전자금융거래법',
    status: 'compliant',
    score: 98,
    lastChecked: '2024-01-14',
    issues: 1,
  },
  {
    category: 'K-IFRS 회계기준',
    status: 'compliant',
    score: 100,
    lastChecked: '2024-01-15',
    issues: 0,
  },
  {
    category: '세무 규정',
    status: 'warning',
    score: 85,
    lastChecked: '2024-01-15',
    issues: 5,
  },
  {
    category: '4대보험',
    status: 'compliant',
    score: 92,
    lastChecked: '2024-01-14',
    issues: 3,
  },
];

export default function ComplianceDashboard() {
  const overallScore = Math.round(
    complianceData.reduce((sum, item) => sum + item.score, 0) / complianceData.length
  );

  const totalIssues = complianceData.reduce((sum, item) => sum + item.issues, 0);

  return (
    <div className="container mx-auto py-8 space-y-8">
      <h1 className="text-3xl font-bold">규정준수 대시보드</h1>

      {/* Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm text-muted-foreground">
              전체 준수율
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold">{overallScore}%</div>
            <Progress value={overallScore} className="mt-2" />
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="text-sm text-muted-foreground">
              미해결 이슈
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold">{totalIssues}</div>
            <p className="text-sm text-muted-foreground mt-1">
              {totalIssues > 0 ? '조치 필요' : '모든 이슈 해결됨'}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="text-sm text-muted-foreground">
              다음 감사
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold">32일</div>
            <p className="text-sm text-muted-foreground mt-1">
              2024년 분기 감사
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Compliance Status */}
      <Card>
        <CardHeader>
          <CardTitle>규정별 준수 현황</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {complianceData.map((item) => (
              <div
                key={item.category}
                className="flex items-center justify-between py-3 border-b last:border-0"
              >
                <div className="flex items-center gap-4">
                  <StatusBadge status={item.status} />
                  <div>
                    <p className="font-medium">{item.category}</p>
                    <p className="text-sm text-muted-foreground">
                      마지막 점검: {item.lastChecked}
                    </p>
                  </div>
                </div>
                <div className="flex items-center gap-6">
                  <div className="text-right">
                    <p className="font-medium">{item.score}%</p>
                    <p className="text-sm text-muted-foreground">
                      {item.issues}건 이슈
                    </p>
                  </div>
                  <Progress value={item.score} className="w-24" />
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

function StatusBadge({ status }: { status: ComplianceStatus['status'] }) {
  const config = {
    compliant: { label: '준수', className: 'bg-green-100 text-green-800' },
    warning: { label: '주의', className: 'bg-yellow-100 text-yellow-800' },
    'non-compliant': { label: '미준수', className: 'bg-red-100 text-red-800' },
  };

  return (
    <Badge className={config[status].className}>
      {config[status].label}
    </Badge>
  );
}
```

---

## 버전 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 0.2 | 2024-01-15 | Compliance Team | Go+Python 하이브리드 아키텍처 반영 |
| 0.1 | 2024-01-01 | Compliance Team | 초안 작성 |
