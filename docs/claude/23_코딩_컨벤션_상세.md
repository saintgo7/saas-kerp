# 23. 코딩 컨벤션 상세

## 목차
1. [개요](#1-개요)
2. [Go 코딩 컨벤션](#2-go-코딩-컨벤션)
3. [Python 코딩 컨벤션](#3-python-코딩-컨벤션)
4. [TypeScript/React 컨벤션](#4-typescriptreact-컨벤션)
5. [SQL 작성 규칙](#5-sql-작성-규칙)
6. [API 설계 규칙](#6-api-설계-규칙)
7. [Git 컨벤션](#7-git-컨벤션)
8. [코드 리뷰 체크리스트](#8-코드-리뷰-체크리스트)

---

## 1. 개요

### 1.1 목적

```yaml
coding_convention_goals:
  consistency:
    description: "팀 전체 일관된 코드 스타일 유지"
    benefit: "가독성 향상 및 유지보수 용이"

  quality:
    description: "고품질 코드 작성 가이드라인"
    benefit: "버그 감소 및 안정성 향상"

  efficiency:
    description: "코드 리뷰 시간 단축"
    benefit: "개발 생산성 향상"

language_distribution:
  go: "90% - API, 비즈니스 로직, 데이터베이스"
  python: "10% - 암호화, 스크래핑, EDI 처리"
  typescript: "프론트엔드 UI"
  sql: "데이터베이스 쿼리"
```

### 1.2 도구 설정

```yaml
# .tool-versions (asdf)
golang 1.22.0
python 3.11.0
nodejs 20.11.0
```

---

## 2. Go 코딩 컨벤션

### 2.1 프로젝트 구조

```
internal/
├── domain/           # 도메인 모델 (순수 Go 구조체)
│   ├── voucher.go
│   ├── account.go
│   └── errors.go
├── dto/              # 데이터 전송 객체
│   ├── request/
│   └── response/
├── repository/       # 데이터 접근 계층
│   ├── interface.go  # 인터페이스 정의
│   ├── voucher_repo.go
│   └── voucher_repo_test.go
├── service/          # 비즈니스 로직
│   ├── voucher_service.go
│   └── voucher_service_test.go
├── handler/          # HTTP 핸들러
│   ├── voucher_handler.go
│   └── voucher_handler_test.go
└── middleware/       # HTTP 미들웨어
    ├── auth.go
    ├── tenant.go
    └── logging.go
```

### 2.2 네이밍 컨벤션

```go
// Package names: lowercase, single word
package voucher
package taxinvoice

// Interface names: verb or adjective + noun
type VoucherRepository interface {}
type Validator interface {}
type Readable interface {}

// Struct names: noun
type Voucher struct {}
type VoucherService struct {}

// Function/Method names: verb + noun (exported = PascalCase)
func (s *VoucherService) CreateVoucher(ctx context.Context, req *CreateVoucherRequest) error
func (s *VoucherService) validateBalance(voucher *domain.Voucher) error // unexported

// Variable names: camelCase
var voucherCount int
var maxRetryAttempts = 3

// Constants: PascalCase for exported, camelCase for unexported
const MaxVoucherLines = 1000
const defaultTimeout = 30 * time.Second

// Errors: Err prefix
var ErrVoucherNotFound = errors.New("voucher not found")
var ErrInvalidBalance = errors.New("debit and credit must be equal")

// Context keys: custom type
type contextKey string
const (
    ContextKeyTenantID contextKey = "tenant_id"
    ContextKeyUserID   contextKey = "user_id"
)
```

### 2.3 함수 시그니처 규칙

```go
// Rule 1: Context is always the first parameter
func (s *Service) ProcessVoucher(ctx context.Context, id uuid.UUID) error

// Rule 2: Options pattern for many parameters
type CreateVoucherOptions struct {
    Description string
    Reference   string
    PostedDate  time.Time
    Lines       []VoucherLineInput
}

func (s *Service) CreateVoucher(ctx context.Context, opts CreateVoucherOptions) (*domain.Voucher, error)

// Rule 3: Return error as last return value
func (s *Service) GetVoucher(ctx context.Context, id uuid.UUID) (*domain.Voucher, error)

// Rule 4: Use pointers for large structs or when mutation is needed
func (s *Service) UpdateVoucher(ctx context.Context, voucher *domain.Voucher) error

// Rule 5: Return concrete types, accept interfaces
type VoucherReader interface {
    FindByID(ctx context.Context, id uuid.UUID) (*domain.Voucher, error)
}

func NewVoucherService(repo VoucherReader) *VoucherService {
    return &VoucherService{repo: repo}
}
```

### 2.4 에러 처리

```go
package errors

import (
    "errors"
    "fmt"
)

// Domain errors
var (
    ErrNotFound       = errors.New("resource not found")
    ErrUnauthorized   = errors.New("unauthorized")
    ErrForbidden      = errors.New("forbidden")
    ErrValidation     = errors.New("validation error")
    ErrConflict       = errors.New("conflict")
    ErrInternal       = errors.New("internal error")
)

// AppError with context
type AppError struct {
    Op      string // operation name
    Code    string // error code for clients
    Err     error  // underlying error
    Message string // user-facing message
}

func (e *AppError) Error() string {
    if e.Message != "" {
        return e.Message
    }
    return e.Err.Error()
}

func (e *AppError) Unwrap() error {
    return e.Err
}

// Error wrapping helper
func Wrap(op string, err error, message string) *AppError {
    return &AppError{
        Op:      op,
        Err:     err,
        Message: message,
    }
}

// Usage in service
func (s *VoucherService) GetVoucher(ctx context.Context, id uuid.UUID) (*domain.Voucher, error) {
    const op = "VoucherService.GetVoucher"

    voucher, err := s.repo.FindByID(ctx, id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, errors.Wrap(op, ErrNotFound, "voucher not found")
        }
        return nil, errors.Wrap(op, err, "failed to get voucher")
    }

    return voucher, nil
}

// Error checking in handler
func (h *VoucherHandler) GetVoucher(c *gin.Context) {
    voucher, err := h.service.GetVoucher(c.Request.Context(), id)
    if err != nil {
        switch {
        case errors.Is(err, errors.ErrNotFound):
            c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        case errors.Is(err, errors.ErrUnauthorized):
            c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
        default:
            c.JSON(http.StatusInternalServerError, gin.H{"error": "internal error"})
        }
        return
    }
    c.JSON(http.StatusOK, voucher)
}
```

### 2.5 구조체 및 태그

```go
// Domain model - no tags (pure Go)
type Voucher struct {
    ID          uuid.UUID
    CompanyID   uuid.UUID
    VoucherNo   string
    VoucherDate time.Time
    Description string
    Status      VoucherStatus
    Lines       []VoucherLine
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

// DTO for API request
type CreateVoucherRequest struct {
    VoucherDate time.Time            `json:"voucher_date" binding:"required"`
    Description string               `json:"description" binding:"max=500"`
    Lines       []VoucherLineRequest `json:"lines" binding:"required,min=1,dive"`
}

type VoucherLineRequest struct {
    AccountCode string  `json:"account_code" binding:"required,len=6"`
    DebitAmt    float64 `json:"debit_amt" binding:"min=0"`
    CreditAmt   float64 `json:"credit_amt" binding:"min=0"`
    Description string  `json:"description" binding:"max=200"`
}

// DTO for API response
type VoucherResponse struct {
    ID          uuid.UUID             `json:"id"`
    VoucherNo   string                `json:"voucher_no"`
    VoucherDate string                `json:"voucher_date"`
    Description string                `json:"description"`
    Status      string                `json:"status"`
    TotalDebit  string                `json:"total_debit"`
    TotalCredit string                `json:"total_credit"`
    Lines       []VoucherLineResponse `json:"lines"`
    CreatedAt   string                `json:"created_at"`
}

// GORM model
type VoucherModel struct {
    ID          uuid.UUID `gorm:"type:uuid;primaryKey;default:gen_random_uuid()"`
    CompanyID   uuid.UUID `gorm:"type:uuid;not null;index"`
    VoucherNo   string    `gorm:"type:varchar(20);not null;index"`
    VoucherDate time.Time `gorm:"type:date;not null;index"`
    Description string    `gorm:"type:varchar(500)"`
    Status      string    `gorm:"type:varchar(20);not null;default:'draft'"`
    CreatedAt   time.Time `gorm:"autoCreateTime"`
    UpdatedAt   time.Time `gorm:"autoUpdateTime"`
}

func (VoucherModel) TableName() string {
    return "vouchers"
}
```

### 2.6 인터페이스 정의

```go
// Rule: Define interfaces where they are used (consumer side)
// internal/service/voucher_service.go

type VoucherRepository interface {
    Create(ctx context.Context, voucher *domain.Voucher) error
    FindByID(ctx context.Context, id uuid.UUID) (*domain.Voucher, error)
    FindByCompany(ctx context.Context, companyID uuid.UUID, filter VoucherFilter) ([]*domain.Voucher, error)
    Update(ctx context.Context, voucher *domain.Voucher) error
    Delete(ctx context.Context, id uuid.UUID) error
}

type VoucherService struct {
    repo   VoucherRepository
    logger *slog.Logger
}

func NewVoucherService(repo VoucherRepository, logger *slog.Logger) *VoucherService {
    return &VoucherService{
        repo:   repo,
        logger: logger,
    }
}

// Small, focused interfaces
type VoucherReader interface {
    FindByID(ctx context.Context, id uuid.UUID) (*domain.Voucher, error)
}

type VoucherWriter interface {
    Create(ctx context.Context, voucher *domain.Voucher) error
    Update(ctx context.Context, voucher *domain.Voucher) error
}

// Compose interfaces when needed
type VoucherReadWriter interface {
    VoucherReader
    VoucherWriter
}
```

### 2.7 테스트 컨벤션

```go
// Table-driven tests
func TestVoucherService_CreateVoucher(t *testing.T) {
    tests := []struct {
        name    string
        input   CreateVoucherRequest
        setup   func(*mockVoucherRepo)
        wantErr error
    }{
        {
            name: "successful creation",
            input: CreateVoucherRequest{
                VoucherDate: time.Now(),
                Lines: []VoucherLineRequest{
                    {AccountCode: "110101", DebitAmt: 1000},
                    {AccountCode: "401001", CreditAmt: 1000},
                },
            },
            setup: func(m *mockVoucherRepo) {
                m.On("Create", mock.Anything, mock.Anything).Return(nil)
            },
            wantErr: nil,
        },
        {
            name: "validation error - unbalanced",
            input: CreateVoucherRequest{
                VoucherDate: time.Now(),
                Lines: []VoucherLineRequest{
                    {AccountCode: "110101", DebitAmt: 1000},
                    {AccountCode: "401001", CreditAmt: 500},
                },
            },
            setup:   func(m *mockVoucherRepo) {},
            wantErr: ErrInvalidBalance,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            repo := new(mockVoucherRepo)
            tt.setup(repo)

            svc := NewVoucherService(repo, slog.Default())
            _, err := svc.CreateVoucher(context.Background(), tt.input)

            if tt.wantErr != nil {
                assert.ErrorIs(t, err, tt.wantErr)
            } else {
                assert.NoError(t, err)
            }
            repo.AssertExpectations(t)
        })
    }
}

// Benchmark tests
func BenchmarkVoucherService_CreateVoucher(b *testing.B) {
    repo := newInMemoryVoucherRepo()
    svc := NewVoucherService(repo, slog.Default())

    input := CreateVoucherRequest{
        VoucherDate: time.Now(),
        Lines: []VoucherLineRequest{
            {AccountCode: "110101", DebitAmt: 1000},
            {AccountCode: "401001", CreditAmt: 1000},
        },
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        svc.CreateVoucher(context.Background(), input)
    }
}

// Test helpers
func newTestVoucher(t *testing.T) *domain.Voucher {
    t.Helper()
    return &domain.Voucher{
        ID:          uuid.New(),
        CompanyID:   uuid.New(),
        VoucherNo:   "V-2024-00001",
        VoucherDate: time.Now(),
        Status:      domain.VoucherStatusDraft,
    }
}
```

### 2.8 Linter 설정

```yaml
# .golangci.yml
run:
  timeout: 5m
  go: "1.22"

linters:
  enable:
    - errcheck
    - gosimple
    - govet
    - ineffassign
    - staticcheck
    - unused
    - gofmt
    - goimports
    - misspell
    - unconvert
    - unparam
    - nakedret
    - prealloc
    - exportloopref
    - gocritic
    - revive
    - gosec
    - bodyclose
    - noctx
    - sqlclosecheck
    - rowserrcheck

linters-settings:
  govet:
    check-shadowing: true

  revive:
    rules:
      - name: exported
        disabled: false
      - name: var-naming
        disabled: false
      - name: package-comments
        disabled: true

  gosec:
    excludes:
      - G104 # Audit errors not checked
    config:
      global:
        nosec: true

  gocritic:
    enabled-tags:
      - diagnostic
      - style
      - performance

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - gosec
        - errcheck
    - path: mock_
      linters:
        - unused
```

---

## 3. Python 코딩 컨벤션

### 3.1 프로젝트 구조

```
python/
├── tax_scraper/
│   ├── __init__.py
│   ├── main.py           # gRPC server entry
│   ├── scraper.py        # Scraping logic
│   ├── crypto.py         # SEED/ARIA encryption
│   └── proto/
│       └── scraper_pb2.py
├── insurance_edi/
│   ├── __init__.py
│   ├── main.py
│   ├── parser.py
│   └── crypto.py
├── tests/
│   ├── test_scraper.py
│   └── test_crypto.py
├── pyproject.toml
└── requirements.txt
```

### 3.2 네이밍 컨벤션

```python
# Module names: lowercase with underscores
import tax_scraper
from insurance_edi import parser

# Class names: PascalCase
class TaxInvoiceScraper:
    pass

class SEEDCipher:
    pass

# Function names: lowercase with underscores
def scrape_tax_invoices(cert_path: str, password: str) -> list[TaxInvoice]:
    pass

def encrypt_with_seed(data: bytes, key: bytes) -> bytes:
    pass

# Variable names: lowercase with underscores
invoice_count = 0
max_retry_attempts = 3

# Constants: UPPERCASE with underscores
MAX_INVOICE_COUNT = 1000
DEFAULT_TIMEOUT_SECONDS = 30

# Private members: single underscore prefix
class TaxInvoiceScraper:
    def __init__(self):
        self._session = None
        self._cert_manager = None

    def _login(self) -> bool:
        pass

# Protected members: double underscore (name mangling)
class BaseParser:
    def __init__(self):
        self.__internal_state = {}
```

### 3.3 타입 힌트

```python
from typing import Optional, List, Dict, Union, TypeVar, Generic
from dataclasses import dataclass
from datetime import date, datetime
from decimal import Decimal
from uuid import UUID

# Data classes with type hints
@dataclass
class TaxInvoice:
    invoice_id: str
    issue_date: date
    supplier_brn: str
    buyer_brn: str
    total_amount: Decimal
    tax_amount: Decimal
    items: List["TaxInvoiceItem"]

@dataclass
class TaxInvoiceItem:
    item_name: str
    quantity: int
    unit_price: Decimal
    amount: Decimal

# Function type hints
def scrape_invoices(
    start_date: date,
    end_date: date,
    *,  # keyword-only arguments after this
    include_cancelled: bool = False,
    max_count: Optional[int] = None,
) -> List[TaxInvoice]:
    """Scrape tax invoices for the given date range."""
    pass

# Generic types
T = TypeVar("T")

class Repository(Generic[T]):
    def find_by_id(self, id: UUID) -> Optional[T]:
        pass

    def save(self, entity: T) -> T:
        pass

# Union types (Python 3.10+)
def process_input(data: str | bytes | None) -> dict:
    pass

# Callable types
from typing import Callable

RetryCallback = Callable[[Exception, int], bool]

def with_retry(
    func: Callable[[], T],
    max_attempts: int = 3,
    on_error: Optional[RetryCallback] = None,
) -> T:
    pass
```

### 3.4 에러 처리

```python
# Custom exceptions
class ScraperError(Exception):
    """Base exception for scraper errors."""
    pass

class AuthenticationError(ScraperError):
    """Certificate authentication failed."""
    pass

class SessionExpiredError(ScraperError):
    """Session has expired."""
    pass

class RateLimitError(ScraperError):
    """Rate limit exceeded."""
    def __init__(self, retry_after: int):
        self.retry_after = retry_after
        super().__init__(f"Rate limit exceeded. Retry after {retry_after} seconds.")

# Exception handling
import logging

logger = logging.getLogger(__name__)

def scrape_with_retry(
    scraper: TaxInvoiceScraper,
    max_attempts: int = 3,
) -> List[TaxInvoice]:
    last_error: Optional[Exception] = None

    for attempt in range(1, max_attempts + 1):
        try:
            return scraper.scrape()
        except SessionExpiredError:
            logger.warning("Session expired, re-authenticating...")
            scraper.authenticate()
        except RateLimitError as e:
            logger.warning(f"Rate limited, waiting {e.retry_after}s...")
            time.sleep(e.retry_after)
        except ScraperError as e:
            logger.error(f"Attempt {attempt}/{max_attempts} failed: {e}")
            last_error = e
            if attempt < max_attempts:
                time.sleep(2 ** attempt)  # Exponential backoff

    raise last_error or ScraperError("Unknown error")

# Context managers for cleanup
from contextlib import contextmanager

@contextmanager
def scraper_session(cert_path: str, password: str):
    scraper = TaxInvoiceScraper(cert_path, password)
    try:
        scraper.authenticate()
        yield scraper
    finally:
        scraper.close()

# Usage
with scraper_session("/path/to/cert", "password") as scraper:
    invoices = scraper.scrape()
```

### 3.5 gRPC 서비스

```python
# proto/scraper.proto -> scraper_pb2.py, scraper_pb2_grpc.py

import grpc
from concurrent import futures
import logging

from proto import scraper_pb2, scraper_pb2_grpc

logger = logging.getLogger(__name__)

class TaxScraperServicer(scraper_pb2_grpc.TaxScraperServicer):
    """gRPC service implementation for tax scraping."""

    def __init__(self, scraper_factory):
        self._scraper_factory = scraper_factory

    def ScrapeTaxInvoices(
        self,
        request: scraper_pb2.ScrapeRequest,
        context: grpc.ServicerContext,
    ) -> scraper_pb2.ScrapeResponse:
        """Scrape tax invoices for the given date range."""
        try:
            scraper = self._scraper_factory.create(
                cert_path=request.cert_path,
                password=request.password,
            )

            invoices = scraper.scrape(
                start_date=request.start_date,
                end_date=request.end_date,
            )

            return scraper_pb2.ScrapeResponse(
                success=True,
                invoices=[self._to_proto(inv) for inv in invoices],
            )
        except AuthenticationError as e:
            context.set_code(grpc.StatusCode.UNAUTHENTICATED)
            context.set_details(str(e))
            return scraper_pb2.ScrapeResponse(success=False)
        except Exception as e:
            logger.exception("Scraping failed")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details("Internal error")
            return scraper_pb2.ScrapeResponse(success=False)

    def _to_proto(self, invoice: TaxInvoice) -> scraper_pb2.TaxInvoice:
        return scraper_pb2.TaxInvoice(
            invoice_id=invoice.invoice_id,
            issue_date=invoice.issue_date.isoformat(),
            supplier_brn=invoice.supplier_brn,
            total_amount=str(invoice.total_amount),
        )

def serve(port: int = 50051):
    """Start the gRPC server."""
    server = grpc.server(
        futures.ThreadPoolExecutor(max_workers=10),
        options=[
            ("grpc.max_receive_message_length", 50 * 1024 * 1024),
        ],
    )
    scraper_pb2_grpc.add_TaxScraperServicer_to_server(
        TaxScraperServicer(ScraperFactory()),
        server,
    )
    server.add_insecure_port(f"[::]:{port}")
    server.start()
    logger.info(f"Server started on port {port}")
    server.wait_for_termination()

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    serve()
```

### 3.6 테스트 컨벤션

```python
# tests/test_scraper.py
import pytest
from unittest.mock import Mock, patch
from datetime import date
from decimal import Decimal

from tax_scraper.scraper import TaxInvoiceScraper, TaxInvoice

class TestTaxInvoiceScraper:
    """Test suite for TaxInvoiceScraper."""

    @pytest.fixture
    def mock_session(self):
        """Create a mock HTTP session."""
        return Mock()

    @pytest.fixture
    def scraper(self, mock_session):
        """Create a scraper with mocked session."""
        with patch("tax_scraper.scraper.requests.Session", return_value=mock_session):
            return TaxInvoiceScraper("/path/to/cert", "password")

    def test_scrape_returns_invoices(self, scraper, mock_session):
        """Test successful scraping returns list of invoices."""
        # Arrange
        mock_session.get.return_value.json.return_value = {
            "invoices": [
                {"id": "INV001", "amount": "1000"},
            ]
        }

        # Act
        result = scraper.scrape(
            start_date=date(2024, 1, 1),
            end_date=date(2024, 1, 31),
        )

        # Assert
        assert len(result) == 1
        assert result[0].invoice_id == "INV001"

    def test_scrape_empty_result(self, scraper, mock_session):
        """Test scraping with no results returns empty list."""
        mock_session.get.return_value.json.return_value = {"invoices": []}

        result = scraper.scrape(
            start_date=date(2024, 1, 1),
            end_date=date(2024, 1, 31),
        )

        assert result == []

    @pytest.mark.parametrize("status_code,expected_error", [
        (401, "AuthenticationError"),
        (429, "RateLimitError"),
        (500, "ScraperError"),
    ])
    def test_scrape_http_errors(self, scraper, mock_session, status_code, expected_error):
        """Test HTTP errors are properly converted to exceptions."""
        mock_session.get.return_value.status_code = status_code
        mock_session.get.return_value.raise_for_status.side_effect = Exception()

        with pytest.raises(Exception) as exc_info:
            scraper.scrape(
                start_date=date(2024, 1, 1),
                end_date=date(2024, 1, 31),
            )

        assert expected_error in str(type(exc_info.value))

# Conftest for shared fixtures
# tests/conftest.py
import pytest

@pytest.fixture(scope="session")
def test_cert_path(tmp_path_factory):
    """Create a temporary test certificate."""
    cert_dir = tmp_path_factory.mktemp("certs")
    cert_path = cert_dir / "test.pfx"
    cert_path.write_bytes(b"dummy cert data")
    return str(cert_path)
```

### 3.7 Linter 설정

```toml
# pyproject.toml
[tool.ruff]
target-version = "py311"
line-length = 100
select = [
    "E",   # pycodestyle errors
    "W",   # pycodestyle warnings
    "F",   # Pyflakes
    "I",   # isort
    "B",   # flake8-bugbear
    "C4",  # flake8-comprehensions
    "UP",  # pyupgrade
    "ARG", # flake8-unused-arguments
    "SIM", # flake8-simplify
]
ignore = [
    "E501",  # line too long (handled by formatter)
    "B008",  # function call in default argument
]

[tool.ruff.per-file-ignores]
"tests/*" = ["ARG", "S101"]

[tool.mypy]
python_version = "3.11"
strict = true
warn_return_any = true
warn_unused_ignores = true
disallow_untyped_defs = true

[[tool.mypy.overrides]]
module = "proto.*"
ignore_missing_imports = true

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = "test_*.py"
python_functions = "test_*"
addopts = "-v --cov=tax_scraper --cov-report=term-missing"
```

---

## 4. TypeScript/React 컨벤션

### 4.1 프로젝트 구조

```
web/
├── src/
│   ├── app/                  # Next.js App Router
│   │   ├── (auth)/          # Auth route group
│   │   ├── (dashboard)/     # Dashboard route group
│   │   └── layout.tsx
│   ├── components/
│   │   ├── ui/              # Shadcn UI components
│   │   ├── forms/           # Form components
│   │   └── common/          # Shared components
│   ├── hooks/               # Custom hooks
│   ├── lib/                 # Utilities
│   │   ├── api.ts
│   │   ├── utils.ts
│   │   └── validations.ts
│   ├── stores/              # Zustand stores
│   ├── types/               # TypeScript types
│   └── services/            # API service layer
├── public/
├── tailwind.config.ts
└── tsconfig.json
```

### 4.2 네이밍 컨벤션

```typescript
// Components: PascalCase
// File: VoucherForm.tsx
export function VoucherForm() {}
export default function VoucherList() {}

// Hooks: camelCase with 'use' prefix
// File: useVoucher.ts
export function useVoucher(id: string) {}
export function useVoucherList() {}

// Utilities: camelCase
// File: formatCurrency.ts
export function formatCurrency(amount: number) {}
export function formatDate(date: Date) {}

// Types/Interfaces: PascalCase
interface Voucher {
  id: string;
  voucherNo: string;
  voucherDate: string;
}

type VoucherStatus = 'draft' | 'posted' | 'cancelled';

// Constants: UPPER_SNAKE_CASE
const MAX_VOUCHER_LINES = 100;
const API_BASE_URL = '/api/v1';

// Enums: PascalCase (prefer const objects)
const VoucherStatus = {
  Draft: 'draft',
  Posted: 'posted',
  Cancelled: 'cancelled',
} as const;

type VoucherStatus = typeof VoucherStatus[keyof typeof VoucherStatus];
```

### 4.3 컴포넌트 패턴

```typescript
// components/forms/VoucherForm.tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// Schema definition
const voucherSchema = z.object({
  voucherDate: z.string().min(1, '전표일자를 입력하세요'),
  description: z.string().max(500).optional(),
  lines: z.array(z.object({
    accountCode: z.string().length(6, '계정코드는 6자리입니다'),
    debitAmt: z.number().min(0),
    creditAmt: z.number().min(0),
  })).min(1, '전표라인이 필요합니다'),
});

type VoucherFormData = z.infer<typeof voucherSchema>;

// Props interface
interface VoucherFormProps {
  initialData?: Partial<VoucherFormData>;
  onSubmit: (data: VoucherFormData) => Promise<void>;
  isLoading?: boolean;
}

// Component
export function VoucherForm({ initialData, onSubmit, isLoading }: VoucherFormProps) {
  const form = useForm<VoucherFormData>({
    resolver: zodResolver(voucherSchema),
    defaultValues: initialData ?? {
      voucherDate: '',
      description: '',
      lines: [{ accountCode: '', debitAmt: 0, creditAmt: 0 }],
    },
  });

  const handleSubmit = async (data: VoucherFormData) => {
    try {
      await onSubmit(data);
    } catch (error) {
      // Error handling
    }
  };

  return (
    <form onSubmit={form.handleSubmit(handleSubmit)}>
      {/* Form fields */}
    </form>
  );
}
```

### 4.4 커스텀 훅

```typescript
// hooks/useVoucher.ts
import useSWR from 'swr';
import useSWRMutation from 'swr/mutation';
import { voucherApi } from '@/services/voucherApi';
import type { Voucher, CreateVoucherRequest } from '@/types/voucher';

export function useVoucher(id: string) {
  const { data, error, isLoading, mutate } = useSWR<Voucher>(
    id ? `/vouchers/${id}` : null,
    () => voucherApi.getById(id),
  );

  return {
    voucher: data,
    isLoading,
    isError: !!error,
    error,
    mutate,
  };
}

export function useVoucherList(params?: { page?: number; limit?: number }) {
  const { data, error, isLoading } = useSWR(
    ['/vouchers', params],
    () => voucherApi.list(params),
  );

  return {
    vouchers: data?.items ?? [],
    total: data?.total ?? 0,
    isLoading,
    isError: !!error,
  };
}

export function useCreateVoucher() {
  const { trigger, isMutating, error } = useSWRMutation(
    '/vouchers',
    (_, { arg }: { arg: CreateVoucherRequest }) => voucherApi.create(arg),
  );

  return {
    createVoucher: trigger,
    isCreating: isMutating,
    error,
  };
}
```

### 4.5 API 서비스

```typescript
// services/api.ts
const API_BASE = process.env.NEXT_PUBLIC_API_URL ?? '/api/v1';

class ApiError extends Error {
  constructor(
    public status: number,
    public code: string,
    message: string,
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

async function request<T>(
  endpoint: string,
  options?: RequestInit,
): Promise<T> {
  const url = `${API_BASE}${endpoint}`;
  const config: RequestInit = {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  };

  const response = await fetch(url, config);

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new ApiError(
      response.status,
      error.code ?? 'UNKNOWN',
      error.message ?? 'An error occurred',
    );
  }

  return response.json();
}

export const api = {
  get: <T>(endpoint: string) => request<T>(endpoint),
  post: <T>(endpoint: string, data: unknown) =>
    request<T>(endpoint, { method: 'POST', body: JSON.stringify(data) }),
  put: <T>(endpoint: string, data: unknown) =>
    request<T>(endpoint, { method: 'PUT', body: JSON.stringify(data) }),
  delete: <T>(endpoint: string) =>
    request<T>(endpoint, { method: 'DELETE' }),
};

// services/voucherApi.ts
import { api } from './api';
import type { Voucher, CreateVoucherRequest, VoucherListResponse } from '@/types/voucher';

export const voucherApi = {
  list: (params?: { page?: number; limit?: number }) =>
    api.get<VoucherListResponse>(`/vouchers?${new URLSearchParams(params as any)}`),

  getById: (id: string) =>
    api.get<Voucher>(`/vouchers/${id}`),

  create: (data: CreateVoucherRequest) =>
    api.post<Voucher>('/vouchers', data),

  update: (id: string, data: Partial<CreateVoucherRequest>) =>
    api.put<Voucher>(`/vouchers/${id}`, data),

  delete: (id: string) =>
    api.delete<void>(`/vouchers/${id}`),
};
```

### 4.6 ESLint/Prettier 설정

```javascript
// .eslintrc.js
module.exports = {
  extends: [
    'next/core-web-vitals',
    'plugin:@typescript-eslint/recommended',
    'prettier',
  ],
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  rules: {
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/prop-types': 'off',
    'react/react-in-jsx-scope': 'off',
    'import/order': [
      'error',
      {
        groups: [
          'builtin',
          'external',
          'internal',
          'parent',
          'sibling',
          'index',
        ],
        'newlines-between': 'always',
        alphabetize: { order: 'asc' },
      },
    ],
  },
};

// .prettierrc
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "all",
  "printWidth": 100,
  "plugins": ["prettier-plugin-tailwindcss"]
}
```

---

## 5. SQL 작성 규칙

### 5.1 네이밍 컨벤션

```sql
-- Tables: snake_case, plural
CREATE TABLE vouchers (...);
CREATE TABLE voucher_lines (...);
CREATE TABLE tax_invoices (...);

-- Columns: snake_case
CREATE TABLE vouchers (
    id UUID PRIMARY KEY,
    company_id UUID NOT NULL,
    voucher_no VARCHAR(20) NOT NULL,
    voucher_date DATE NOT NULL,
    total_debit_amt DECIMAL(18, 2),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes: ix_{table}_{column(s)}
CREATE INDEX ix_vouchers_company_id ON vouchers(company_id);
CREATE INDEX ix_vouchers_voucher_date ON vouchers(voucher_date);
CREATE INDEX ix_vouchers_company_date ON vouchers(company_id, voucher_date);

-- Unique constraints: uq_{table}_{column(s)}
ALTER TABLE vouchers ADD CONSTRAINT uq_vouchers_company_no
    UNIQUE (company_id, voucher_no);

-- Foreign keys: fk_{table}_{ref_table}
ALTER TABLE voucher_lines ADD CONSTRAINT fk_voucher_lines_voucher
    FOREIGN KEY (voucher_id) REFERENCES vouchers(id);

-- Check constraints: ck_{table}_{description}
ALTER TABLE vouchers ADD CONSTRAINT ck_vouchers_status
    CHECK (status IN ('draft', 'posted', 'cancelled'));
```

### 5.2 쿼리 포맷팅

```sql
-- SELECT: Keywords uppercase, columns/tables lowercase
SELECT
    v.id,
    v.voucher_no,
    v.voucher_date,
    v.description,
    SUM(vl.debit_amt) AS total_debit,
    SUM(vl.credit_amt) AS total_credit
FROM vouchers v
INNER JOIN voucher_lines vl ON vl.voucher_id = v.id
WHERE v.company_id = $1
    AND v.voucher_date BETWEEN $2 AND $3
    AND v.status = 'posted'
GROUP BY v.id, v.voucher_no, v.voucher_date, v.description
HAVING SUM(vl.debit_amt) > 0
ORDER BY v.voucher_date DESC, v.voucher_no DESC
LIMIT $4 OFFSET $5;

-- CTE for complex queries
WITH monthly_totals AS (
    SELECT
        DATE_TRUNC('month', voucher_date) AS month,
        SUM(debit_amt) AS total_debit,
        SUM(credit_amt) AS total_credit
    FROM vouchers v
    INNER JOIN voucher_lines vl ON vl.voucher_id = v.id
    WHERE v.company_id = $1
        AND v.voucher_date >= $2
    GROUP BY DATE_TRUNC('month', voucher_date)
),
running_totals AS (
    SELECT
        month,
        total_debit,
        total_credit,
        SUM(total_debit - total_credit) OVER (ORDER BY month) AS cumulative
    FROM monthly_totals
)
SELECT * FROM running_totals ORDER BY month;
```

### 5.3 sqlc 쿼리 파일

```sql
-- db/queries/vouchers.sql

-- name: GetVoucherByID :one
SELECT
    v.*,
    COALESCE(
        json_agg(
            json_build_object(
                'id', vl.id,
                'account_code', vl.account_code,
                'debit_amt', vl.debit_amt,
                'credit_amt', vl.credit_amt
            )
        ) FILTER (WHERE vl.id IS NOT NULL),
        '[]'
    )::json AS lines
FROM vouchers v
LEFT JOIN voucher_lines vl ON vl.voucher_id = v.id
WHERE v.id = $1 AND v.company_id = $2
GROUP BY v.id;

-- name: ListVouchersByCompany :many
SELECT
    v.id,
    v.voucher_no,
    v.voucher_date,
    v.description,
    v.status,
    COUNT(vl.id) AS line_count,
    SUM(vl.debit_amt) AS total_debit
FROM vouchers v
LEFT JOIN voucher_lines vl ON vl.voucher_id = v.id
WHERE v.company_id = $1
    AND ($2::date IS NULL OR v.voucher_date >= $2)
    AND ($3::date IS NULL OR v.voucher_date <= $3)
    AND ($4::text IS NULL OR v.status = $4)
GROUP BY v.id
ORDER BY v.voucher_date DESC, v.voucher_no DESC
LIMIT $5 OFFSET $6;

-- name: CreateVoucher :one
INSERT INTO vouchers (
    company_id,
    voucher_no,
    voucher_date,
    description,
    status
) VALUES ($1, $2, $3, $4, $5)
RETURNING *;

-- name: CreateVoucherLine :one
INSERT INTO voucher_lines (
    voucher_id,
    line_no,
    account_code,
    debit_amt,
    credit_amt,
    description
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING *;
```

---

## 6. API 설계 규칙

### 6.1 URL 구조

```yaml
# RESTful URL patterns
base_url: /api/v1

# Collection resources
GET    /vouchers              # List vouchers
POST   /vouchers              # Create voucher
GET    /vouchers/{id}         # Get single voucher
PUT    /vouchers/{id}         # Update voucher
DELETE /vouchers/{id}         # Delete voucher

# Nested resources
GET    /vouchers/{id}/lines   # List voucher lines
POST   /vouchers/{id}/lines   # Add voucher line

# Actions (non-CRUD operations)
POST   /vouchers/{id}/post    # Post voucher (change status)
POST   /vouchers/{id}/cancel  # Cancel voucher

# Filtering and pagination
GET    /vouchers?status=draft&from=2024-01-01&to=2024-01-31&page=1&limit=20

# Search
GET    /vouchers/search?q=매출

# Bulk operations
POST   /vouchers/bulk         # Bulk create
DELETE /vouchers/bulk         # Bulk delete
```

### 6.2 요청/응답 형식

```typescript
// Standard request format
interface CreateVoucherRequest {
  voucher_date: string;       // ISO 8601 date
  description?: string;
  lines: VoucherLineInput[];
}

// Standard response format (success)
interface ApiResponse<T> {
  success: true;
  data: T;
  meta?: {
    page: number;
    limit: number;
    total: number;
    total_pages: number;
  };
}

// Standard response format (error)
interface ApiErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: Record<string, string[]>;
  };
}

// Example success response
{
  "success": true,
  "data": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "voucher_no": "V-2024-00001",
    "voucher_date": "2024-01-15",
    "status": "draft",
    "lines": [...]
  }
}

// Example error response
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": {
      "voucher_date": ["전표일자는 필수입니다"],
      "lines": ["최소 1개의 전표라인이 필요합니다"]
    }
  }
}

// Pagination response
{
  "success": true,
  "data": [...],
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "total_pages": 8
  }
}
```

### 6.3 HTTP 상태 코드

```yaml
status_codes:
  # Success
  200: "OK - GET, PUT 성공"
  201: "Created - POST 성공"
  204: "No Content - DELETE 성공"

  # Client errors
  400: "Bad Request - 잘못된 요청"
  401: "Unauthorized - 인증 필요"
  403: "Forbidden - 권한 없음"
  404: "Not Found - 리소스 없음"
  409: "Conflict - 충돌 (중복 등)"
  422: "Unprocessable Entity - 유효성 검증 실패"
  429: "Too Many Requests - 요청 제한"

  # Server errors
  500: "Internal Server Error - 서버 오류"
  503: "Service Unavailable - 서비스 불가"
```

---

## 7. Git 컨벤션

### 7.1 브랜치 전략

```yaml
branches:
  main:
    description: "프로덕션 배포 브랜치"
    protection:
      - require_pull_request
      - require_review_approval
      - require_status_checks

  develop:
    description: "개발 통합 브랜치"
    source: main

  feature/*:
    description: "기능 개발"
    pattern: "feature/{issue-number}-{short-description}"
    example: "feature/123-voucher-api"
    source: develop

  bugfix/*:
    description: "버그 수정"
    pattern: "bugfix/{issue-number}-{short-description}"
    example: "bugfix/456-balance-calculation"
    source: develop

  hotfix/*:
    description: "긴급 수정"
    pattern: "hotfix/{issue-number}-{short-description}"
    source: main

  release/*:
    description: "릴리스 준비"
    pattern: "release/v{major}.{minor}.{patch}"
    example: "release/v1.2.0"
    source: develop
```

### 7.2 커밋 메시지

```yaml
# Conventional Commits format
# <type>(<scope>): <subject>
# <blank line>
# <body>
# <blank line>
# <footer>

types:
  feat: "새로운 기능"
  fix: "버그 수정"
  docs: "문서 변경"
  style: "코드 포맷팅 (기능 변경 없음)"
  refactor: "리팩토링 (기능 변경 없음)"
  perf: "성능 개선"
  test: "테스트 추가/수정"
  chore: "빌드, 설정 변경"
  ci: "CI/CD 설정 변경"

scopes:
  - voucher
  - account
  - tax-invoice
  - auth
  - api
  - db
  - ui

examples:
  - "feat(voucher): add bulk voucher creation API"
  - "fix(tax-invoice): correct tax calculation for exempt items"
  - "docs(api): update voucher API documentation"
  - "refactor(account): extract balance calculator to separate service"
  - "test(voucher): add integration tests for posting workflow"
  - "chore: update Go version to 1.22"

# Breaking changes
breaking_change: |
  feat(api)!: change voucher response format

  BREAKING CHANGE: The voucher response now includes nested lines array
  instead of separate endpoint.
```

### 7.3 PR 템플릿

```markdown
<!-- .github/pull_request_template.md -->

## 변경 사항
<!-- 이 PR의 변경 내용을 설명하세요 -->

## 관련 이슈
<!-- 관련 이슈 번호를 연결하세요 -->
Closes #

## 변경 유형
- [ ] 새로운 기능 (feat)
- [ ] 버그 수정 (fix)
- [ ] 문서 업데이트 (docs)
- [ ] 리팩토링 (refactor)
- [ ] 테스트 (test)
- [ ] 기타 (chore)

## 체크리스트
- [ ] 코드 린트 통과 (`make lint`)
- [ ] 테스트 통과 (`make test`)
- [ ] 문서 업데이트 완료
- [ ] 마이그레이션 스크립트 추가 (필요시)

## 스크린샷 (UI 변경시)
<!-- UI 변경 전/후 스크린샷을 첨부하세요 -->

## 테스트 방법
<!-- 리뷰어가 테스트할 수 있는 방법을 설명하세요 -->
```

---

## 8. 코드 리뷰 체크리스트

### 8.1 일반 체크리스트

```yaml
general:
  - "코드가 요구사항을 충족하는가?"
  - "변경의 범위가 적절한가? (너무 크지 않은가?)"
  - "불필요한 변경이 포함되어 있지 않은가?"
  - "에러 처리가 적절한가?"
  - "로깅이 충분한가?"
  - "민감 정보가 노출되지 않는가?"

go_specific:
  - "에러가 항상 처리되거나 명시적으로 무시되는가?"
  - "context가 적절히 전파되는가?"
  - "goroutine 누수 가능성이 없는가?"
  - "race condition 가능성이 없는가?"
  - "인터페이스가 소비자 측에서 정의되어 있는가?"

python_specific:
  - "타입 힌트가 적절히 사용되었는가?"
  - "exception 처리가 적절한가?"
  - "resource cleanup이 보장되는가? (context manager)"
  - "async/await 사용이 올바른가?"

typescript_specific:
  - "any 타입이 남용되지 않았는가?"
  - "null/undefined 체크가 적절한가?"
  - "hooks 사용 규칙을 준수하는가?"
  - "메모이제이션이 필요한 곳에 적용되었는가?"

sql_specific:
  - "인덱스를 활용하는 쿼리인가?"
  - "N+1 문제가 없는가?"
  - "SQL injection 위험이 없는가?"
  - "company_id 필터가 항상 적용되는가?"
```

### 8.2 보안 체크리스트

```yaml
security:
  authentication:
    - "인증이 필요한 엔드포인트에 적용되어 있는가?"
    - "토큰 검증이 올바른가?"
    - "세션 관리가 안전한가?"

  authorization:
    - "권한 검사가 적절한가?"
    - "tenant isolation이 보장되는가?"
    - "horizontal privilege escalation이 불가능한가?"

  input_validation:
    - "모든 입력이 검증되는가?"
    - "SQL injection이 불가능한가?"
    - "XSS가 불가능한가?"
    - "Path traversal이 불가능한가?"

  sensitive_data:
    - "민감 정보가 로그에 기록되지 않는가?"
    - "에러 메시지에 내부 정보가 노출되지 않는가?"
    - "응답에 불필요한 정보가 포함되지 않는가?"
```

### 8.3 성능 체크리스트

```yaml
performance:
  database:
    - "적절한 인덱스가 있는가?"
    - "N+1 쿼리가 없는가?"
    - "대량 데이터 처리시 pagination이 적용되었는가?"
    - "불필요한 컬럼을 조회하지 않는가?"

  api:
    - "응답 크기가 적절한가?"
    - "캐싱이 적용될 수 있는가?"
    - "비동기 처리가 필요한가?"

  memory:
    - "메모리 누수 가능성이 없는가?"
    - "대용량 데이터 처리시 streaming을 사용하는가?"
    - "불필요한 복사가 없는가?"
```

---

## 버전 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|-----------|
| 0.2 | 2024-01-15 | DevTeam | Go+Python 하이브리드 아키텍처 반영 |
| 0.1 | 2024-01-01 | DevTeam | 초안 작성 |
