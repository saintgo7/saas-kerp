# 22. 성능 벤치마크

## 개요

K-ERP 시스템의 성능 목표 및 벤치마크 기준 정의.
API 응답 시간, 처리량, 동시 사용자 지원 등의 성능 지표.

### 성능 목표 (SLA)

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| API 응답 시간 (p50) | < 100ms | Prometheus percentile |
| API 응답 시간 (p95) | < 200ms | Prometheus percentile |
| API 응답 시간 (p99) | < 500ms | Prometheus percentile |
| 가용성 | 99.9% | Uptime 모니터링 |
| 동시 사용자 | 1,000+ | Load testing |
| 처리량 | 1,000 RPS | k6 load test |

---

## 1. 벤치마크 환경

### 1.1 테스트 환경 구성

```yaml
# 테스트 환경 스펙

Production 환경 (기준):
  API Server:
    - Instance: AWS c6i.xlarge (4 vCPU, 8GB)
    - Replicas: 3
    - Container: Go 1.22 binary

  Database:
    - Type: AWS RDS PostgreSQL 16
    - Instance: db.r6g.large (2 vCPU, 16GB)
    - Storage: gp3, 100GB, 3000 IOPS

  Cache:
    - Type: AWS ElastiCache Redis 7
    - Instance: cache.r6g.large (2 vCPU, 13GB)
    - Cluster Mode: Disabled

  Load Balancer:
    - Type: AWS ALB
    - SSL Termination: Yes
```

### 1.2 테스트 데이터셋

```sql
-- 테스트 데이터 규모

테넌트(회사): 100개
회사당 사용자: 평균 20명
회사당 계정과목: 200개
회사당 거래처: 500개
회사당 전표: 10,000건/년
회사당 전표라인: 평균 3개/전표

총 데이터량:
- companies: 100
- users: 2,000
- accounts: 20,000
- customers: 50,000
- vouchers: 1,000,000
- voucher_lines: 3,000,000
```

---

## 2. API 성능 벤치마크

### 2.1 k6 부하 테스트 스크립트

```javascript
// tests/load/api-benchmark.js
import http from 'k6/http'
import { check, sleep } from 'k6'
import { Rate, Trend } from 'k6/metrics'

// 커스텀 메트릭
const errorRate = new Rate('errors')
const voucherListTrend = new Trend('voucher_list_duration')
const voucherCreateTrend = new Trend('voucher_create_duration')

export const options = {
  scenarios: {
    // 시나리오 1: 평상시 부하
    normal_load: {
      executor: 'constant-vus',
      vus: 50,
      duration: '5m',
      startTime: '0s',
    },
    // 시나리오 2: 피크 타임 부하
    peak_load: {
      executor: 'ramping-vus',
      startVUs: 50,
      stages: [
        { duration: '2m', target: 200 },
        { duration: '5m', target: 200 },
        { duration: '2m', target: 50 },
      ],
      startTime: '5m',
    },
    // 시나리오 3: 스파이크 테스트
    spike_test: {
      executor: 'ramping-vus',
      startVUs: 50,
      stages: [
        { duration: '10s', target: 500 },
        { duration: '1m', target: 500 },
        { duration: '10s', target: 50 },
      ],
      startTime: '14m',
    },
  },
  thresholds: {
    http_req_duration: ['p(95)<200', 'p(99)<500'],
    http_req_failed: ['rate<0.01'],
    errors: ['rate<0.01'],
  },
}

const BASE_URL = __ENV.BASE_URL || 'https://api.kerp.example.com'
const API_TOKEN = __ENV.API_TOKEN

const headers = {
  'Content-Type': 'application/json',
  'Authorization': `Bearer ${API_TOKEN}`,
  'X-Company-ID': __ENV.COMPANY_ID,
}

export default function () {
  // API 호출 비율 (실제 사용 패턴 기반)
  const random = Math.random()

  if (random < 0.4) {
    // 40%: 전표 목록 조회
    testVoucherList()
  } else if (random < 0.6) {
    // 20%: 전표 상세 조회
    testVoucherDetail()
  } else if (random < 0.75) {
    // 15%: 전표 생성
    testVoucherCreate()
  } else if (random < 0.85) {
    // 10%: 재무제표 조회
    testFinancialReport()
  } else if (random < 0.95) {
    // 10%: 대시보드
    testDashboard()
  } else {
    // 5%: 검색
    testSearch()
  }

  sleep(Math.random() * 2 + 1) // 1-3초 대기
}

function testVoucherList() {
  const startTime = Date.now()
  const res = http.get(`${BASE_URL}/api/v1/vouchers?limit=20&page=1`, { headers })
  const duration = Date.now() - startTime

  voucherListTrend.add(duration)

  const success = check(res, {
    'voucher list status 200': (r) => r.status === 200,
    'voucher list has data': (r) => JSON.parse(r.body).data.length > 0,
    'voucher list < 200ms': (r) => r.timings.duration < 200,
  })

  errorRate.add(!success)
}

function testVoucherDetail() {
  const voucherId = getRandomVoucherId()
  const res = http.get(`${BASE_URL}/api/v1/vouchers/${voucherId}`, { headers })

  check(res, {
    'voucher detail status 200': (r) => r.status === 200,
    'voucher detail < 100ms': (r) => r.timings.duration < 100,
  })
}

function testVoucherCreate() {
  const startTime = Date.now()
  const payload = JSON.stringify({
    voucher_date: new Date().toISOString().split('T')[0],
    voucher_type: 'general',
    description: `Load test voucher ${Date.now()}`,
    lines: [
      { account_code: '10101', debit_amount: 100000, credit_amount: 0 },
      { account_code: '40101', debit_amount: 0, credit_amount: 100000 },
    ],
  })

  const res = http.post(`${BASE_URL}/api/v1/vouchers`, payload, { headers })
  const duration = Date.now() - startTime

  voucherCreateTrend.add(duration)

  const success = check(res, {
    'voucher create status 201': (r) => r.status === 201,
    'voucher create < 300ms': (r) => r.timings.duration < 300,
  })

  errorRate.add(!success)
}

function testFinancialReport() {
  const res = http.get(
    `${BASE_URL}/api/v1/reports/balance-sheet?year=2024&month=12`,
    { headers }
  )

  check(res, {
    'report status 200': (r) => r.status === 200,
    'report < 500ms': (r) => r.timings.duration < 500,
  })
}

function testDashboard() {
  const res = http.get(`${BASE_URL}/api/v1/dashboard/summary`, { headers })

  check(res, {
    'dashboard status 200': (r) => r.status === 200,
    'dashboard < 300ms': (r) => r.timings.duration < 300,
  })
}

function testSearch() {
  const res = http.get(
    `${BASE_URL}/api/v1/search?q=매출&type=voucher`,
    { headers }
  )

  check(res, {
    'search status 200': (r) => r.status === 200,
    'search < 200ms': (r) => r.timings.duration < 200,
  })
}

// 헬퍼 함수
function getRandomVoucherId() {
  const ids = JSON.parse(open('./voucher_ids.json'))
  return ids[Math.floor(Math.random() * ids.length)]
}
```

### 2.2 테스트 실행 및 결과

```bash
# 테스트 실행
k6 run \
  --out json=results.json \
  --out influxdb=http://localhost:8086/k6 \
  -e BASE_URL=https://staging-api.kerp.example.com \
  -e API_TOKEN=$API_TOKEN \
  -e COMPANY_ID=$COMPANY_ID \
  tests/load/api-benchmark.js

# 결과 예시
```

### 2.3 벤치마크 결과 (목표)

| API 엔드포인트 | p50 | p95 | p99 | RPS |
|---------------|-----|-----|-----|-----|
| GET /vouchers | 45ms | 120ms | 250ms | 500 |
| GET /vouchers/:id | 20ms | 50ms | 100ms | 800 |
| POST /vouchers | 80ms | 180ms | 350ms | 200 |
| GET /reports/balance-sheet | 150ms | 400ms | 800ms | 100 |
| GET /dashboard/summary | 100ms | 250ms | 500ms | 300 |
| GET /search | 50ms | 150ms | 300ms | 400 |

---

## 3. 데이터베이스 성능

### 3.1 주요 쿼리 벤치마크

```sql
-- 전표 목록 조회 (인덱스 최적화 후)
EXPLAIN ANALYZE
SELECT v.*, COUNT(vl.id) as line_count
FROM vouchers v
LEFT JOIN voucher_lines vl ON v.id = vl.voucher_id
WHERE v.company_id = '550e8400-e29b-41d4-a716-446655440000'
  AND v.voucher_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND v.deleted_at IS NULL
GROUP BY v.id
ORDER BY v.voucher_date DESC, v.voucher_no DESC
LIMIT 20;

-- 예상 실행 계획
/*
 Limit  (cost=1234.56..1234.78 rows=20 width=200) (actual time=15.123..15.456 rows=20 loops=1)
   ->  Sort  (cost=1234.56..1245.67 rows=1000 width=200) (actual time=15.120..15.140 rows=20 loops=1)
         Sort Key: v.voucher_date DESC, v.voucher_no DESC
         Sort Method: top-N heapsort  Memory: 25kB
         ->  Index Scan using idx_vouchers_company_date on vouchers v  (actual time=0.123..12.345 rows=1000 loops=1)
               Index Cond: ((company_id = '550e8400...'::uuid) AND ...)
               Filter: (deleted_at IS NULL)
 Planning Time: 0.234 ms
 Execution Time: 15.678 ms
*/
```

### 3.2 인덱스 성능 분석

```sql
-- 인덱스 사용률 분석
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan as index_scans,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC
LIMIT 20;

-- 미사용 인덱스 감지
SELECT
    schemaname || '.' || tablename as table,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes
WHERE idx_scan < 50
AND schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;
```

### 3.3 데이터베이스 성능 목표

| 쿼리 유형 | 목표 실행 시간 | 비고 |
|----------|---------------|------|
| 단순 조회 (PK) | < 5ms | 캐시 히트 시 |
| 목록 조회 (20건) | < 50ms | 인덱스 사용 |
| 복잡 집계 (재무제표) | < 500ms | 월별 집계 |
| 검색 (전문검색) | < 100ms | Meilisearch |
| 배치 삽입 (1000건) | < 2s | COPY 사용 |

---

## 4. 캐시 성능

### 4.1 Redis 벤치마크

```bash
# Redis 벤치마크
redis-benchmark -h localhost -p 6379 -c 50 -n 100000 -q

# 결과 예시
PING_INLINE: 125000.00 requests per second
PING_BULK: 142857.14 requests per second
SET: 111111.11 requests per second
GET: 125000.00 requests per second
INCR: 111111.11 requests per second
LPUSH: 100000.00 requests per second
RPUSH: 100000.00 requests per second
LPOP: 100000.00 requests per second
RPOP: 100000.00 requests per second
SADD: 111111.11 requests per second
HSET: 100000.00 requests per second
MSET (10 keys): 71428.57 requests per second
```

### 4.2 캐시 히트율 목표

```go
// 캐시 전략별 목표 히트율

type CacheMetrics struct {
    // 세션 캐시 (필수)
    SessionCacheHitRate float64 // 목표: 99%+

    // 사용자 정보 캐시
    UserCacheHitRate float64 // 목표: 95%+

    // 계정과목 캐시
    AccountCacheHitRate float64 // 목표: 98%+

    // 거래처 캐시
    CustomerCacheHitRate float64 // 목표: 90%+

    // 대시보드 집계 캐시
    DashboardCacheHitRate float64 // 목표: 80%+

    // 재무제표 캐시
    ReportCacheHitRate float64 // 목표: 70%+
}
```

---

## 5. 동시성 테스트

### 5.1 동시 사용자 시뮬레이션

```javascript
// tests/load/concurrent-users.js
import http from 'k6/http'
import { check, group, sleep } from 'k6'
import { SharedArray } from 'k6/data'

// 테스트 사용자 목록
const users = new SharedArray('users', function () {
  return JSON.parse(open('./test_users.json'))
})

export const options = {
  scenarios: {
    concurrent_users: {
      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '2m', target: 100 },   // 100명까지 증가
        { duration: '5m', target: 500 },   // 500명까지 증가
        { duration: '5m', target: 1000 },  // 1000명까지 증가
        { duration: '10m', target: 1000 }, // 1000명 유지
        { duration: '3m', target: 0 },     // 종료
      ],
    },
  },
  thresholds: {
    http_req_duration: ['p(95)<500'],
    http_req_failed: ['rate<0.05'],
  },
}

export default function () {
  // 각 VU에 고유 사용자 할당
  const user = users[__VU % users.length]

  // 로그인
  const loginRes = http.post(
    `${BASE_URL}/api/v1/auth/login`,
    JSON.stringify({
      email: user.email,
      password: user.password,
    }),
    { headers: { 'Content-Type': 'application/json' } }
  )

  check(loginRes, { 'login success': (r) => r.status === 200 })

  if (loginRes.status !== 200) {
    return
  }

  const token = JSON.parse(loginRes.body).access_token
  const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`,
    'X-Company-ID': user.company_id,
  }

  // 사용자 행동 시뮬레이션
  group('user workflow', () => {
    // 대시보드 확인
    http.get(`${BASE_URL}/api/v1/dashboard/summary`, { headers })
    sleep(2)

    // 전표 목록 조회
    http.get(`${BASE_URL}/api/v1/vouchers?limit=20`, { headers })
    sleep(3)

    // 전표 상세 조회
    const voucherRes = http.get(`${BASE_URL}/api/v1/vouchers`, { headers })
    if (voucherRes.status === 200) {
      const vouchers = JSON.parse(voucherRes.body).data
      if (vouchers.length > 0) {
        http.get(`${BASE_URL}/api/v1/vouchers/${vouchers[0].id}`, { headers })
      }
    }
    sleep(2)

    // 20% 확률로 전표 생성
    if (Math.random() < 0.2) {
      http.post(
        `${BASE_URL}/api/v1/vouchers`,
        JSON.stringify({
          voucher_date: new Date().toISOString().split('T')[0],
          voucher_type: 'general',
          description: 'Concurrent test',
          lines: [
            { account_code: '10101', debit_amount: 10000, credit_amount: 0 },
            { account_code: '40101', debit_amount: 0, credit_amount: 10000 },
          ],
        }),
        { headers }
      )
    }
    sleep(5)
  })
}
```

### 5.2 동시성 테스트 결과 목표

| 동시 사용자 | 목표 응답 시간 (p95) | 목표 에러율 |
|------------|---------------------|------------|
| 100 | < 150ms | < 0.1% |
| 500 | < 200ms | < 0.5% |
| 1,000 | < 300ms | < 1.0% |
| 2,000 | < 500ms | < 2.0% |

---

## 6. 특수 시나리오 벤치마크

### 6.1 월말 마감 처리

```go
// 월말 마감 시 대량 처리 성능 테스트

func BenchmarkMonthEndClosing(b *testing.B) {
    // 테스트 데이터: 10,000건 전표, 30,000건 전표라인
    ctx := context.Background()
    companyID := uuid.New()

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        // 월말 마감 처리
        err := service.ProcessMonthEndClosing(ctx, companyID, "2024-12")
        if err != nil {
            b.Fatal(err)
        }
    }
}

// 목표: 10,000건 전표 마감 처리 < 30초
```

### 6.2 세금계산서 대량 발행

```go
// 세금계산서 대량 발행 성능 테스트

func BenchmarkBulkTaxInvoiceIssue(b *testing.B) {
    // 테스트 데이터: 1,000건 세금계산서
    ctx := context.Background()
    invoices := generateTestTaxInvoices(1000)

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        results := service.BulkIssueTaxInvoices(ctx, invoices)

        successCount := 0
        for _, r := range results {
            if r.Success {
                successCount++
            }
        }

        if successCount < 990 { // 99% 성공률
            b.Fatalf("Success rate too low: %d/1000", successCount)
        }
    }
}

// 목표:
// - 1,000건 발행 < 5분 (동시 10개 요청)
// - 성공률 > 99%
```

### 6.3 재무제표 생성

```go
// 재무제표 생성 성능 테스트

func BenchmarkFinancialStatements(b *testing.B) {
    ctx := context.Background()
    companyID := uuid.New()

    b.Run("BalanceSheet", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            _, err := service.GenerateBalanceSheet(ctx, companyID, 2024, 12)
            if err != nil {
                b.Fatal(err)
            }
        }
    })

    b.Run("IncomeStatement", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            _, err := service.GenerateIncomeStatement(ctx, companyID, 2024)
            if err != nil {
                b.Fatal(err)
            }
        }
    })

    b.Run("CashFlowStatement", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            _, err := service.GenerateCashFlowStatement(ctx, companyID, 2024)
            if err != nil {
                b.Fatal(err)
            }
        }
    })
}

// 목표:
// - 재무상태표: < 500ms
// - 손익계산서: < 300ms
// - 현금흐름표: < 800ms
```

---

## 7. 성능 모니터링

### 7.1 Prometheus 메트릭

```yaml
# 주요 성능 메트릭

# API 응답 시간
http_request_duration_seconds:
  type: histogram
  buckets: [0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]

# DB 쿼리 시간
db_query_duration_seconds:
  type: histogram
  labels: [query_type, table]

# 캐시 히트율
cache_hit_total:
  type: counter
  labels: [cache_name]

cache_miss_total:
  type: counter
  labels: [cache_name]

# 동시 연결 수
active_connections:
  type: gauge
  labels: [service]

# 메모리 사용량
process_resident_memory_bytes:
  type: gauge
```

### 7.2 Grafana 대시보드

```json
{
  "dashboard": {
    "title": "K-ERP Performance Dashboard",
    "panels": [
      {
        "title": "API Response Time (p95)",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))"
          }
        ]
      },
      {
        "title": "Request Rate",
        "type": "stat",
        "targets": [
          {
            "expr": "sum(rate(http_requests_total[1m]))"
          }
        ]
      },
      {
        "title": "Error Rate",
        "type": "stat",
        "targets": [
          {
            "expr": "sum(rate(http_requests_total{status=~'5..'}[5m])) / sum(rate(http_requests_total[5m])) * 100"
          }
        ]
      },
      {
        "title": "Cache Hit Rate",
        "type": "gauge",
        "targets": [
          {
            "expr": "sum(rate(cache_hit_total[5m])) / (sum(rate(cache_hit_total[5m])) + sum(rate(cache_miss_total[5m]))) * 100"
          }
        ]
      }
    ]
  }
}
```

---

## 8. 성능 최적화 가이드라인

### 8.1 코드 레벨 최적화

```go
// 1. N+1 쿼리 방지
// Bad
for _, voucher := range vouchers {
    lines, _ := repo.FindLinesByVoucherID(voucher.ID)
    voucher.Lines = lines
}

// Good (Preload)
db.Preload("Lines").Find(&vouchers)

// 2. 불필요한 데이터 로드 방지
// Bad
db.Find(&vouchers) // 모든 컬럼

// Good
db.Select("id", "voucher_no", "voucher_date", "status").Find(&vouchers)

// 3. 배치 처리
// Bad
for _, item := range items {
    db.Create(&item)
}

// Good
db.CreateInBatches(items, 1000)

// 4. 컨텍스트 타임아웃
ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
defer cancel()
```

### 8.2 데이터베이스 최적화

```sql
-- 1. 적절한 인덱스 생성
CREATE INDEX CONCURRENTLY idx_vouchers_company_date_status
ON vouchers (company_id, voucher_date, status)
WHERE deleted_at IS NULL;

-- 2. 파티셔닝 (대용량 테이블)
-- 월별 파티션

-- 3. 정기적인 VACUUM
VACUUM ANALYZE vouchers;

-- 4. 쿼리 최적화 (EXPLAIN ANALYZE 활용)
```

---

**문서 버전**: 1.0
**작성일**: 2025년 1월
**작성자**: K-ERP 개발팀
