# K-ERP 외부 연동 구현 설계서

## 1. 외부 연동 개요

### 1.1 연동 대상 시스템

```
┌─────────────────────────────────────────────────────────────────┐
│                    K-ERP 외부 연동 아키텍처                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                        ┌───────────────┐                        │
│                        │    K-ERP      │                        │
│                        │   Backend     │                        │
│                        └───────┬───────┘                        │
│                                │                                 │
│         ┌──────────────────────┼──────────────────────┐         │
│         │                      │                      │         │
│         ▼                      ▼                      ▼         │
│  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐      │
│  │   Popbill   │      │  4대보험    │      │    기타     │      │
│  │     API     │      │   EDI       │      │   연동      │      │
│  └──────┬──────┘      └──────┬──────┘      └──────┬──────┘      │
│         │                    │                    │             │
│         ▼                    ▼                    ▼             │
│  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐      │
│  │   국세청    │      │ 국민연금   │      │   은행      │      │
│  │   e세로     │      │ 건강보험   │      │  PG사 등    │      │
│  │             │      │ 고용산재   │      │             │      │
│  └─────────────┘      └─────────────┘      └─────────────┘      │
│                                                                  │
│  [연동 방식]                                                    │
│  • Popbill: REST API (HTTPS)                                    │
│  • 4대보험: EDI 파일 + SFTP 전송                                │
│  • 은행/PG: 각 사별 API                                         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. Popbill API 연동 (세금계산서)

### 2.1 Popbill 클라이언트 구현

```go
// internal/infrastructure/external/popbill/client.go

package popbill

import (
    "context"
    "crypto/sha256"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "time"

    "github.com/go-resty/resty/v2"
)

type Config struct {
    LinkID        string        // 팝빌 링크아이디
    SecretKey     string        // 팝빌 비밀키
    IsTest        bool          // 테스트 환경 여부
    Timeout       time.Duration // 요청 타임아웃
    RetryCount    int           // 재시도 횟수
    RetryWaitTime time.Duration // 재시도 대기시간
}

type Client struct {
    config     *Config
    httpClient *resty.Client
    baseURL    string
}

func NewClient(config *Config) *Client {
    baseURL := "https://popbill.linkhub.co.kr"
    if config.IsTest {
        baseURL = "https://popbill-test.linkhub.co.kr"
    }

    httpClient := resty.New().
        SetTimeout(config.Timeout).
        SetRetryCount(config.RetryCount).
        SetRetryWaitTime(config.RetryWaitTime).
        SetRetryMaxWaitTime(30 * time.Second).
        AddRetryCondition(func(r *resty.Response, err error) bool {
            // 5xx 에러 또는 네트워크 에러 시 재시도
            return err != nil || r.StatusCode() >= 500
        })

    return &Client{
        config:     config,
        httpClient: httpClient,
        baseURL:    baseURL,
    }
}

// 인증 토큰 발급
func (c *Client) getAccessToken(ctx context.Context, corpNum string, scopes []string) (string, error) {
    // 서명 생성
    timestamp := time.Now().Format("2006-01-02T15:04:05Z")
    signTarget := fmt.Sprintf("%s%s", c.config.LinkID, timestamp)

    h := sha256.New()
    h.Write([]byte(signTarget))
    signature := base64.StdEncoding.EncodeToString(h.Sum(nil))

    reqBody := map[string]interface{}{
        "access_id":  c.config.LinkID,
        "scope":      scopes,
        "timestamp":  timestamp,
        "signature":  signature,
        "secret_key": c.config.SecretKey,
    }

    var result struct {
        AccessToken string `json:"access_token"`
        ExpiresIn   int    `json:"expires_in"`
    }

    resp, err := c.httpClient.R().
        SetContext(ctx).
        SetHeader("Content-Type", "application/json").
        SetBody(reqBody).
        SetResult(&result).
        Post(fmt.Sprintf("%s/Token/%s", c.baseURL, corpNum))

    if err != nil {
        return "", fmt.Errorf("token request failed: %w", err)
    }

    if resp.IsError() {
        return "", c.parseError(resp)
    }

    return result.AccessToken, nil
}

// 에러 파싱
func (c *Client) parseError(resp *resty.Response) error {
    var popbillErr struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
    }

    if err := json.Unmarshal(resp.Body(), &popbillErr); err != nil {
        return fmt.Errorf("unknown error: %s", resp.String())
    }

    return &PopbillError{
        Code:    popbillErr.Code,
        Message: popbillErr.Message,
    }
}

type PopbillError struct {
    Code    int
    Message string
}

func (e *PopbillError) Error() string {
    return fmt.Sprintf("Popbill error %d: %s", e.Code, e.Message)
}
```

### 2.2 세금계산서 발행 서비스

```go
// internal/infrastructure/external/popbill/tax_invoice.go

package popbill

import (
    "context"
    "fmt"
)

// 세금계산서 발행 요청
type TaxInvoiceRequest struct {
    // 관리번호 (고유키)
    MgtKey string `json:"mgtKey"`

    // 작성일자 (YYYYMMDD)
    WriteDate string `json:"writeDate"`

    // 과세형태 (01: 과세, 02: 영세, 03: 면세)
    TaxType string `json:"taxType"`

    // 발행형태 (01: 정발행, 02: 역발행, 03: 위수탁)
    IssueType string `json:"issueType"`

    // 공급자 정보
    InvoicerCorpNum       string `json:"invoicerCorpNum"`
    InvoicerCorpName      string `json:"invoicerCorpName"`
    InvoicerCEOName       string `json:"invoicerCEOName"`
    InvoicerAddr          string `json:"invoicerAddr,omitempty"`
    InvoicerBizType       string `json:"invoicerBizType,omitempty"`
    InvoicerBizClass      string `json:"invoicerBizClass,omitempty"`
    InvoicerContactName   string `json:"invoicerContactName,omitempty"`
    InvoicerEmail         string `json:"invoicerEmail,omitempty"`

    // 공급받는자 정보
    InvoiceeCorpNum       string `json:"invoiceeCorpNum"`
    InvoiceeCorpName      string `json:"invoiceeCorpName"`
    InvoiceeCEOName       string `json:"invoiceeCEOName,omitempty"`
    InvoiceeAddr          string `json:"invoiceeAddr,omitempty"`
    InvoiceeEmail         string `json:"invoiceeEmail1,omitempty"`

    // 금액
    SupplyCostTotal   int64 `json:"supplyCostTotal"`   // 공급가액 합계
    TaxTotal          int64 `json:"taxTotal"`          // 세액 합계
    TotalAmount       int64 `json:"totalAmount"`       // 합계금액

    // 비고
    Remark1 string `json:"remark1,omitempty"`

    // 품목
    DetailList []TaxInvoiceDetail `json:"detailList"`
}

type TaxInvoiceDetail struct {
    SerialNum     int    `json:"serialNum"`     // 일련번호
    PurchaseDate  string `json:"purchaseDT"`    // 거래일자
    ItemName      string `json:"itemName"`      // 품명
    Spec          string `json:"spec,omitempty"` // 규격
    Qty           int    `json:"qty,omitempty"` // 수량
    UnitCost      int64  `json:"unitCost,omitempty"` // 단가
    SupplyCost    int64  `json:"supplyCost"`    // 공급가액
    Tax           int64  `json:"tax"`           // 세액
}

// 발행 응답
type IssueResponse struct {
    NTSConfirmNum string `json:"ntsConfirmNum"` // 국세청 승인번호
    IssueDate     string `json:"issueDate"`     // 발행일시
}

// 세금계산서 즉시 발행 (RegistIssue)
func (c *Client) IssueTaxInvoice(ctx context.Context, corpNum string, req *TaxInvoiceRequest) (*IssueResponse, error) {
    // 토큰 발급
    token, err := c.getAccessToken(ctx, corpNum, []string{"110"}) // 110: 세금계산서
    if err != nil {
        return nil, fmt.Errorf("failed to get access token: %w", err)
    }

    var result IssueResponse

    resp, err := c.httpClient.R().
        SetContext(ctx).
        SetHeader("Authorization", fmt.Sprintf("Bearer %s", token)).
        SetHeader("Content-Type", "application/json").
        SetHeader("x-pb-userid", corpNum). // 회원 아이디
        SetBody(req).
        SetResult(&result).
        Post(fmt.Sprintf("%s/Taxinvoice/%s", c.baseURL, corpNum))

    if err != nil {
        return nil, fmt.Errorf("issue request failed: %w", err)
    }

    if resp.IsError() {
        return nil, c.parseError(resp)
    }

    return &result, nil
}

// 세금계산서 상태 조회
func (c *Client) GetTaxInvoiceInfo(ctx context.Context, corpNum, mgtKey string) (*TaxInvoiceInfo, error) {
    token, err := c.getAccessToken(ctx, corpNum, []string{"110"})
    if err != nil {
        return nil, err
    }

    var result TaxInvoiceInfo

    resp, err := c.httpClient.R().
        SetContext(ctx).
        SetHeader("Authorization", fmt.Sprintf("Bearer %s", token)).
        SetResult(&result).
        Get(fmt.Sprintf("%s/Taxinvoice/%s/%s", c.baseURL, corpNum, mgtKey))

    if err != nil {
        return nil, err
    }

    if resp.IsError() {
        return nil, c.parseError(resp)
    }

    return &result, nil
}

type TaxInvoiceInfo struct {
    MgtKey        string `json:"mgtKey"`
    StateCode     int    `json:"stateCode"`     // 상태코드
    StateDT       string `json:"stateDT"`       // 상태변경일시
    NTSConfirmNum string `json:"ntsConfirmNum"` // 국세청 승인번호
    NTSSendDT     string `json:"ntsSendDT"`     // 국세청 전송일시
    NTSResultCode int    `json:"ntsResultCode"` // 국세청 처리결과
}

// 세금계산서 취소
func (c *Client) CancelTaxInvoice(ctx context.Context, corpNum, mgtKey, reason string) error {
    token, err := c.getAccessToken(ctx, corpNum, []string{"110"})
    if err != nil {
        return err
    }

    body := map[string]string{
        "memo": reason,
    }

    resp, err := c.httpClient.R().
        SetContext(ctx).
        SetHeader("Authorization", fmt.Sprintf("Bearer %s", token)).
        SetHeader("Content-Type", "application/json").
        SetBody(body).
        Post(fmt.Sprintf("%s/Taxinvoice/%s/%s?action=CANCEL", c.baseURL, corpNum, mgtKey))

    if err != nil {
        return err
    }

    if resp.IsError() {
        return c.parseError(resp)
    }

    return nil
}
```

### 2.3 세금계산서 서비스 (비즈니스 로직)

```go
// internal/service/tax/tax_invoice_service.go

package tax

import (
    "context"
    "fmt"
    "time"

    "k-erp/internal/domain"
    "k-erp/internal/infrastructure/external/popbill"
    "k-erp/internal/repository"
)

type TaxInvoiceService struct {
    repo          repository.TaxInvoiceRepository
    companyRepo   repository.CompanyRepository
    popbillClient *popbill.Client
    auditService  *audit.AuditService
}

type IssueTaxInvoiceInput struct {
    IssueType   string // 정발행/역발행
    TaxType     string // 과세/영세/면세
    BuyerCorpNum string
    BuyerName    string
    BuyerEmail   string
    Items       []TaxInvoiceItemInput
}

type TaxInvoiceItemInput struct {
    ItemDate   time.Time
    ItemName   string
    Spec       string
    Quantity   int
    UnitPrice  int64
    SupplyAmt  int64
    TaxAmt     int64
}

// 세금계산서 발행
func (s *TaxInvoiceService) IssueTaxInvoice(ctx context.Context, input *IssueTaxInvoiceInput) (*domain.TaxInvoice, error) {
    // 1. 회사 정보 조회 (공급자)
    companyID := getCompanyIDFromContext(ctx)
    company, err := s.companyRepo.FindByID(ctx, companyID)
    if err != nil {
        return nil, fmt.Errorf("회사 정보 조회 실패: %w", err)
    }

    // 2. 관리번호 생성 (고유)
    mgtKey := s.generateMgtKey(companyID)

    // 3. 금액 계산
    var totalSupply, totalTax int64
    details := make([]popbill.TaxInvoiceDetail, len(input.Items))

    for i, item := range input.Items {
        totalSupply += item.SupplyAmt
        totalTax += item.TaxAmt

        details[i] = popbill.TaxInvoiceDetail{
            SerialNum:    i + 1,
            PurchaseDate: item.ItemDate.Format("20060102"),
            ItemName:     item.ItemName,
            Spec:         item.Spec,
            Qty:          item.Quantity,
            UnitCost:     item.UnitPrice,
            SupplyCost:   item.SupplyAmt,
            Tax:          item.TaxAmt,
        }
    }

    // 4. Popbill API 호출
    popbillReq := &popbill.TaxInvoiceRequest{
        MgtKey:           mgtKey,
        WriteDate:        time.Now().Format("20060102"),
        TaxType:          input.TaxType,
        IssueType:        input.IssueType,
        InvoicerCorpNum:  company.BusinessNumber,
        InvoicerCorpName: company.Name,
        InvoicerCEOName:  company.CEOName,
        InvoicerAddr:     company.Address,
        InvoicerEmail:    company.Email,
        InvoiceeCorpNum:  input.BuyerCorpNum,
        InvoiceeCorpName: input.BuyerName,
        InvoiceeEmail:    input.BuyerEmail,
        SupplyCostTotal:  totalSupply,
        TaxTotal:         totalTax,
        TotalAmount:      totalSupply + totalTax,
        DetailList:       details,
    }

    result, err := s.popbillClient.IssueTaxInvoice(ctx, company.BusinessNumber, popbillReq)
    if err != nil {
        // Popbill 에러 로깅
        s.logPopbillError(ctx, mgtKey, err)
        return nil, fmt.Errorf("세금계산서 발행 실패: %w", err)
    }

    // 5. DB 저장
    taxInvoice := &domain.TaxInvoice{
        CompanyID:             companyID,
        MgtKey:                mgtKey,
        InvoiceNumber:         result.NTSConfirmNum,
        IssueType:             input.IssueType,
        TaxType:               input.TaxType,
        SupplierBusinessNumber: company.BusinessNumber,
        SupplierName:          company.Name,
        BuyerBusinessNumber:   input.BuyerCorpNum,
        BuyerName:             input.BuyerName,
        SupplyAmount:          totalSupply,
        TaxAmount:             totalTax,
        TotalAmount:           totalSupply + totalTax,
        IssueDate:             time.Now(),
        Status:                domain.TaxInvoiceStatusIssued,
        NTSSendDate:           parsePopbillDate(result.IssueDate),
    }

    if err := s.repo.Create(ctx, taxInvoice); err != nil {
        return nil, fmt.Errorf("세금계산서 저장 실패: %w", err)
    }

    // 6. 감사 로그
    s.auditService.Log(ctx, &audit.AuditEntry{
        Action:     domain.AuditActionCreate,
        Resource:   "tax_invoice",
        ResourceID: taxInvoice.ID.String(),
        NewValue:   taxInvoice,
    })

    return taxInvoice, nil
}

// 관리번호 생성 (회사ID + 타임스탬프 + 랜덤)
func (s *TaxInvoiceService) generateMgtKey(companyID uuid.UUID) string {
    shortID := companyID.String()[:8]
    timestamp := time.Now().Format("20060102150405")
    random := fmt.Sprintf("%04d", rand.Intn(10000))
    return fmt.Sprintf("%s%s%s", shortID, timestamp, random)
}
```

---

## 3. 4대보험 EDI 연동

### 3.1 EUC-KR 인코딩 처리

```go
// pkg/encoding/euckr.go

package encoding

import (
    "bytes"
    "fmt"
    "unicode/utf8"

    "golang.org/x/text/encoding/korean"
    "golang.org/x/text/transform"
)

// UTF-8 → EUC-KR 변환
func EncodeToEUCKR(input string) ([]byte, error) {
    encoder := korean.EUCKR.NewEncoder()
    result, _, err := transform.Bytes(encoder, []byte(input))
    if err != nil {
        return nil, fmt.Errorf("EUC-KR 인코딩 실패: %w", err)
    }
    return result, nil
}

// EUC-KR → UTF-8 변환
func DecodeFromEUCKR(input []byte) (string, error) {
    decoder := korean.EUCKR.NewDecoder()
    result, _, err := transform.Bytes(decoder, input)
    if err != nil {
        return "", fmt.Errorf("EUC-KR 디코딩 실패: %w", err)
    }
    return string(result), nil
}

// 고정길이 필드 패딩 (EUC-KR 바이트 기준)
// 한글: 2바이트, 영문/숫자: 1바이트
func PadToFixedLength(input string, length int, padChar byte) ([]byte, error) {
    encoded, err := EncodeToEUCKR(input)
    if err != nil {
        return nil, err
    }

    currentLen := len(encoded)

    if currentLen > length {
        // 초과 시 자르기 (한글 깨짐 방지)
        return truncateEUCKR(encoded, length), nil
    }

    if currentLen < length {
        // 부족 시 패딩
        padding := make([]byte, length-currentLen)
        for i := range padding {
            padding[i] = padChar
        }
        return append(encoded, padding...), nil
    }

    return encoded, nil
}

// 숫자 고정길이 (왼쪽 0 패딩)
func PadNumber(num int64, length int) string {
    format := fmt.Sprintf("%%0%dd", length)
    return fmt.Sprintf(format, num)
}

// EUC-KR 바이트를 한글 안 깨지게 자르기
func truncateEUCKR(data []byte, maxLen int) []byte {
    if len(data) <= maxLen {
        return data
    }

    // 마지막 바이트가 한글 첫 바이트인지 확인
    result := data[:maxLen]

    // EUC-KR에서 한글은 0x81-0xFE 범위의 첫 바이트로 시작
    if result[len(result)-1] >= 0x81 && result[len(result)-1] <= 0xFE {
        // 한글 첫 바이트만 있으면 제거
        result = result[:len(result)-1]
    }

    return result
}
```

### 3.2 EDI 파일 생성기

```go
// internal/infrastructure/external/edi/generator.go

package edi

import (
    "bytes"
    "fmt"
    "time"

    "k-erp/pkg/encoding"
)

// EDI 파일 타입
type EDIType string

const (
    EDITypeAcquisition EDIType = "ACQ" // 자격취득
    EDITypeLoss        EDIType = "LOS" // 자격상실
    EDITypeSalary      EDIType = "SAL" // 보수총액
)

// EDI 파일 생성기
type EDIGenerator struct {
    companyNumber string // 사업장관리번호
}

func NewEDIGenerator(companyNumber string) *EDIGenerator {
    return &EDIGenerator{companyNumber: companyNumber}
}

// 자격취득 신고 파일 생성
type AcquisitionRecord struct {
    EmployeeName       string    // 성명
    ResidentNumber     string    // 주민등록번호
    AcquisitionDate    time.Time // 취득일
    AcquisitionReason  string    // 취득사유 (1: 입사, 2: 전입 등)
    MonthlySalary      int64     // 월평균보수
    WorkType           string    // 근무형태 (1: 정규직, 2: 비정규직)
    WeeklyWorkHours    int       // 주소정근로시간
}

func (g *EDIGenerator) GenerateAcquisitionFile(records []AcquisitionRecord) ([]byte, error) {
    var buf bytes.Buffer

    // 헤더 레코드
    header := g.buildHeader(EDITypeAcquisition, len(records))
    buf.Write(header)
    buf.WriteByte('\n')

    // 데이터 레코드
    for _, rec := range records {
        line, err := g.buildAcquisitionLine(rec)
        if err != nil {
            return nil, fmt.Errorf("레코드 생성 실패: %w", err)
        }
        buf.Write(line)
        buf.WriteByte('\n')
    }

    // 트레일러 레코드
    trailer := g.buildTrailer(len(records))
    buf.Write(trailer)

    return buf.Bytes(), nil
}

// 헤더 레코드 (고정길이)
func (g *EDIGenerator) buildHeader(ediType EDIType, recordCount int) []byte {
    var buf bytes.Buffer

    // 레코드구분 (2)
    buf.WriteString("HD")

    // 사업장관리번호 (10)
    num, _ := encoding.PadToFixedLength(g.companyNumber, 10, ' ')
    buf.Write(num)

    // 신고구분 (3)
    buf.WriteString(string(ediType))

    // 작성일자 (8)
    buf.WriteString(time.Now().Format("20060102"))

    // 총건수 (6)
    buf.WriteString(encoding.PadNumber(int64(recordCount), 6))

    // 예비 (fill to 100 bytes)
    padding := make([]byte, 100-buf.Len())
    for i := range padding {
        padding[i] = ' '
    }
    buf.Write(padding)

    return buf.Bytes()
}

// 자격취득 데이터 레코드
func (g *EDIGenerator) buildAcquisitionLine(rec AcquisitionRecord) ([]byte, error) {
    var buf bytes.Buffer

    // 레코드구분 (2)
    buf.WriteString("DT")

    // 성명 (30) - EUC-KR 기준
    name, err := encoding.PadToFixedLength(rec.EmployeeName, 30, ' ')
    if err != nil {
        return nil, err
    }
    buf.Write(name)

    // 주민등록번호 (13)
    buf.WriteString(rec.ResidentNumber)

    // 취득일 (8)
    buf.WriteString(rec.AcquisitionDate.Format("20060102"))

    // 취득사유 (1)
    buf.WriteString(rec.AcquisitionReason)

    // 월평균보수 (10, 우측정렬 0패딩)
    buf.WriteString(encoding.PadNumber(rec.MonthlySalary, 10))

    // 근무형태 (1)
    buf.WriteString(rec.WorkType)

    // 주소정근로시간 (3)
    buf.WriteString(encoding.PadNumber(int64(rec.WeeklyWorkHours), 3))

    // 예비 (fill to 200 bytes)
    currentLen := buf.Len()
    if currentLen < 200 {
        padding := make([]byte, 200-currentLen)
        for i := range padding {
            padding[i] = ' '
        }
        buf.Write(padding)
    }

    return buf.Bytes(), nil
}

// 트레일러 레코드
func (g *EDIGenerator) buildTrailer(recordCount int) []byte {
    var buf bytes.Buffer

    // 레코드구분 (2)
    buf.WriteString("TR")

    // 총건수 (6)
    buf.WriteString(encoding.PadNumber(int64(recordCount), 6))

    // 예비 (fill to 100 bytes)
    padding := make([]byte, 100-buf.Len())
    for i := range padding {
        padding[i] = ' '
    }
    buf.Write(padding)

    return buf.Bytes()
}
```

### 3.3 EDI 파일 파서

```go
// internal/infrastructure/external/edi/parser.go

package edi

import (
    "bufio"
    "bytes"
    "fmt"
    "strconv"
    "strings"
    "time"

    "k-erp/pkg/encoding"
)

// EDI 응답 파일 파서
type EDIParser struct{}

type ParsedResult struct {
    Header   *HeaderRecord
    Records  []DataRecord
    Trailer  *TrailerRecord
    Errors   []ParseError
}

type HeaderRecord struct {
    RecordType    string
    CompanyNumber string
    ReportType    string
    CreateDate    time.Time
    TotalCount    int
}

type DataRecord struct {
    LineNumber     int
    EmployeeName   string
    ResidentNumber string
    ResultCode     string    // 처리결과 (00: 정상, 그 외: 오류)
    ResultMessage  string    // 오류메시지
    ProcessedDate  time.Time
}

type TrailerRecord struct {
    RecordType   string
    TotalCount   int
    SuccessCount int
    ErrorCount   int
}

type ParseError struct {
    LineNumber int
    Field      string
    Message    string
}

func NewEDIParser() *EDIParser {
    return &EDIParser{}
}

// 응답 파일 파싱
func (p *EDIParser) ParseResponseFile(data []byte) (*ParsedResult, error) {
    result := &ParsedResult{
        Records: make([]DataRecord, 0),
        Errors:  make([]ParseError, 0),
    }

    scanner := bufio.NewScanner(bytes.NewReader(data))
    lineNum := 0

    for scanner.Scan() {
        lineNum++
        line := scanner.Bytes()

        // EUC-KR → UTF-8 변환
        utf8Line, err := encoding.DecodeFromEUCKR(line)
        if err != nil {
            result.Errors = append(result.Errors, ParseError{
                LineNumber: lineNum,
                Field:      "encoding",
                Message:    fmt.Sprintf("인코딩 변환 실패: %v", err),
            })
            continue
        }

        // 레코드 타입 확인
        if len(utf8Line) < 2 {
            continue
        }

        recordType := utf8Line[:2]

        switch recordType {
        case "HD":
            header, err := p.parseHeader(utf8Line)
            if err != nil {
                result.Errors = append(result.Errors, ParseError{
                    LineNumber: lineNum,
                    Field:      "header",
                    Message:    err.Error(),
                })
            } else {
                result.Header = header
            }

        case "DT":
            record, err := p.parseDataRecord(utf8Line, lineNum)
            if err != nil {
                result.Errors = append(result.Errors, ParseError{
                    LineNumber: lineNum,
                    Field:      "data",
                    Message:    err.Error(),
                })
            } else {
                result.Records = append(result.Records, *record)
            }

        case "TR":
            trailer, err := p.parseTrailer(utf8Line)
            if err != nil {
                result.Errors = append(result.Errors, ParseError{
                    LineNumber: lineNum,
                    Field:      "trailer",
                    Message:    err.Error(),
                })
            } else {
                result.Trailer = trailer
            }
        }
    }

    return result, nil
}

func (p *EDIParser) parseHeader(line string) (*HeaderRecord, error) {
    if len(line) < 29 {
        return nil, fmt.Errorf("헤더 길이 부족: %d", len(line))
    }

    totalCount, err := strconv.Atoi(strings.TrimSpace(line[23:29]))
    if err != nil {
        totalCount = 0
    }

    createDate, _ := time.Parse("20060102", line[15:23])

    return &HeaderRecord{
        RecordType:    line[0:2],
        CompanyNumber: strings.TrimSpace(line[2:12]),
        ReportType:    line[12:15],
        CreateDate:    createDate,
        TotalCount:    totalCount,
    }, nil
}

func (p *EDIParser) parseDataRecord(line string, lineNum int) (*DataRecord, error) {
    if len(line) < 100 {
        return nil, fmt.Errorf("데이터 레코드 길이 부족: %d", len(line))
    }

    processedDate, _ := time.Parse("20060102", strings.TrimSpace(line[53:61]))

    return &DataRecord{
        LineNumber:     lineNum,
        EmployeeName:   strings.TrimSpace(line[2:32]),
        ResidentNumber: strings.TrimSpace(line[32:45]),
        ResultCode:     strings.TrimSpace(line[45:47]),
        ResultMessage:  strings.TrimSpace(line[47:97]),
        ProcessedDate:  processedDate,
    }, nil
}

func (p *EDIParser) parseTrailer(line string) (*TrailerRecord, error) {
    if len(line) < 20 {
        return nil, fmt.Errorf("트레일러 길이 부족")
    }

    totalCount, _ := strconv.Atoi(strings.TrimSpace(line[2:8]))
    successCount, _ := strconv.Atoi(strings.TrimSpace(line[8:14]))
    errorCount, _ := strconv.Atoi(strings.TrimSpace(line[14:20]))

    return &TrailerRecord{
        RecordType:   line[0:2],
        TotalCount:   totalCount,
        SuccessCount: successCount,
        ErrorCount:   errorCount,
    }, nil
}
```

### 3.4 SFTP 전송 클라이언트

```go
// internal/infrastructure/external/edi/sftp_client.go

package edi

import (
    "context"
    "fmt"
    "io"
    "os"
    "path/filepath"
    "time"

    "github.com/pkg/sftp"
    "golang.org/x/crypto/ssh"
)

type SFTPConfig struct {
    Host           string
    Port           int
    User           string
    PrivateKeyPath string        // SSH 개인키 경로
    KnownHostsPath string        // known_hosts 경로
    Timeout        time.Duration
    RemoteDir      string        // 원격 업로드 디렉토리
}

type SFTPClient struct {
    config *SFTPConfig
}

func NewSFTPClient(config *SFTPConfig) *SFTPClient {
    return &SFTPClient{config: config}
}

// 파일 업로드
func (c *SFTPClient) Upload(ctx context.Context, localPath, remoteName string) error {
    // SSH 연결
    conn, err := c.connect()
    if err != nil {
        return fmt.Errorf("SSH 연결 실패: %w", err)
    }
    defer conn.Close()

    // SFTP 클라이언트 생성
    client, err := sftp.NewClient(conn)
    if err != nil {
        return fmt.Errorf("SFTP 클라이언트 생성 실패: %w", err)
    }
    defer client.Close()

    // 로컬 파일 열기
    localFile, err := os.Open(localPath)
    if err != nil {
        return fmt.Errorf("로컬 파일 열기 실패: %w", err)
    }
    defer localFile.Close()

    // 원격 파일 생성
    remotePath := filepath.Join(c.config.RemoteDir, remoteName)
    remoteFile, err := client.Create(remotePath)
    if err != nil {
        return fmt.Errorf("원격 파일 생성 실패: %w", err)
    }
    defer remoteFile.Close()

    // 복사
    _, err = io.Copy(remoteFile, localFile)
    if err != nil {
        return fmt.Errorf("파일 전송 실패: %w", err)
    }

    return nil
}

// 파일 다운로드 (응답 파일)
func (c *SFTPClient) Download(ctx context.Context, remoteName, localPath string) error {
    conn, err := c.connect()
    if err != nil {
        return err
    }
    defer conn.Close()

    client, err := sftp.NewClient(conn)
    if err != nil {
        return err
    }
    defer client.Close()

    // 원격 파일 열기
    remotePath := filepath.Join(c.config.RemoteDir, remoteName)
    remoteFile, err := client.Open(remotePath)
    if err != nil {
        return fmt.Errorf("원격 파일 열기 실패: %w", err)
    }
    defer remoteFile.Close()

    // 로컬 파일 생성
    localFile, err := os.Create(localPath)
    if err != nil {
        return fmt.Errorf("로컬 파일 생성 실패: %w", err)
    }
    defer localFile.Close()

    // 복사
    _, err = io.Copy(localFile, remoteFile)
    return err
}

// 파일 목록 조회
func (c *SFTPClient) ListFiles(ctx context.Context, pattern string) ([]string, error) {
    conn, err := c.connect()
    if err != nil {
        return nil, err
    }
    defer conn.Close()

    client, err := sftp.NewClient(conn)
    if err != nil {
        return nil, err
    }
    defer client.Close()

    files, err := client.ReadDir(c.config.RemoteDir)
    if err != nil {
        return nil, err
    }

    var result []string
    for _, f := range files {
        if matched, _ := filepath.Match(pattern, f.Name()); matched {
            result = append(result, f.Name())
        }
    }

    return result, nil
}

// SSH 연결
func (c *SFTPClient) connect() (*ssh.Client, error) {
    // 개인키 읽기
    key, err := os.ReadFile(c.config.PrivateKeyPath)
    if err != nil {
        return nil, fmt.Errorf("개인키 읽기 실패: %w", err)
    }

    signer, err := ssh.ParsePrivateKey(key)
    if err != nil {
        return nil, fmt.Errorf("개인키 파싱 실패: %w", err)
    }

    config := &ssh.ClientConfig{
        User: c.config.User,
        Auth: []ssh.AuthMethod{
            ssh.PublicKeys(signer),
        },
        Timeout:         c.config.Timeout,
        HostKeyCallback: ssh.InsecureIgnoreHostKey(), // 실제 운영에서는 known_hosts 검증 필요
    }

    addr := fmt.Sprintf("%s:%d", c.config.Host, c.config.Port)
    return ssh.Dial("tcp", addr, config)
}
```

### 3.5 EDI 서비스 (스케줄링 포함)

```go
// internal/service/edi/edi_service.go

package edi

import (
    "context"
    "fmt"
    "os"
    "path/filepath"
    "time"

    "github.com/robfig/cron/v3"
    "k-erp/internal/domain"
    "k-erp/internal/infrastructure/external/edi"
    "k-erp/internal/repository"
)

type EDIService struct {
    generator    *edi.EDIGenerator
    parser       *edi.EDIParser
    sftpClient   *edi.SFTPClient
    employeeRepo repository.EmployeeRepository
    ediBatchRepo repository.EDIBatchRepository
    scheduler    *cron.Cron
    tempDir      string
}

type EDIServiceConfig struct {
    TempDir       string
    SFTPConfig    *edi.SFTPConfig
    CompanyNumber string
}

func NewEDIService(config *EDIServiceConfig, employeeRepo repository.EmployeeRepository, ediBatchRepo repository.EDIBatchRepository) *EDIService {
    return &EDIService{
        generator:    edi.NewEDIGenerator(config.CompanyNumber),
        parser:       edi.NewEDIParser(),
        sftpClient:   edi.NewSFTPClient(config.SFTPConfig),
        employeeRepo: employeeRepo,
        ediBatchRepo: ediBatchRepo,
        scheduler:    cron.New(),
        tempDir:      config.TempDir,
    }
}

// 자격취득 신고 생성 및 전송
func (s *EDIService) ProcessAcquisition(ctx context.Context, employeeIDs []uuid.UUID) (*domain.EDIBatch, error) {
    // 1. 직원 정보 조회
    employees, err := s.employeeRepo.FindByIDs(ctx, employeeIDs)
    if err != nil {
        return nil, fmt.Errorf("직원 조회 실패: %w", err)
    }

    // 2. EDI 레코드 생성
    records := make([]edi.AcquisitionRecord, len(employees))
    for i, emp := range employees {
        records[i] = edi.AcquisitionRecord{
            EmployeeName:      emp.Name,
            ResidentNumber:    emp.ResidentNumber, // 이미 복호화됨
            AcquisitionDate:   emp.HireDate,
            AcquisitionReason: "1", // 입사
            MonthlySalary:     emp.BaseSalary,
            WorkType:          "1", // 정규직
            WeeklyWorkHours:   40,
        }
    }

    // 3. EDI 파일 생성
    fileContent, err := s.generator.GenerateAcquisitionFile(records)
    if err != nil {
        return nil, fmt.Errorf("EDI 파일 생성 실패: %w", err)
    }

    // 4. 임시 파일 저장
    fileName := fmt.Sprintf("ACQ_%s_%s.dat",
        s.generator.companyNumber,
        time.Now().Format("20060102150405"),
    )
    localPath := filepath.Join(s.tempDir, fileName)

    if err := os.WriteFile(localPath, fileContent, 0600); err != nil {
        return nil, fmt.Errorf("임시 파일 저장 실패: %w", err)
    }
    defer os.Remove(localPath) // 전송 후 삭제

    // 5. SFTP 전송
    if err := s.sftpClient.Upload(ctx, localPath, fileName); err != nil {
        return nil, fmt.Errorf("SFTP 전송 실패: %w", err)
    }

    // 6. 배치 기록 저장
    batch := &domain.EDIBatch{
        CompanyID:   getCompanyIDFromContext(ctx),
        BatchType:   domain.EDIBatchTypeAcquisition,
        FileName:    fileName,
        RecordCount: len(records),
        Status:      domain.EDIBatchStatusSent,
        SentAt:      time.Now(),
    }

    if err := s.ediBatchRepo.Create(ctx, batch); err != nil {
        return nil, fmt.Errorf("배치 기록 저장 실패: %w", err)
    }

    return batch, nil
}

// 응답 파일 처리
func (s *EDIService) ProcessResponse(ctx context.Context, batchID uuid.UUID) error {
    // 1. 배치 정보 조회
    batch, err := s.ediBatchRepo.FindByID(ctx, batchID)
    if err != nil {
        return err
    }

    // 2. 응답 파일 다운로드
    responseFileName := fmt.Sprintf("RES_%s", batch.FileName)
    localPath := filepath.Join(s.tempDir, responseFileName)

    if err := s.sftpClient.Download(ctx, responseFileName, localPath); err != nil {
        return fmt.Errorf("응답 파일 다운로드 실패: %w", err)
    }
    defer os.Remove(localPath)

    // 3. 파일 파싱
    content, err := os.ReadFile(localPath)
    if err != nil {
        return err
    }

    result, err := s.parser.ParseResponseFile(content)
    if err != nil {
        return fmt.Errorf("응답 파일 파싱 실패: %w", err)
    }

    // 4. 결과 업데이트
    batch.Status = domain.EDIBatchStatusProcessed
    batch.SuccessCount = result.Trailer.SuccessCount
    batch.ErrorCount = result.Trailer.ErrorCount
    batch.ProcessedAt = time.Now()

    if err := s.ediBatchRepo.Update(ctx, batch); err != nil {
        return err
    }

    // 5. 개별 레코드 결과 저장
    for _, rec := range result.Records {
        if rec.ResultCode != "00" {
            // 오류 레코드 저장
            s.ediBatchRepo.CreateErrorRecord(ctx, &domain.EDIErrorRecord{
                BatchID:        batchID,
                EmployeeName:   rec.EmployeeName,
                ResidentNumber: rec.ResidentNumber,
                ErrorCode:      rec.ResultCode,
                ErrorMessage:   rec.ResultMessage,
            })
        }
    }

    return nil
}

// 스케줄러 시작
func (s *EDIService) StartScheduler() {
    // 매월 10일 오전 9시에 보수총액 신고 확인
    s.scheduler.AddFunc("0 9 10 * *", func() {
        // TODO: 보수총액 신고 자동 처리
    })

    // 매일 오전 10시에 응답 파일 확인
    s.scheduler.AddFunc("0 10 * * *", func() {
        // TODO: 응답 파일 자동 처리
    })

    s.scheduler.Start()
}

func (s *EDIService) StopScheduler() {
    s.scheduler.Stop()
}
```

---

## 4. 공동인증서 관리

### 4.1 인증서 저장 및 관리

```go
// internal/infrastructure/external/edi/cert_manager.go

package edi

import (
    "crypto"
    "crypto/x509"
    "encoding/pem"
    "fmt"
    "os"

    "software.sslmate.com/src/go-pkcs12"
)

type CertificateManager struct {
    certPath string
    password string
}

func NewCertificateManager(certPath, password string) *CertificateManager {
    return &CertificateManager{
        certPath: certPath,
        password: password,
    }
}

// PFX/P12 파일에서 인증서 로드
func (m *CertificateManager) LoadCertificate() (*x509.Certificate, crypto.PrivateKey, error) {
    // PFX 파일 읽기
    pfxData, err := os.ReadFile(m.certPath)
    if err != nil {
        return nil, nil, fmt.Errorf("인증서 파일 읽기 실패: %w", err)
    }

    // PFX 디코딩
    privateKey, cert, err := pkcs12.Decode(pfxData, m.password)
    if err != nil {
        return nil, nil, fmt.Errorf("인증서 디코딩 실패: %w", err)
    }

    return cert, privateKey, nil
}

// 인증서 유효성 검증
func (m *CertificateManager) ValidateCertificate() error {
    cert, _, err := m.LoadCertificate()
    if err != nil {
        return err
    }

    // 만료일 확인
    if cert.NotAfter.Before(time.Now()) {
        return fmt.Errorf("인증서가 만료되었습니다: %v", cert.NotAfter)
    }

    // 30일 이내 만료 경고
    if cert.NotAfter.Before(time.Now().AddDate(0, 0, 30)) {
        // 경고 로그 또는 알림
    }

    return nil
}

// 인증서 정보 조회
func (m *CertificateManager) GetCertificateInfo() (*CertificateInfo, error) {
    cert, _, err := m.LoadCertificate()
    if err != nil {
        return nil, err
    }

    return &CertificateInfo{
        Subject:   cert.Subject.String(),
        Issuer:    cert.Issuer.String(),
        NotBefore: cert.NotBefore,
        NotAfter:  cert.NotAfter,
        SerialNumber: cert.SerialNumber.String(),
    }, nil
}

type CertificateInfo struct {
    Subject      string
    Issuer       string
    NotBefore    time.Time
    NotAfter     time.Time
    SerialNumber string
}
```

### 4.2 인증서 저장 보안

```go
// 인증서는 절대 일반 파일시스템에 저장하지 않음
// Vault 또는 암호화된 저장소 사용

// 예: AWS Secrets Manager 연동
func (m *CertificateManager) LoadFromSecretsManager(secretName string) (*x509.Certificate, crypto.PrivateKey, error) {
    // AWS SDK로 시크릿 조회
    sess := session.Must(session.NewSession())
    svc := secretsmanager.New(sess)

    result, err := svc.GetSecretValue(&secretsmanager.GetSecretValueInput{
        SecretId: aws.String(secretName),
    })
    if err != nil {
        return nil, nil, err
    }

    // 시크릿에서 PFX 데이터와 비밀번호 추출
    var secret struct {
        CertData string `json:"cert_data"` // base64 encoded
        Password string `json:"password"`
    }
    json.Unmarshal([]byte(*result.SecretString), &secret)

    pfxData, _ := base64.StdEncoding.DecodeString(secret.CertData)
    return pkcs12.Decode(pfxData, secret.Password)
}
```

---

## 5. 에러 처리 및 재시도

### 5.1 외부 API 에러 처리

```go
// pkg/errors/external.go

package errors

import "fmt"

// 외부 연동 에러
type ExternalError struct {
    Service   string // popbill, edi, bank
    Operation string // issue, upload, query
    Code      string
    Message   string
    Retryable bool
    Cause     error
}

func (e *ExternalError) Error() string {
    return fmt.Sprintf("[%s] %s failed: %s - %s", e.Service, e.Operation, e.Code, e.Message)
}

func (e *ExternalError) Unwrap() error {
    return e.Cause
}

// 재시도 가능 에러 생성
func NewRetryableError(service, operation, code, message string, cause error) *ExternalError {
    return &ExternalError{
        Service:   service,
        Operation: operation,
        Code:      code,
        Message:   message,
        Retryable: true,
        Cause:     cause,
    }
}

// 재시도 불가 에러 생성
func NewPermanentError(service, operation, code, message string, cause error) *ExternalError {
    return &ExternalError{
        Service:   service,
        Operation: operation,
        Code:      code,
        Message:   message,
        Retryable: false,
        Cause:     cause,
    }
}
```

### 5.2 재시도 로직

```go
// pkg/retry/retry.go

package retry

import (
    "context"
    "math"
    "time"

    "k-erp/pkg/errors"
)

type Config struct {
    MaxAttempts     int
    InitialDelay    time.Duration
    MaxDelay        time.Duration
    BackoffFactor   float64
}

var DefaultConfig = Config{
    MaxAttempts:   3,
    InitialDelay:  1 * time.Second,
    MaxDelay:      30 * time.Second,
    BackoffFactor: 2.0,
}

func Do(ctx context.Context, config Config, fn func() error) error {
    var lastErr error

    for attempt := 1; attempt <= config.MaxAttempts; attempt++ {
        err := fn()
        if err == nil {
            return nil
        }

        lastErr = err

        // 재시도 가능한 에러인지 확인
        var extErr *errors.ExternalError
        if errors.As(err, &extErr) && !extErr.Retryable {
            return err // 재시도 불가 에러는 즉시 반환
        }

        // 마지막 시도면 반환
        if attempt == config.MaxAttempts {
            break
        }

        // 지수 백오프 대기
        delay := time.Duration(float64(config.InitialDelay) * math.Pow(config.BackoffFactor, float64(attempt-1)))
        if delay > config.MaxDelay {
            delay = config.MaxDelay
        }

        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-time.After(delay):
            // 재시도
        }
    }

    return lastErr
}
```

---

## 6. 모니터링 및 알림

### 6.1 연동 상태 모니터링

```go
// internal/service/external/monitor.go

package external

import (
    "context"
    "time"

    "github.com/prometheus/client_golang/prometheus"
)

var (
    externalAPILatency = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "kerp_external_api_latency_seconds",
            Help:    "External API call latency",
            Buckets: prometheus.DefBuckets,
        },
        []string{"service", "operation"},
    )

    externalAPIErrors = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "kerp_external_api_errors_total",
            Help: "External API error count",
        },
        []string{"service", "operation", "error_code"},
    )

    externalAPISuccess = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "kerp_external_api_success_total",
            Help: "External API success count",
        },
        []string{"service", "operation"},
    )
)

func init() {
    prometheus.MustRegister(externalAPILatency)
    prometheus.MustRegister(externalAPIErrors)
    prometheus.MustRegister(externalAPISuccess)
}

// 외부 API 호출 래퍼
func MonitorExternalCall(service, operation string, fn func() error) error {
    start := time.Now()
    err := fn()
    duration := time.Since(start).Seconds()

    externalAPILatency.WithLabelValues(service, operation).Observe(duration)

    if err != nil {
        var code string
        var extErr *errors.ExternalError
        if errors.As(err, &extErr) {
            code = extErr.Code
        } else {
            code = "unknown"
        }
        externalAPIErrors.WithLabelValues(service, operation, code).Inc()
    } else {
        externalAPISuccess.WithLabelValues(service, operation).Inc()
    }

    return err
}
```

### 6.2 알림 서비스

```go
// internal/service/notification/external_alert.go

package notification

import (
    "context"
    "fmt"
)

type AlertService struct {
    slackWebhook string
    emailService *EmailService
}

type ExternalAlert struct {
    Service   string
    Operation string
    ErrorCode string
    Message   string
    Severity  string // critical, warning, info
}

func (s *AlertService) SendExternalAlert(ctx context.Context, alert *ExternalAlert) error {
    message := fmt.Sprintf(
        "[%s] 외부 연동 오류\n서비스: %s\n작업: %s\n에러코드: %s\n메시지: %s",
        alert.Severity,
        alert.Service,
        alert.Operation,
        alert.ErrorCode,
        alert.Message,
    )

    // Slack 알림
    if alert.Severity == "critical" {
        if err := s.sendSlack(message); err != nil {
            // 로깅만, 실패해도 계속 진행
        }
    }

    // 이메일 알림 (담당자)
    if alert.Severity == "critical" || alert.Severity == "warning" {
        s.emailService.SendToAdmins(ctx, "외부 연동 오류 알림", message)
    }

    return nil
}
```

---

**문서 버전**: 1.0
**작성일**: 2025년 1월
**다음 검토일**: 2025년 4월
