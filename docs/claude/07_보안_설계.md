# K-ERP 보안 설계서

## 1. 보안 개요

### 1.1 보안 요구사항

```
┌─────────────────────────────────────────────────────────────────┐
│                    K-ERP 보안 요구사항                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [규제 준수]                                                     │
│  • 개인정보보호법 (PIPA)                                         │
│  • 정보통신망법                                                  │
│  • 전자금융거래법                                                │
│  • K-ISMS 인증 요건                                              │
│                                                                  │
│  [보호 대상 데이터]                                              │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Critical (최고 보호)                                    │    │
│  │  • 주민등록번호, 외국인등록번호                          │    │
│  │  • 계좌번호, 카드번호                                    │    │
│  │  • 공동인증서, API 키                                    │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │  High (높은 보호)                                        │    │
│  │  • 급여 정보, 4대보험 정보                               │    │
│  │  • 세금계산서 데이터                                     │    │
│  │  • 거래처 정보                                           │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │  Medium (일반 보호)                                      │    │
│  │  • 전표, 원장, 재무제표                                  │    │
│  │  • 품목, 재고 정보                                       │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 보안 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                    보안 계층 아키텍처                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    네트워크 보안                         │    │
│  │  WAF │ DDoS 방어 │ IP 화이트리스트 │ TLS 1.3           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    애플리케이션 보안                     │    │
│  │  인증/인가 │ 입력 검증 │ CSRF/XSS 방어 │ Rate Limit    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    데이터 보안                           │    │
│  │  암호화 │ 마스킹 │ 접근 제어 │ 감사 로그               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    인프라 보안                           │    │
│  │  시크릿 관리 │ 컨테이너 보안 │ 네트워크 분리            │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 인증/인가 (Authentication & Authorization)

### 2.1 JWT 기반 인증

```go
// internal/infrastructure/auth/jwt.go

package auth

import (
    "time"
    "github.com/golang-jwt/jwt/v5"
)

type JWTConfig struct {
    SecretKey          string        // 환경변수에서 로드
    AccessTokenExpiry  time.Duration // 15분
    RefreshTokenExpiry time.Duration // 7일
    Issuer             string        // "k-erp"
}

type Claims struct {
    jwt.RegisteredClaims
    UserID    string   `json:"user_id"`
    CompanyID string   `json:"company_id"`  // 테넌트 식별
    Roles     []string `json:"roles"`
    SessionID string   `json:"session_id"`  // 세션 무효화용
}

// 토큰 생성
func (j *JWTService) GenerateTokenPair(user *domain.User) (*TokenPair, error) {
    // Access Token (짧은 수명)
    accessClaims := &Claims{
        RegisteredClaims: jwt.RegisteredClaims{
            Subject:   user.ID.String(),
            Issuer:    j.config.Issuer,
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(j.config.AccessTokenExpiry)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            ID:        uuid.New().String(),
        },
        UserID:    user.ID.String(),
        CompanyID: user.CompanyID.String(),
        Roles:     user.GetRoleNames(),
        SessionID: uuid.New().String(),
    }

    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
    accessTokenString, err := accessToken.SignedString([]byte(j.config.SecretKey))
    if err != nil {
        return nil, fmt.Errorf("failed to sign access token: %w", err)
    }

    // Refresh Token (긴 수명, Redis에 저장)
    refreshToken := uuid.New().String()
    err = j.redis.Set(ctx,
        fmt.Sprintf("refresh:%s", refreshToken),
        user.ID.String(),
        j.config.RefreshTokenExpiry,
    ).Err()
    if err != nil {
        return nil, fmt.Errorf("failed to store refresh token: %w", err)
    }

    return &TokenPair{
        AccessToken:  accessTokenString,
        RefreshToken: refreshToken,
        ExpiresIn:    int(j.config.AccessTokenExpiry.Seconds()),
    }, nil
}

// 토큰 검증
func (j *JWTService) ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return []byte(j.config.SecretKey), nil
    })

    if err != nil {
        return nil, fmt.Errorf("failed to parse token: %w", err)
    }

    claims, ok := token.Claims.(*Claims)
    if !ok || !token.Valid {
        return nil, errors.New("invalid token claims")
    }

    // 세션 무효화 확인 (로그아웃된 토큰인지)
    isRevoked, _ := j.redis.Exists(ctx, fmt.Sprintf("revoked:%s", claims.ID)).Result()
    if isRevoked > 0 {
        return nil, errors.New("token has been revoked")
    }

    return claims, nil
}

// 토큰 무효화 (로그아웃)
func (j *JWTService) RevokeToken(claims *Claims) error {
    // 토큰 만료 시간까지 블랙리스트에 유지
    ttl := time.Until(claims.ExpiresAt.Time)
    return j.redis.Set(ctx,
        fmt.Sprintf("revoked:%s", claims.ID),
        "1",
        ttl,
    ).Err()
}
```

### 2.2 인증 미들웨어

```go
// internal/middleware/auth.go

package middleware

import (
    "strings"
    "github.com/gin-gonic/gin"
)

func AuthMiddleware(jwtService *auth.JWTService) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. Authorization 헤더 추출
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(401, gin.H{
                "success": false,
                "error": gin.H{
                    "code":    "UNAUTHORIZED",
                    "message": "Authorization header required",
                },
            })
            return
        }

        // 2. Bearer 토큰 파싱
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.AbortWithStatusJSON(401, gin.H{
                "success": false,
                "error": gin.H{
                    "code":    "UNAUTHORIZED",
                    "message": "Invalid authorization format",
                },
            })
            return
        }

        // 3. 토큰 검증
        claims, err := jwtService.ValidateToken(parts[1])
        if err != nil {
            c.AbortWithStatusJSON(401, gin.H{
                "success": false,
                "error": gin.H{
                    "code":    "UNAUTHORIZED",
                    "message": "Invalid or expired token",
                },
            })
            return
        }

        // 4. 컨텍스트에 사용자 정보 저장
        c.Set("user_id", claims.UserID)
        c.Set("company_id", claims.CompanyID)
        c.Set("roles", claims.Roles)
        c.Set("session_id", claims.SessionID)

        c.Next()
    }
}
```

### 2.3 RBAC (Role-Based Access Control)

```go
// internal/domain/permission.go

package domain

type Permission string

const (
    // 회계
    PermVoucherCreate   Permission = "voucher:create"
    PermVoucherRead     Permission = "voucher:read"
    PermVoucherUpdate   Permission = "voucher:update"
    PermVoucherDelete   Permission = "voucher:delete"
    PermVoucherApprove  Permission = "voucher:approve"

    // 세금계산서
    PermTaxInvoiceCreate Permission = "tax_invoice:create"
    PermTaxInvoiceRead   Permission = "tax_invoice:read"
    PermTaxInvoiceCancel Permission = "tax_invoice:cancel"

    // 급여
    PermPayrollRead      Permission = "payroll:read"
    PermPayrollProcess   Permission = "payroll:process"
    PermPayrollApprove   Permission = "payroll:approve"

    // 직원 (민감정보)
    PermEmployeeReadBasic    Permission = "employee:read:basic"
    PermEmployeeReadSensitive Permission = "employee:read:sensitive" // 주민번호 등
    PermEmployeeCreate       Permission = "employee:create"
    PermEmployeeUpdate       Permission = "employee:update"

    // 시스템
    PermUserManage       Permission = "user:manage"
    PermRoleManage       Permission = "role:manage"
    PermCompanySettings  Permission = "company:settings"
    PermAuditLogRead     Permission = "audit_log:read"
)

// 기본 역할 정의
var DefaultRoles = map[string][]Permission{
    "admin": {
        PermVoucherCreate, PermVoucherRead, PermVoucherUpdate, PermVoucherDelete, PermVoucherApprove,
        PermTaxInvoiceCreate, PermTaxInvoiceRead, PermTaxInvoiceCancel,
        PermPayrollRead, PermPayrollProcess, PermPayrollApprove,
        PermEmployeeReadBasic, PermEmployeeReadSensitive, PermEmployeeCreate, PermEmployeeUpdate,
        PermUserManage, PermRoleManage, PermCompanySettings, PermAuditLogRead,
    },
    "accountant": {
        PermVoucherCreate, PermVoucherRead, PermVoucherUpdate,
        PermTaxInvoiceCreate, PermTaxInvoiceRead,
        PermEmployeeReadBasic,
    },
    "hr_manager": {
        PermPayrollRead, PermPayrollProcess,
        PermEmployeeReadBasic, PermEmployeeReadSensitive, PermEmployeeCreate, PermEmployeeUpdate,
    },
    "viewer": {
        PermVoucherRead,
        PermTaxInvoiceRead,
        PermEmployeeReadBasic,
    },
}
```

```go
// internal/middleware/rbac.go

package middleware

func RequirePermission(perms ...domain.Permission) gin.HandlerFunc {
    return func(c *gin.Context) {
        roles, exists := c.Get("roles")
        if !exists {
            c.AbortWithStatusJSON(403, gin.H{
                "success": false,
                "error": gin.H{
                    "code":    "FORBIDDEN",
                    "message": "No roles assigned",
                },
            })
            return
        }

        userRoles := roles.([]string)

        // 필요한 권한 중 하나라도 있는지 확인
        for _, requiredPerm := range perms {
            for _, role := range userRoles {
                rolePerms, ok := domain.DefaultRoles[role]
                if !ok {
                    continue
                }
                for _, perm := range rolePerms {
                    if perm == requiredPerm {
                        c.Next()
                        return
                    }
                }
            }
        }

        c.AbortWithStatusJSON(403, gin.H{
            "success": false,
            "error": gin.H{
                "code":    "FORBIDDEN",
                "message": "Insufficient permissions",
                "required": perms,
            },
        })
    }
}

// 사용 예시
// router.POST("/vouchers",
//     middleware.AuthMiddleware(jwtService),
//     middleware.RequirePermission(domain.PermVoucherCreate),
//     voucherHandler.Create,
// )
```

---

## 3. 데이터 암호화

### 3.1 암호화 전략

```
┌─────────────────────────────────────────────────────────────────┐
│                      암호화 전략                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [전송 중 암호화 (In Transit)]                                  │
│  • TLS 1.3 필수                                                  │
│  • 내부 서비스 간 통신도 mTLS 적용                              │
│  • HTTP → HTTPS 리다이렉트 강제                                 │
│                                                                  │
│  [저장 시 암호화 (At Rest)]                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  레벨 1: 디스크 암호화                                   │    │
│  │  • AWS EBS / GCP Persistent Disk 자동 암호화            │    │
│  │  • PostgreSQL data directory 암호화                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  레벨 2: 컬럼 레벨 암호화 (민감 데이터)                  │    │
│  │  • 주민등록번호: AES-256-GCM                            │    │
│  │  • 계좌번호: AES-256-GCM                                │    │
│  │  • 비밀번호: bcrypt (해시)                               │    │
│  └─────────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  레벨 3: 키 관리                                         │    │
│  │  • AWS KMS / HashiCorp Vault                            │    │
│  │  • 키 자동 로테이션 (90일)                              │    │
│  │  • 키 사용 감사 로그                                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 암호화 구현

```go
// pkg/crypto/aes.go

package crypto

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "io"
)

type AESEncryptor struct {
    key []byte // 32 bytes for AES-256
}

func NewAESEncryptor(keyBase64 string) (*AESEncryptor, error) {
    key, err := base64.StdEncoding.DecodeString(keyBase64)
    if err != nil {
        return nil, fmt.Errorf("invalid key format: %w", err)
    }
    if len(key) != 32 {
        return nil, fmt.Errorf("key must be 32 bytes for AES-256")
    }
    return &AESEncryptor{key: key}, nil
}

// Encrypt encrypts plaintext using AES-256-GCM
func (e *AESEncryptor) Encrypt(plaintext string) (string, error) {
    block, err := aes.NewCipher(e.key)
    if err != nil {
        return "", fmt.Errorf("failed to create cipher: %w", err)
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", fmt.Errorf("failed to create GCM: %w", err)
    }

    // 랜덤 nonce 생성
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", fmt.Errorf("failed to generate nonce: %w", err)
    }

    // 암호화 (nonce + ciphertext)
    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// Decrypt decrypts ciphertext using AES-256-GCM
func (e *AESEncryptor) Decrypt(ciphertextBase64 string) (string, error) {
    ciphertext, err := base64.StdEncoding.DecodeString(ciphertextBase64)
    if err != nil {
        return "", fmt.Errorf("invalid ciphertext format: %w", err)
    }

    block, err := aes.NewCipher(e.key)
    if err != nil {
        return "", fmt.Errorf("failed to create cipher: %w", err)
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", fmt.Errorf("failed to create GCM: %w", err)
    }

    nonceSize := gcm.NonceSize()
    if len(ciphertext) < nonceSize {
        return "", fmt.Errorf("ciphertext too short")
    }

    nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", fmt.Errorf("failed to decrypt: %w", err)
    }

    return string(plaintext), nil
}
```

### 3.3 민감 데이터 필드 암호화 (GORM Hook)

```go
// internal/domain/employee.go

package domain

import (
    "gorm.io/gorm"
    "k-erp/pkg/crypto"
)

type Employee struct {
    ID                    uuid.UUID `gorm:"type:uuid;primary_key"`
    CompanyID             uuid.UUID `gorm:"type:uuid;index;not null"`
    EmployeeNumber        string    `gorm:"size:20;not null"`
    Name                  string    `gorm:"size:50;not null"`

    // 암호화 저장 (DB에는 암호문)
    ResidentNumberEnc     string    `gorm:"column:resident_number;size:200"`
    BankAccountEnc        string    `gorm:"column:bank_account;size:200"`

    // 평문 (DB에 저장 안 함)
    ResidentNumber        string    `gorm:"-"`
    BankAccount           string    `gorm:"-"`

    // ... 기타 필드
}

// 저장 전 암호화
func (e *Employee) BeforeCreate(tx *gorm.DB) error {
    return e.encryptSensitiveFields()
}

func (e *Employee) BeforeUpdate(tx *gorm.DB) error {
    return e.encryptSensitiveFields()
}

func (e *Employee) encryptSensitiveFields() error {
    encryptor := crypto.GetEncryptor() // 싱글톤으로 관리

    if e.ResidentNumber != "" {
        encrypted, err := encryptor.Encrypt(e.ResidentNumber)
        if err != nil {
            return fmt.Errorf("failed to encrypt resident number: %w", err)
        }
        e.ResidentNumberEnc = encrypted
    }

    if e.BankAccount != "" {
        encrypted, err := encryptor.Encrypt(e.BankAccount)
        if err != nil {
            return fmt.Errorf("failed to encrypt bank account: %w", err)
        }
        e.BankAccountEnc = encrypted
    }

    return nil
}

// 조회 후 복호화
func (e *Employee) AfterFind(tx *gorm.DB) error {
    encryptor := crypto.GetEncryptor()

    if e.ResidentNumberEnc != "" {
        decrypted, err := encryptor.Decrypt(e.ResidentNumberEnc)
        if err != nil {
            return fmt.Errorf("failed to decrypt resident number: %w", err)
        }
        e.ResidentNumber = decrypted
    }

    if e.BankAccountEnc != "" {
        decrypted, err := encryptor.Decrypt(e.BankAccountEnc)
        if err != nil {
            return fmt.Errorf("failed to decrypt bank account: %w", err)
        }
        e.BankAccount = decrypted
    }

    return nil
}
```

### 3.4 비밀번호 해싱

```go
// pkg/crypto/password.go

package crypto

import (
    "golang.org/x/crypto/bcrypt"
)

const bcryptCost = 12 // 보안 vs 성능 균형

// HashPassword hashes password using bcrypt
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcryptCost)
    return string(bytes), err
}

// CheckPassword compares password with hash
func CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// 비밀번호 정책 검증
func ValidatePasswordPolicy(password string) error {
    if len(password) < 8 {
        return errors.New("password must be at least 8 characters")
    }

    var hasUpper, hasLower, hasNumber, hasSpecial bool
    for _, c := range password {
        switch {
        case unicode.IsUpper(c):
            hasUpper = true
        case unicode.IsLower(c):
            hasLower = true
        case unicode.IsNumber(c):
            hasNumber = true
        case unicode.IsPunct(c) || unicode.IsSymbol(c):
            hasSpecial = true
        }
    }

    if !hasUpper || !hasLower || !hasNumber || !hasSpecial {
        return errors.New("password must contain uppercase, lowercase, number, and special character")
    }

    return nil
}
```

---

## 4. 감사 로그 (Audit Log)

### 4.1 감사 로그 설계

```go
// internal/domain/audit_log.go

package domain

import (
    "time"
    "github.com/google/uuid"
)

type AuditAction string

const (
    AuditActionCreate  AuditAction = "CREATE"
    AuditActionRead    AuditAction = "READ"
    AuditActionUpdate  AuditAction = "UPDATE"
    AuditActionDelete  AuditAction = "DELETE"
    AuditActionLogin   AuditAction = "LOGIN"
    AuditActionLogout  AuditAction = "LOGOUT"
    AuditActionExport  AuditAction = "EXPORT"
    AuditActionApprove AuditAction = "APPROVE"
)

type AuditLog struct {
    ID          uuid.UUID   `gorm:"type:uuid;primary_key"`
    CompanyID   uuid.UUID   `gorm:"type:uuid;index;not null"`
    UserID      uuid.UUID   `gorm:"type:uuid;index;not null"`
    Action      AuditAction `gorm:"size:20;not null;index"`
    Resource    string      `gorm:"size:50;not null;index"`  // voucher, employee, tax_invoice
    ResourceID  string      `gorm:"size:50"`                  // 대상 리소스 ID

    // 변경 내용
    OldValue    string      `gorm:"type:jsonb"`               // 변경 전 (JSON)
    NewValue    string      `gorm:"type:jsonb"`               // 변경 후 (JSON)

    // 요청 정보
    IPAddress   string      `gorm:"size:45"`                  // IPv6 지원
    UserAgent   string      `gorm:"size:500"`
    RequestID   string      `gorm:"size:50;index"`            // 분산 트레이싱용

    // 메타데이터
    Description string      `gorm:"size:500"`
    CreatedAt   time.Time   `gorm:"index;not null"`
}

// 인덱스 정의
func (AuditLog) TableName() string {
    return "audit_logs"
}
```

### 4.2 감사 로그 서비스

```go
// internal/service/audit/audit_service.go

package audit

import (
    "context"
    "encoding/json"
    "github.com/gin-gonic/gin"
)

type AuditService struct {
    repo AuditRepository
}

type AuditEntry struct {
    Action      domain.AuditAction
    Resource    string
    ResourceID  string
    OldValue    interface{}
    NewValue    interface{}
    Description string
}

// 감사 로그 기록
func (s *AuditService) Log(ctx context.Context, entry *AuditEntry) error {
    // Gin context에서 사용자 정보 추출
    ginCtx, ok := ctx.(*gin.Context)
    if !ok {
        return errors.New("invalid context")
    }

    userID, _ := ginCtx.Get("user_id")
    companyID, _ := ginCtx.Get("company_id")
    requestID, _ := ginCtx.Get("request_id")

    var oldValueJSON, newValueJSON string
    if entry.OldValue != nil {
        b, _ := json.Marshal(entry.OldValue)
        oldValueJSON = string(b)
    }
    if entry.NewValue != nil {
        b, _ := json.Marshal(entry.NewValue)
        newValueJSON = string(b)
    }

    log := &domain.AuditLog{
        ID:          uuid.New(),
        CompanyID:   uuid.MustParse(companyID.(string)),
        UserID:      uuid.MustParse(userID.(string)),
        Action:      entry.Action,
        Resource:    entry.Resource,
        ResourceID:  entry.ResourceID,
        OldValue:    oldValueJSON,
        NewValue:    newValueJSON,
        IPAddress:   ginCtx.ClientIP(),
        UserAgent:   ginCtx.GetHeader("User-Agent"),
        RequestID:   requestID.(string),
        Description: entry.Description,
        CreatedAt:   time.Now(),
    }

    // 비동기 저장 (성능 영향 최소화)
    go func() {
        if err := s.repo.Create(context.Background(), log); err != nil {
            // 로그 저장 실패는 시스템 로그에 기록
            logger.Error("failed to save audit log", zap.Error(err))
        }
    }()

    return nil
}

// 민감 데이터 조회 시 감사 로그
func (s *AuditService) LogSensitiveAccess(ctx context.Context, resource, resourceID string) error {
    return s.Log(ctx, &AuditEntry{
        Action:      domain.AuditActionRead,
        Resource:    resource,
        ResourceID:  resourceID,
        Description: "Sensitive data accessed",
    })
}
```

### 4.3 감사 로그 미들웨어

```go
// internal/middleware/audit.go

package middleware

// 민감 데이터 접근 감사
func AuditSensitiveAccess(auditService *audit.AuditService) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 요청 처리 후 감사 로그 기록
        c.Next()

        // 민감 리소스 접근인 경우만 기록
        resource := c.GetString("audit_resource")
        resourceID := c.GetString("audit_resource_id")

        if resource != "" {
            auditService.LogSensitiveAccess(c, resource, resourceID)
        }
    }
}

// 변경 작업 감사 (Create/Update/Delete)
func AuditMutation(auditService *audit.AuditService) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 요청 본문 캡처 (변경 전/후 비교용)
        var requestBody []byte
        if c.Request.Body != nil {
            requestBody, _ = io.ReadAll(c.Request.Body)
            c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))
        }

        c.Next()

        // 성공한 변경 작업만 감사 로그
        if c.Writer.Status() >= 200 && c.Writer.Status() < 300 {
            action := getActionFromMethod(c.Request.Method)
            auditService.Log(c, &audit.AuditEntry{
                Action:     action,
                Resource:   c.GetString("audit_resource"),
                ResourceID: c.GetString("audit_resource_id"),
                NewValue:   string(requestBody),
            })
        }
    }
}
```

---

## 5. 입력 검증 및 보안

### 5.1 입력 검증

```go
// pkg/validator/validator.go

package validator

import (
    "regexp"
    "github.com/go-playground/validator/v10"
)

var validate *validator.Validate

func init() {
    validate = validator.New()

    // 한국 사업자번호 검증
    validate.RegisterValidation("business_number", validateBusinessNumber)

    // 한국 주민등록번호 검증
    validate.RegisterValidation("resident_number", validateResidentNumber)

    // SQL Injection 방지
    validate.RegisterValidation("safe_string", validateSafeString)
}

// 사업자번호 검증 (10자리 + 체크섬)
func validateBusinessNumber(fl validator.FieldLevel) bool {
    bn := fl.Field().String()
    if len(bn) != 10 {
        return false
    }

    // 숫자만 허용
    if !regexp.MustCompile(`^\d{10}$`).MatchString(bn) {
        return false
    }

    // 체크섬 검증
    weights := []int{1, 3, 7, 1, 3, 7, 1, 3, 5}
    sum := 0
    for i := 0; i < 9; i++ {
        sum += int(bn[i]-'0') * weights[i]
    }
    sum += (int(bn[8]-'0') * 5) / 10
    checkDigit := (10 - (sum % 10)) % 10

    return checkDigit == int(bn[9]-'0')
}

// SQL Injection 방지 (위험 문자 차단)
func validateSafeString(fl validator.FieldLevel) bool {
    dangerous := []string{"--", ";", "'", "\"", "/*", "*/", "xp_", "sp_"}
    value := fl.Field().String()

    for _, d := range dangerous {
        if strings.Contains(strings.ToLower(value), d) {
            return false
        }
    }
    return true
}
```

### 5.2 XSS 방지

```go
// pkg/sanitizer/html.go

package sanitizer

import (
    "html"
    "regexp"
)

// HTML 특수문자 이스케이프
func EscapeHTML(input string) string {
    return html.EscapeString(input)
}

// 위험한 태그/속성 제거
func SanitizeHTML(input string) string {
    // script, iframe, onclick 등 제거
    patterns := []string{
        `<script[^>]*>.*?</script>`,
        `<iframe[^>]*>.*?</iframe>`,
        `on\w+\s*=\s*["'][^"']*["']`,
        `javascript:`,
    }

    result := input
    for _, pattern := range patterns {
        re := regexp.MustCompile(`(?i)` + pattern)
        result = re.ReplaceAllString(result, "")
    }

    return result
}
```

### 5.3 Rate Limiting

```go
// internal/middleware/ratelimit.go

package middleware

import (
    "time"
    "github.com/gin-gonic/gin"
    "github.com/go-redis/redis_rate/v10"
)

type RateLimitConfig struct {
    // 일반 API
    GeneralLimit  int           // 100
    GeneralWindow time.Duration // 1분

    // 인증 API (브루트포스 방지)
    AuthLimit  int           // 5
    AuthWindow time.Duration // 5분

    // 민감 API (세금계산서 발행 등)
    SensitiveLimit  int           // 10
    SensitiveWindow time.Duration // 1분
}

func RateLimitMiddleware(redis *redis.Client, config *RateLimitConfig) gin.HandlerFunc {
    limiter := redis_rate.NewLimiter(redis)

    return func(c *gin.Context) {
        // 키 생성 (IP + User ID)
        key := fmt.Sprintf("ratelimit:%s:%s", c.ClientIP(), c.GetString("user_id"))

        // 경로별 제한
        var limit int
        var window time.Duration

        switch {
        case strings.HasPrefix(c.Request.URL.Path, "/api/v1/auth"):
            limit = config.AuthLimit
            window = config.AuthWindow
        case strings.HasPrefix(c.Request.URL.Path, "/api/v1/tax-invoices"):
            limit = config.SensitiveLimit
            window = config.SensitiveWindow
        default:
            limit = config.GeneralLimit
            window = config.GeneralWindow
        }

        res, err := limiter.Allow(c, key, redis_rate.PerDuration(limit, window))
        if err != nil {
            c.AbortWithStatusJSON(500, gin.H{"error": "rate limit error"})
            return
        }

        // 응답 헤더에 제한 정보 추가
        c.Header("X-RateLimit-Limit", strconv.Itoa(limit))
        c.Header("X-RateLimit-Remaining", strconv.Itoa(res.Remaining))
        c.Header("X-RateLimit-Reset", strconv.FormatInt(res.ResetAfter.Milliseconds(), 10))

        if res.Remaining < 0 {
            c.AbortWithStatusJSON(429, gin.H{
                "success": false,
                "error": gin.H{
                    "code":    "TOO_MANY_REQUESTS",
                    "message": "Rate limit exceeded",
                    "retry_after": res.ResetAfter.Seconds(),
                },
            })
            return
        }

        c.Next()
    }
}
```

---

## 6. 시크릿 관리

### 6.1 환경변수 구조

```yaml
# .env.example (실제 값은 절대 커밋 금지)

# 데이터베이스
DATABASE_URL=postgres://user:pass@localhost:5432/kerp?sslmode=require
DATABASE_MAX_CONNECTIONS=25
DATABASE_MAX_IDLE=5

# Redis
REDIS_URL=redis://:password@localhost:6379/0

# JWT
JWT_SECRET_KEY=your-256-bit-secret-key-here
JWT_ACCESS_EXPIRY=15m
JWT_REFRESH_EXPIRY=168h

# 암호화 키 (AES-256)
ENCRYPTION_KEY=base64-encoded-32-byte-key

# Popbill
POPBILL_LINK_ID=your-link-id
POPBILL_SECRET_KEY=your-secret-key
POPBILL_IS_TEST=true

# 4대보험 EDI
EDI_SFTP_HOST=sftp.4insure.or.kr
EDI_SFTP_USER=your-user
EDI_SFTP_KEY_PATH=/path/to/private/key
EDI_CERT_PATH=/path/to/cert.pfx
EDI_CERT_PASSWORD=cert-password

# 기타
APP_ENV=development
LOG_LEVEL=debug
```

### 6.2 HashiCorp Vault 연동 (프로덕션)

```go
// pkg/config/vault.go

package config

import (
    "github.com/hashicorp/vault/api"
)

type VaultClient struct {
    client *api.Client
    path   string
}

func NewVaultClient(addr, token, path string) (*VaultClient, error) {
    config := api.DefaultConfig()
    config.Address = addr

    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }

    client.SetToken(token)

    return &VaultClient{
        client: client,
        path:   path,
    }, nil
}

// 시크릿 조회
func (v *VaultClient) GetSecret(key string) (string, error) {
    secret, err := v.client.Logical().Read(fmt.Sprintf("%s/data/%s", v.path, key))
    if err != nil {
        return "", err
    }

    if secret == nil || secret.Data == nil {
        return "", fmt.Errorf("secret not found: %s", key)
    }

    data, ok := secret.Data["data"].(map[string]interface{})
    if !ok {
        return "", fmt.Errorf("invalid secret format")
    }

    value, ok := data["value"].(string)
    if !ok {
        return "", fmt.Errorf("invalid secret value type")
    }

    return value, nil
}

// 시크릿 로테이션 감지
func (v *VaultClient) WatchSecrets(ctx context.Context, callback func(key, value string)) {
    // Vault의 lease renewal 또는 polling으로 변경 감지
}
```

### 6.3 Kubernetes Secrets (선택적)

```yaml
# deployments/k8s/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: kerp-secrets
  namespace: kerp
type: Opaque
stringData:
  DATABASE_URL: postgres://...
  JWT_SECRET_KEY: ...
  ENCRYPTION_KEY: ...

---
# External Secrets Operator 사용 시
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: kerp-vault-secrets
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: kerp-secrets
  data:
    - secretKey: DATABASE_URL
      remoteRef:
        key: kerp/database
        property: url
```

---

## 7. 네트워크 보안

### 7.1 보안 그룹 설계

```
┌─────────────────────────────────────────────────────────────────┐
│                    네트워크 보안 아키텍처                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [Public Subnet]                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  ALB / WAF                                               │    │
│  │  • 인바운드: 443 (HTTPS) only                           │    │
│  │  • WAF 규칙: OWASP Top 10 방어                          │    │
│  │  • DDoS 방어 (AWS Shield)                               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                   │
│  [Private Subnet - App]                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  API Server / Worker Pods                                │    │
│  │  • 인바운드: ALB에서만 (SG 제한)                        │    │
│  │  • 아웃바운드: DB, Redis, 외부 API                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                   │
│  [Private Subnet - Data]                                        │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  PostgreSQL / Redis                                      │    │
│  │  • 인바운드: App Subnet에서만                           │    │
│  │  • 아웃바운드: 없음                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  [VPC Endpoints]                                                │
│  • S3 Gateway Endpoint                                          │
│  • Secrets Manager Interface Endpoint                           │
│  • KMS Interface Endpoint                                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 7.2 WAF 규칙

```yaml
# AWS WAF 규칙 (Terraform)
resource "aws_wafv2_web_acl" "kerp" {
  name  = "kerp-waf"
  scope = "REGIONAL"

  default_action {
    allow {}
  }

  # SQL Injection 방어
  rule {
    name     = "SQLInjectionRule"
    priority = 1

    override_action {
      none {}
    }

    statement {
      managed_rule_group_statement {
        name        = "AWSManagedRulesSQLiRuleSet"
        vendor_name = "AWS"
      }
    }

    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "SQLInjectionRule"
      sampled_requests_enabled   = true
    }
  }

  # XSS 방어
  rule {
    name     = "XSSRule"
    priority = 2

    statement {
      managed_rule_group_statement {
        name        = "AWSManagedRulesKnownBadInputsRuleSet"
        vendor_name = "AWS"
      }
    }
  }

  # Rate Limiting
  rule {
    name     = "RateLimitRule"
    priority = 3

    action {
      block {}
    }

    statement {
      rate_based_statement {
        limit              = 2000
        aggregate_key_type = "IP"
      }
    }
  }
}
```

---

## 8. 보안 체크리스트

### 8.1 개발 단계

```
□ 입력값 검증 (모든 사용자 입력)
□ SQL 파라미터 바인딩 (PreparedStatement)
□ XSS 방어 (출력 이스케이프)
□ CSRF 토큰 적용
□ 민감 데이터 암호화
□ 비밀번호 정책 적용
□ 에러 메시지 민감정보 제외
□ 로그에 민감정보 마스킹
□ 의존성 취약점 스캔 (Snyk, Dependabot)
□ 정적 분석 도구 적용 (gosec)
```

### 8.2 배포 단계

```
□ TLS 1.3 적용
□ 보안 헤더 설정 (CSP, HSTS, X-Frame-Options)
□ 불필요한 포트 차단
□ 시크릿 환경변수/Vault 사용
□ 컨테이너 non-root 실행
□ 이미지 취약점 스캔
□ 네트워크 분리 (VPC)
□ WAF 적용
□ DDoS 방어 설정
□ 백업 암호화
```

### 8.3 운영 단계

```
□ 감사 로그 모니터링
□ 이상 접근 알림 설정
□ 정기 취약점 점검
□ 침투 테스트 (연 1회)
□ 시크릿 로테이션 (90일)
□ 인증서 갱신 관리
□ 보안 패치 적용 프로세스
□ 인시던트 대응 계획
□ 데이터 백업 복구 테스트
□ 접근 권한 정기 검토
```

---

**문서 버전**: 1.0
**작성일**: 2025년 1월
**다음 검토일**: 2025년 4월
